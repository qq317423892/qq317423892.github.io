<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一次使用Github + Hexo搭建博客</title>
    <url>/2021/03/21/hello-world/</url>
    <content><![CDATA[<p>偶然看到一个大神的文章，讲到怎么使用GitHub跟Hexo搭建博客，便依照大神给的方法尝试了一遍，便有了今天这个博客。大神的<a href="https://imzlp.com/posts/58952/">博客链接</a></p>
<p>环境: Win10</p>
<h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h2><h3 id="1-1-安装必要工具"><a href="#1-1-安装必要工具" class="headerlink" title="1.1 安装必要工具"></a>1.1 安装必要工具</h3><ul>
<li>node.js</li>
<li>git</li>
<li>github账号</li>
</ul>
<h3 id="1-2-创建自己的github-io"><a href="#1-2-创建自己的github-io" class="headerlink" title="1.2 创建自己的github.io"></a>1.2 创建自己的github.io</h3><p>登录你注册号的github账号，在账户下创建一个特殊的仓库(repo)，命名是固定的:your_github_id.github.io</p>
<span id="more"></span>

<h3 id="1-3-生成公私钥"><a href="#1-3-生成公私钥" class="headerlink" title="1.3 生成公私钥"></a>1.3 生成公私钥</h3><p>安装好Git软件后，在cmd命令行中生成SSH keys。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;emain_address@youremail.com&quot;</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa key pair.</span><br><span class="line">Enter <span class="keyword">file</span> in which to save the key (C:\Users\your_user_directory<span class="regexp">/.ssh/i</span>d_rsa)::</span><br></pre></td></tr></table></figure>
<p>然后系统会要求你输入秘钥名字，按回车就好，接着按照提示输入密码即可。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in C:\Users\your_user_directory/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in C:\Users\your_user_directory/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:UWMR/4HrfxACapJAMSyi2aCBcsvsAU1VDw1TBtwmE8c emain_address<span class="meta">@youremail.com</span></span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|<span class="string">      .+*.+ .oo. </span>|</span><br><span class="line">|<span class="string">       . * ..o.  </span>|</span><br><span class="line">|<span class="string">        o oE +o  </span>|</span><br><span class="line">|<span class="string">        oo+.+.o  </span>|</span><br><span class="line">|<span class="string">       oS= =.. . </span>|</span><br><span class="line">|<span class="string">      o B o     .</span>|</span><br><span class="line">|<span class="string">       * o. ..  +</span>|</span><br><span class="line">|<span class="string">      . .. ...oo+</span>|</span><br><span class="line">|<span class="string">        .. .o===B</span>|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<h3 id="1-4-配置SSH-Key到GitHub"><a href="#1-4-配置SSH-Key到GitHub" class="headerlink" title="1.4 配置SSH Key到GitHub"></a>1.4 配置SSH Key到GitHub</h3><ul>
<li>打开本地 <strong>C:\Users\your_user_directory/.ssh/id_rsa.pub</strong>文件，复制文件里的公钥内容。</li>
<li>登录github系统，点击页面上 左上角个人图标 -&gt; Settings -&gt;  SSH keys -&gt; ADD SSH Key</li>
<li>把刚刚复制的密钥复制到Key文本框中，点击add key就ok了</li>
</ul>
<p>测试密钥是否能访问(当前目录下的密钥文件：blog_ssh)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">ssh -<span class="selector-tag">i</span> blog_ssh git<span class="keyword">@github</span>.com</span><br></pre></td></tr></table></figure>
<p>如果密钥设置了密码访问，则按照提示输入密码，出现以下提示表示访问成功了。</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">E:</span>\Blog\blog\doc&gt;ssh -i blog git@github.com</span><br><span class="line">Enter passphrase <span class="keyword">for</span> <span class="keyword">key</span> <span class="comment">&#x27;blog&#x27;:</span></span><br><span class="line">PTY allocation request failed <span class="keyword">on</span> channel <span class="number">0</span></span><br><span class="line">Hi your_github_id! You<span class="comment">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line">Connection <span class="keyword">to</span> github.com closed.</span><br></pre></td></tr></table></figure>

<h2 id="2-Hexo使用"><a href="#2-Hexo使用" class="headerlink" title="2. Hexo使用"></a>2. Hexo使用</h2><h3 id="2-1-安装Hexo"><a href="#2-1-安装Hexo" class="headerlink" title="2.1 安装Hexo"></a>2.1 安装Hexo</h3><p>在你要创建博客的目录下，鼠标右键，打开gitbash<br><img src="/images/hello_world/git_bash.png" width=20% height=20% align="left"/> <br><br><br><br><br><br><br><br><br><br><br></p>
<p>在打开的MINGW64窗口输入以下指令安装Hexo(先安装了node.js才能使用npm指令)</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g hexo</span><br></pre></td></tr></table></figure>

<h3 id="2-1-部署Hexo"><a href="#2-1-部署Hexo" class="headerlink" title="2.1 部署Hexo"></a>2.1 部署Hexo</h3><p>新建一个Blog文件夹，然后在该文件夹打开Git Bash</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>Hexo会在这个目录下自动创建建立博客网站需要的文件。<br>然后我们可以通过执行下面指令，预览本地博客，本地地址：<strong>localhost:4000</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>

<p>设置部署到Github前，需要先安装部署插件 hexo-deployer-git</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p>修改Blog根目录下的_cofig.yml配置文件。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repository:</span> git@github.com:qq317423892/qq317423892.github.io.git</span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure>
<p>执行后就可以使用下列指令部署，注意部署会覆盖你之前在版本库中存放的文件，如果有文件不想被覆盖，可以放到Blog/source目录例如:Blog/source/CNAME</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
<p>或者使用组合命令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo d -g</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>hexo clean 清理生成的文件<br>  hexo g 或者 hexo generate 可以生成网站文件<br>  hexo s 或者 hexo server 可以启动本地服务器</p>
</blockquote>
<p>注意在gitbash中部署时，要手动添加密钥，可以使用下面指令</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">eval $(ssh-agent -s) <span class="comment">#启动ssh服务</span></span><br><span class="line">ssh-add <span class="regexp">/c/</span>Users<span class="regexp">/your_use_name/</span>.ssh/blog_ssh <span class="comment"># 添加ssh文件: c:\Users\your_user_name\.ssh\blog_ssh</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-更换主题NexT"><a href="#2-2-更换主题NexT" class="headerlink" title="2.2 更换主题NexT"></a>2.2 更换主题NexT</h3><p>在blog目录下拉取Next主题资源</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/iissnan/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<p>打开blog跟目录配置文件：_cofig.yml，找到theme选项，改成next</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## Themes: https:<span class="comment">//hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>由于Hexo在5.0版本把swig给删除了，需要自己手动安装:hexo-renderer-swig</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-renderer-swig</span><br></pre></td></tr></table></figure>
<p>即可解决下面的渲染报错<br><img src="/images/hello_world/next_theme_err.png" width=100% height=100% /></p>
<h3 id="2-3-站点概况"><a href="#2-3-站点概况" class="headerlink" title="2.3 站点概况"></a>2.3 站点概况</h3><img src="/images/hello_world/site_info.png" width=20% height=20% align="left" />
这里对应根目录下的配置文件：_config.yml
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line"><span class="symbol">title:</span> 十三的blog</span><br><span class="line"><span class="symbol">subtitle:</span> <span class="comment">&#x27;安心学技术&#x27;</span></span><br><span class="line"><span class="symbol">description:</span> </span><br><span class="line"><span class="symbol">keywords:</span> <span class="string">&quot;Unity, UE4&quot;</span></span><br><span class="line"><span class="symbol">author:</span> 小贤</span><br><span class="line"><span class="symbol">language:</span> zh-Hans</span><br><span class="line"><span class="symbol">timezone:</span> <span class="comment">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<br>
<br>
<br>

<img src="/images/hello_world/site_info_avatar.png" width=20% height=20% align="left" />
这里对应的是next目录下的配置文件:_config.yml
显示头像
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(<span class="keyword">source</span><span class="regexp">/images): /im</span>ages/avatar.gif</span><br><span class="line"># in site  directory(<span class="keyword">source</span><span class="regexp">/uploads): /u</span>ploads/avatar.gif</span><br><span class="line">avatar: <span class="regexp">/images/</span>avatar.jpg</span><br></pre></td></tr></table></figure>
显示名字跟描述：在next目录下的配置文件中手动添加下面两行
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">author:</span> 小贤</span><br><span class="line"><span class="symbol">description:</span> Watch <span class="built_in">and</span> learn, your magic <span class="built_in">is</span> mine!</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-4-新增目录"><a href="#2-4-新增目录" class="headerlink" title="2.4 新增目录"></a>2.4 新增目录</h3><p>侧边栏的目录项配置在next主题下的配置文件：_config.yml</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> /|| home</span><br><span class="line"><span class="symbol">  about:</span> <span class="meta-keyword">/about/</span>|| user</span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span>|| tags</span><br><span class="line"><span class="symbol">  categories:</span> <span class="meta-keyword">/categories/</span>|| th</span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span>|| archive</span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="meta">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<p>可以通过下面的指令增加对应的目录，配置文件中的 || 前面不要留空格，否则标签页访问会失败</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">page</span> <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-新建文章"><a href="#2-5-新建文章" class="headerlink" title="2.5 新建文章"></a>2.5 新建文章</h3><p>新增文章用下面的指令，会在默认的文件夹下新增文章（默认的是:blog/source/_posts），打开对应的路径，可以看到新增的md文件，编辑文章就可以了。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;test_article&quot;</span></span><br></pre></td></tr></table></figure>
<p>打开md文件，可以设置文章的分类跟标签Tag</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Test</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-03-25 12:52:30</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">Unity</span>, <span class="string">C#</span>, <span class="string">InjectFix</span>]</span><br><span class="line"><span class="attr">categories:</span> <span class="string">Unity开发</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-设置文章字数"><a href="#2-6-设置文章字数" class="headerlink" title="2.6 设置文章字数"></a>2.6 设置文章字数</h3><p>先安装插件</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm i <span class="comment">--save hexo-wordcount</span></span><br></pre></td></tr></table></figure>
<p>打开next主题下的配置文件:_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>wordcount:显示字数<br>min2read: 显示阅读时长<br>totalcount：博客总字数</p>
</blockquote>
<h3 id="2-7-设置文章分割（全部显示）"><a href="#2-7-设置文章分割（全部显示）" class="headerlink" title="2.7 设置文章分割（全部显示）"></a>2.7 设置文章分割（全部显示）</h3><p>推荐自己在文章中插入:<font color=#A50A0A ><strong>&lt;!– more –&gt;</strong> </font> ，也可以设置auto_excerpt，length表示字数。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Automatically Excerpt. Not recommend.</span><br><span class="line"># Please use <span class="comment">&lt;!-- more --&gt;</span> in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<h3 id="2-8-站内搜索"><a href="#2-8-站内搜索" class="headerlink" title="2.8 站内搜索"></a>2.8 站内搜索</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-<span class="keyword">search</span> <span class="comment">--save</span></span><br><span class="line">npm install hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Dependencies: https:<span class="operator">/</span><span class="operator">/</span>github.com<span class="operator">/</span>flashlab<span class="operator">/</span>hexo<span class="operator">-</span>generator<span class="operator">-</span><span class="keyword">search</span></span><br><span class="line">local_search:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  # if auto, <span class="keyword">trigger</span> <span class="keyword">search</span> <span class="keyword">by</span> changing input</span><br><span class="line">  # if manual, <span class="keyword">trigger</span> <span class="keyword">search</span> <span class="keyword">by</span> pressing enter key <span class="keyword">or</span> <span class="keyword">search</span> button</span><br><span class="line">  <span class="keyword">trigger</span>: auto</span><br><span class="line">  # <span class="keyword">show</span> top n results <span class="keyword">per</span> article, <span class="keyword">show</span> <span class="keyword">all</span> results <span class="keyword">by</span> setting <span class="keyword">to</span> <span class="number">-1</span></span><br><span class="line">  top_n_per_article: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-9-plantUML"><a href="#2-9-plantUML" class="headerlink" title="2.9 plantUML"></a>2.9 plantUML</h3><p>npm install hexo-tag-plantuml</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">title Relationships - <span class="keyword">Class</span> Diagram</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dwelling &#123;</span><br><span class="line">  +<span class="type">Int</span> Windows</span><br><span class="line">  +<span class="type">void</span> LockTheDoor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Apartment</span><br><span class="line"><span class="keyword">class</span> House</span><br><span class="line"><span class="keyword">class</span> Commune</span><br><span class="line"><span class="keyword">class</span> <span class="keyword">Window</span></span><br><span class="line"><span class="keyword">class</span> Door</span><br><span class="line"></span><br><span class="line">Dwelling &lt;|-down- Apartment: Inheritance</span><br><span class="line">Dwelling &lt;|-down- Commune: Inheritance</span><br><span class="line">Dwelling &lt;|-down- House: Inheritance</span><br><span class="line">Dwelling &quot;1&quot; *-up- &quot;many&quot; <span class="keyword">Window</span>: Composition</span><br><span class="line">Dwelling &quot;1&quot; *-up- &quot;many&quot; Door: Composition</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<img  src=http://www.plantuml.com/plantuml/svg/XP0z2y8m48Rt_8gZanzaS2qkKWSBJY8uXpQqXybTQ5ABgF_TrhQAuCUMbpptt4V0O3Jij541cNo9peE4n2ZlOOsgg9GL8kjZeur1Ak0Y0EOf1JWWvTpuBfuOSzXoTjoNUirSJQRYDXQkdAg2rHI6lE7Qw-6TiBKrZQaNZlrQZH3FhikhRFz8ldGnf5Jg2eEYJ7y01_S_x37E5oXQH32JjPCGMKNdQ9WmxjoEFNP7-q5tAxonTm00><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>InjectFix学习笔记</title>
    <url>/2021/03/25/injectfix-doc/</url>
    <content><![CDATA[<h2 id="1-InjectFix-工作流程"><a href="#1-InjectFix-工作流程" class="headerlink" title="1.InjectFix 工作流程"></a>1.InjectFix 工作流程</h2><ul>
<li>打新包<ul>
<li>其他预处理</li>
<li>预先配置好需要Patch的类跟函数，提交配置Configure代码</li>
<li>打包机打包时，自动reload被Inject的dll，保证当前的dll没有被注入过</li>
<li>调用InjectFix提供的注入函数，注入WrappersManagerImpl，ILFixInterfaceBridge，ILFixDynamicMethodWrapper，IDMAP-1跟插桩代码dll</li>
<li>执行il2cpp处理</li>
<li>执行其他预处理</li>
</ul>
</li>
<li>Patch阶段<ul>
<li>修复代码<ul>
<li>修复函数：使用标签[IFix.Patch]</li>
<li>新增类、属性、方法：使用标签[IFix.Interpret] </li>
</ul>
</li>
<li>调用InjectFix提供的打Patch函数，生成Patch文件</li>
<li>生成Patch文件的AssetsBuddle包</li>
<li>上传更新过后的AssetsBuddle包</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps：在patch过程中，如果没有重新打出新的包体，不要删除Patch标签</p>
</blockquote>
<span id="more"></span>

<h2 id="2-InjectFix-工作原理"><a href="#2-InjectFix-工作原理" class="headerlink" title="2.InjectFix 工作原理"></a>2.InjectFix 工作原理</h2><h3 id="2-1-Inject阶段"><a href="#2-1-Inject阶段" class="headerlink" title="2.1 Inject阶段"></a>2.1 Inject阶段</h3><h3 id="2-1-1-IFix-跟-IFix-Filter-标签"><a href="#2-1-1-IFix-跟-IFix-Filter-标签" class="headerlink" title="2.1.1 [IFix]跟[IFix.Filter]标签"></a>2.1.1 [IFix]跟[IFix.Filter]标签</h3><p>在Inject阶段，预先对有可能需要修复的类跟函数提交配置类，调用Inject处理函数时，会对这些写上标签的函数注入插桩代码，例如有如下代码，其中Add跟Sub目前逻辑是错误的，是需要修复的函数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">IFix.Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Mult</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Div</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包时需要配置对应的配置类，具体配置<strong>Configure</strong>类如下，其中 <strong>[Configure]</strong> 标签是配置类的标签，用来配置注入阶段需要注入或者过滤的内容，配置类必须放在<strong>Editor</strong>目录下。</p>
<ul>
<li><strong>[IFix]</strong> 标签 ：用来配置需要注入的类型</li>
<li><strong>[IFix.Filter]</strong> 标签 ：用来过滤不需要的字段</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Configure</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloworldCfg</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">IFix</span>]</span><br><span class="line">    <span class="keyword">static</span> IEnumerable&lt;Type&gt; hotfix</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Type&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">typeof</span>(IFix.Test.Calculator),</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">IFix.Filter</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Filter</span>(<span class="params">System.Reflection.MethodInfo methodInfo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> methodInfo.DeclaringType.FullName == <span class="string">&quot;IFix.Test.Calculator&quot;</span> </span><br><span class="line">            &amp;&amp; (methodInfo.Name == <span class="string">&quot;Div&quot;</span> || methodInfo.Name == <span class="string">&quot;Mult&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>ILSpy工具</strong>查看注入后dll，看到生成如下代码，其中<strong>Add</strong>跟<strong>Sub</strong>方法增加了注入代码，<strong>Mult</strong>跟<strong>Div</strong>函数因为在配置类中被过滤了，没有注入代码。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IFix.WrappersManagerImpl.IsPatched(<span class="number">6</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> IFix.WrappersManagerImpl.GetPatch(<span class="number">6</span>).__Gen_Wrap_1(<span class="keyword">this</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IFix.WrappersManagerImpl.IsPatched(<span class="number">7</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> IFix.WrappersManagerImpl.GetPatch(<span class="number">7</span>).__Gen_Wrap_1(<span class="keyword">this</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Mult</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Div</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了插桩代码，注入阶段还会注入几个相关的代码，其中<strong>IDMAP0</strong>是修复函数的索引ID，当索引值超过32760时，会生成下一个<strong>IDMAP1</strong>，依次类推。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IDMAP0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">IFix</span>-Test-Calculator-Add0 = <span class="number">6</span>,</span><br><span class="line">    <span class="built_in">IFix</span>-Test-Calculator-Sub0,</span><br><span class="line">    Helloworld-test0 = <span class="number">5</span>,</span><br><span class="line">    Helloworld-Start0 = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的GetPatch(<strong>6</strong>)中的参数<strong>6</strong>对应到注入代码中IDMAP0中<strong>IFix-Test-Calculator-Add0</strong></p>
<p>注入WrappersManagerImpl类代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WrappersManagerImpl</span> : <span class="title">WrappersManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> VirtualMachine virtualMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappersManagerImpl</span>(<span class="params">VirtualMachine virtualMachine</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine = virtualMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILFixDynamicMethodWrapper <span class="title">GetPatch</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> ILFixDynamicMethodWrapper.wrapperArray[id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsPatched</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> id &lt; ILFixDynamicMethodWrapper.wrapperArray.Length &amp;&amp; ILFixDynamicMethodWrapper.wrapperArray[id] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> System.<span class="function">Delegate <span class="title">CreateDelegate</span>(<span class="params">System.Type type, <span class="built_in">int</span> id, <span class="built_in">object</span> anon</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ILFixDynamicMethodWrapper iLFixDynamicMethodWrapper = <span class="keyword">new</span> ILFixDynamicMethodWrapper(<span class="keyword">this</span>.virtualMachine, id, anon);</span><br><span class="line">        <span class="keyword">return</span> Utils.TryAdapterToDelegate(iLFixDynamicMethodWrapper, type, <span class="string">&quot;__Gen_Wrap_&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">CreateWrapper</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ILFixDynamicMethodWrapper(<span class="keyword">this</span>.virtualMachine, id, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">InitWrapperArray</span>(<span class="params"><span class="built_in">int</span> len</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ILFixDynamicMethodWrapper.wrapperArray = <span class="keyword">new</span> ILFixDynamicMethodWrapper[len];</span><br><span class="line">        <span class="keyword">return</span> ILFixDynamicMethodWrapper.wrapperArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnonymousStorey <span class="title">CreateBridge</span>(<span class="params"><span class="built_in">int</span> fieldNum, <span class="built_in">int</span>[] fieldTypes, <span class="built_in">int</span> typeIndex, <span class="built_in">int</span>[] vTable, <span class="built_in">int</span>[] slots, VirtualMachine virtualMachine</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ILFixInterfaceBridge(fieldNum, fieldTypes, typeIndex, vTable, slots, virtualMachine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中使用到的iLFixDynamicMethodWrapper的代码如下，其中 <strong>__Gen_Wrap_X</strong> 函数会根据注入时函数的参数个数，类型来生成，相同的参数只生成一个对应的 <strong>__Gen_Wrap_X</strong>  方法，例子中的Add，Sub方法共用了 <strong>__Gen_Wrap_1</strong> 方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ILFixDynamicMethodWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> VirtualMachine virtualMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> methodId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">object</span> anonObj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ILFixDynamicMethodWrapper[] wrapperArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ILFixDynamicMethodWrapper</span>(<span class="params">VirtualMachine virtualMachine, <span class="built_in">int</span> methodId, <span class="built_in">object</span> anonObj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine = virtualMachine;</span><br><span class="line">        <span class="keyword">this</span>.methodId = methodId;</span><br><span class="line">        <span class="keyword">this</span>.anonObj = anonObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> __Gen_Wrap_0(<span class="built_in">string</span> P0)</span><br><span class="line">    &#123;</span><br><span class="line">        Call call = Call.Begin();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            call.PushObject(<span class="keyword">this</span>.anonObj);</span><br><span class="line">        &#125;</span><br><span class="line">        call.PushObject(P0);</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine.Execute(<span class="keyword">this</span>.methodId, <span class="keyword">ref</span> call, (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>) ? <span class="number">2</span> : <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> __Gen_Wrap_1(<span class="built_in">object</span> P0, <span class="built_in">int</span> P1, <span class="built_in">int</span> P2)</span><br><span class="line">    &#123;</span><br><span class="line">        Call call = Call.Begin();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            call.PushObject(<span class="keyword">this</span>.anonObj);</span><br><span class="line">        &#125;</span><br><span class="line">        call.PushObject(P0);</span><br><span class="line">        call.PushInt32(P1);</span><br><span class="line">        call.PushInt32(P2);</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine.Execute(<span class="keyword">this</span>.methodId, <span class="keyword">ref</span> call, (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>) ? <span class="number">4</span> : <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> call.GetInt32(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> __Gen_Wrap_2(<span class="built_in">int</span> P0)</span><br><span class="line">    &#123;</span><br><span class="line">        Call call = Call.Begin();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            call.PushObject(<span class="keyword">this</span>.anonObj);</span><br><span class="line">        &#125;</span><br><span class="line">        call.PushInt32(P0);</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine.Execute(<span class="keyword">this</span>.methodId, <span class="keyword">ref</span> call, (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>) ? <span class="number">2</span> : <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> call.GetInt32(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> __Gen_Wrap_3(<span class="built_in">object</span> P0)</span><br><span class="line">    &#123;</span><br><span class="line">        Call call = Call.Begin();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            call.PushObject(<span class="keyword">this</span>.anonObj);</span><br><span class="line">        &#125;</span><br><span class="line">        call.PushObject(P0);</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine.Execute(<span class="keyword">this</span>.methodId, <span class="keyword">ref</span> call, (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>) ? <span class="number">2</span> : <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">ILFixDynamicMethodWrapper</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ILFixDynamicMethodWrapper.wrapperArray = <span class="keyword">new</span> ILFixDynamicMethodWrapper[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果Patch阶段，有对Add方法进行修复，生成Patch，则执行逻辑会通过IFix.WrappersManagerImpl.GetPatch(6).__Gen_Wrap_1(this, a, b)调用<strong>ILFixDynamicMethodWrapper <strong>中的</strong>__Gen_Wrap_1</strong>函数，最终调用<strong>virtualMachine</strong>的函数，通过IFix内部实现的虚拟机，解析执行Patch中的IL指令，执行修复后的代码逻辑，最后然后通过 <strong>call.GetInt32(0)</strong> 获取计算返回的结果，将正确的值返回。</p>
<h3 id="2-1-2-IFix-CustomBridge-：interface和delegate桥接"><a href="#2-1-2-IFix-CustomBridge-：interface和delegate桥接" class="headerlink" title="2.1.2 [IFix.CustomBridge] ：interface和delegate桥接"></a>2.1.2 <strong>[IFix.CustomBridge]</strong> ：interface和delegate桥接</h3><p>在注入阶段使用，用来把一个在虚拟机上的类适配到原生interface或者把一个虚拟机的函数适配到原生delegate。<br>    - 修复代码赋值一个闭包到一个delegate变量；<br>    - 修复代码的Unity协程用了yield return；<br>    - 新增一个函数，赋值到一个delegate变量；<br>    - 新增一个类，赋值到一个原生interface变量；<br>    - 新增函数，用了yield return； </p>
<p>例如，原生类代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> running &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.CustomBridge</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AdditionalBridge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">Type</span>&gt; bridge</span> = <span class="keyword">new</span> List&lt;Type&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typeof</span>(ISubSystem),</span><br><span class="line">        <span class="keyword">typeof</span>(IEnumerator),</span><br><span class="line">        <span class="keyword">typeof</span>(Test.MyDelegate)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增函数（或者修复代码[IFix.Patch]的Unity协程），用到了 yield return </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.Interpret</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">TestInterface</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">    UnityEngine.Debug.Log(<span class="string">&quot;wait one second&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增函数（或者修复代码[IFix.Patch]），赋值到一个delegate变量</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">IFix.Interpret</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyDelegate <span class="title">TestDelegate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (a,b) =&gt; a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增一个类，该类实现了一个接口</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.Interpret</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubSystem</span> : <span class="title">ISubSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> running &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(<span class="string">&quot;SubSystem1.Print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入dll后，使用<strong>ILSpy</strong>能看到dll中有注入的类<strong>ILFixInterfaceBridge</strong></p>
<h3 id="2-2-Patch阶段"><a href="#2-2-Patch阶段" class="headerlink" title="2.2 Patch阶段"></a>2.2 Patch阶段</h3><p>Patch阶段针对修复内容使用对应的Tag</p>
<ul>
<li>修复方法 ：[IFix.Patch]</li>
<li>新增方法、类型 ：[IFix.Interpret]</li>
</ul>
<h4 id="2-2-1-修复方法"><a href="#2-2-1-修复方法" class="headerlink" title="2.2.1 修复方法"></a>2.2.1 修复方法</h4><p>需要修复的方法，再Patch阶段加上[Patch]标签，在执行生成Patch时，被修复的方法就会被写到生成的Patch里，例如，将Add方法从原先的 <strong>a * b</strong> 改成正确的逻辑 <strong>a + b</strong>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Patch</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不支持修复泛型函数，不支持修复构造函数</p>
</blockquote>
<h3 id="2-2-2-新增函数、类型"><a href="#2-2-2-新增函数、类型" class="headerlink" title="2.2.2 新增函数、类型"></a>2.2.2 新增函数、类型</h3><ul>
<li>新增一个函数</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.Interpret</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Greater</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增一个类</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.Interpret</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewClass</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增一个属性</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;<span class="comment">//这个name字段是原生的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">IFix.Interpret</span>]</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">    	name = <span class="keyword">value</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">IFix.Interpret</span>]</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不支持继承原生类，泛型类，不支持在原生类中新增字段</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Unity开发</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>InjectFix</tag>
      </tags>
  </entry>
  <entry>
    <title>UMG源码笔记</title>
    <url>/2021/05/24/umg-framework/</url>
    <content><![CDATA[<p>整理下最近学习UE4 UMG的进度。</p>
<h1 id="1-UMG类视图"><a href="#1-UMG类视图" class="headerlink" title="1.UMG类视图"></a>1.UMG类视图</h1><p>UMG 控件跟Unity UGUI不太一样，不是所有的控件节点，都能拥有子节点，为了区分这三种控件，整理了下他们基类：</p>
<ul>
<li><strong>UWidget</strong> : 所有UMG 控件的公共基类，不提供增加子节点功能</li>
<li><strong>UPanelWidget</strong> : 提供了增加子节点功能，可以有多个子节点</li>
<li><strong>UContentWidget</strong> : 继承于<strong>UPanelWidget</strong>，是<strong>UPanelWidget</strong>的一种特例，只能有一个子节点</li>
</ul>
<p>UMG常用控件的继承关系如下图所示:</p>
<h2 id="1-1-不能有子节点的控件如下："><a href="#1-1-不能有子节点的控件如下：" class="headerlink" title="1.1 不能有子节点的控件如下："></a>1.1 不能有子节点的控件如下：</h2><p>这个类别的控件的公共基类都是<strong>UWidget</strong>，每个UMG控件，都持有一个Slate控件的智能指针。</p>
<img  src=http://www.plantuml.com/plantuml/svg/VPB1Ri8m44Jl-GgVA_45HHo2ggeILL6JmDaas-1YwiesAWZrtyjclH37eHoGipDvCtPSQ-cSgDusdr1xSVxDicgbt45gCPbCPYnaDTc2XBQiMgkc1HzyfB2Ff7CcBhzgARz05zhu1u7_Zzrq3NAtz7PQa7KcNa-q6iYKVpCzpzc6LUTclp6vELvA7Bwn1ebSuofJaxBOIWiDSaN1sZHiyM4caCzZuZyroikDXXAEk56hsgrFOo9N4bNqPOpeFrFCorws40uoHfEIChivmhe5KHRA-PM2drowSLXaI9abbc8TsT4WpWZyFd6OCfB0qktCCOQdbB2qfhNWN2xjw2RwUfhGKn7TUoGwdlb2dip1Ns-lXe-HRveOpztxxwhUefHhK-z2lw6L4R4txHhfs3OQKDz2gmRidUiTn9HC0Y9fTTixzoRSlUR_jOuQ3zgMYkxBu7PSiIoFK8CKtmoU1he5flCtInA2PIGWA8E0CCM0Fm00>

<h2 id="1-2-可以增加子节点的控件："><a href="#1-2-可以增加子节点的控件：" class="headerlink" title="1.2 可以增加子节点的控件："></a>1.2 可以增加子节点的控件：</h2><h3 id="1-2-1-可以有一个子节点控件"><a href="#1-2-1-可以有一个子节点控件" class="headerlink" title="1.2.1 可以有一个子节点控件"></a>1.2.1 可以有一个子节点控件</h3><p>有一个子节点的控件继承的父类依次是 <strong>UComponentWidget</strong> -&gt; <strong>UPanelWidget</strong>，父类<strong>UComponentWidget</strong>构造函数中设置了不允许多个孩子标记位：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UContentWidget::<span class="built_in">UContentWidget</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">    : <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    bCanHaveMultipleChildren = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公共基类<strong>UPanelWidget</strong>定义了<strong>AddChild</strong>函数，可以增加对应的子节点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UPanelSlot* <span class="title">UPanelWidget::AddChild</span><span class="params">(UWidget* Content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Content == <span class="literal">nullptr</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !bCanHaveMultipleChildren &amp;&amp; <span class="built_in">GetChildrenCount</span>() &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Content-&gt;<span class="built_in">RemoveFromParent</span>();</span><br><span class="line"></span><br><span class="line">    EObjectFlags NewObjectFlags = RF_Transactional;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">HasAnyFlags</span>(RF_Transient))</span><br><span class="line">    &#123;</span><br><span class="line">        NewObjectFlags |= RF_Transient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UPanelSlot* PanelSlot = NewObject&lt;UPanelSlot&gt;(<span class="keyword">this</span>, <span class="built_in">GetSlotClass</span>(), NAME_None, NewObjectFlags);</span><br><span class="line">    PanelSlot-&gt;Content = Content;</span><br><span class="line">    PanelSlot-&gt;Parent = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    Content-&gt;Slot = PanelSlot;</span><br><span class="line"></span><br><span class="line">    Slots.<span class="built_in">Add</span>(PanelSlot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OnSlotAdded</span>(PanelSlot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InvalidateLayoutAndVolatility</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PanelSlot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<strong>GetSlotClass</strong>返回对应控件的<strong>Slot</strong>的类型，在类视图里，带红色方格的标记的，是各自控件<strong>GetSlotClass</strong>返回的<strong>Slot</strong>的类型。Slot会分别指向父节点跟子节点。</p>
<img  src=http://www.plantuml.com/plantuml/svg/VLFBRe905Dtp5RDK6xv0Ow8iN3MQKchItGXNeHAc6SP4Q_hlPUwT5mLbGUREEPp707dDsvPbsyCNv8hTVwCe-wZQ2wzP7ClgLAfuQT4e9wx1aRklYXEea4kevH9-ZrXtxO6VTqekKjfSijSRhUPzcDmyQPDO6lBYRCSRgDDQg1dJztcaaxZDBimmXqSfYmasOube53Gc0j4ijECI4QVkocfz6dhwOTdtbPJyjl36IypQaj5Bbk1pCxO1fVTnd4mj6ZHS5KLILdKn-HzvEZmFochmNjeWdutSfzqVYAs5B41sAfTlhTDxo2ePZYcUbjsv5VWc2T3la5OkCOs1oqKfqPYiunx46F5003rmvJrm38wbXFoy5jTdBeupzB6GTiBrGLn9EEL7-1GDF1DsdA6mWxIo7LmBk-5xl87YLGEIgjHmL0zTG-hGsAB-J-llc7RL3v2L-yN76nhUs5U0XsO8lXdDjjWV>


<h3 id="1-2-2-可以有多个子节点控件"><a href="#1-2-2-可以有多个子节点控件" class="headerlink" title="1.2.2 可以有多个子节点控件"></a>1.2.2 可以有多个子节点控件</h3><img  src=http://www.plantuml.com/plantuml/svg/TPDDReCm48NtdCBBX8eJ949AMT1D5IH2itR1JPnQK1adAaMzUx77lmLO8C-yXxytjgWPxdjK7Tzlf1Pe_8sYwetsTynGad1wkOeaDMfKWrVhodkcpOM8oIjj81WRI6E4fkTCy6SX-Bw4PefU1rZjGXb0pfHdngPyILNWbh2ITI96yhsBP0ZRz3E7OPm50kbqCSgwLf1Mvm2RaGhCbM8HmR1G1Flx4vyEdEDXxy2f2jm3wAdAr7SnoecGVLLkjaRrnZmqJNQbhDdyZxoT7mfarRfDoyY7EX4leuaTMiVb3QSTSVl0lUhgwPVsyapg34xbTJh1Hbti1Ee5nxGLO9EN2okO8l4_TwEyT9p-J1anU-w-_TjTu8TUVGjUX42N_A1X3pFekYJ71-4C3-lZ6yCSh1M9r4iBqxN3b3Nlc1vs1UGiSvJL9CmM5cSx3fXpsfYBlN-j89rfZhIQ-bzDOP6oOsX_>

<h2 id="1-3-Slate控件类视图"><a href="#1-3-Slate控件类视图" class="headerlink" title="1.3 Slate控件类视图"></a>1.3 Slate控件类视图</h2><p>Slate中除了<strong>SWidget</strong>之外有三个基础类，其他控件都是继承者三个基类。</p>
<ul>
<li><strong>SPanel</strong> : 有多个子节点</li>
<li><strong>SLeafWidget</strong> : 没有子节点</li>
<li><strong>SCompoundWidget</strong> : 可以有一个子节点</li>
</ul>
<img  src=http://www.plantuml.com/plantuml/svg/VP3H2i8W58RlVGfVm2TOx6Om2882YrtBj2Ku7MgBYDwzJO-rZJMlnE_pdF-SMZ7dCAqaRuH7BuJU2D4Jqq9XGaZ-9NNq0adQiHTMiIU84O47Q33nSCWvmE8c5RT2xqh0L1cVu_ISXQ87mQwnvsg07quf2jDsvgxvngUvaaALLBQT4cE8c66yPL1JEs-PrBvWkcTkRSIbysTMN8O6op4lJjXPuaL6Q3BHODnzone1VoRB03zIK2kfkNbirezAMEK7>

<h1 id="2-UMG渲染流程"><a href="#2-UMG渲染流程" class="headerlink" title="2 UMG渲染流程"></a>2 UMG渲染流程</h1><p>TODO</p>
<img  src=http://www.plantuml.com/plantuml/svg/NOxV2e8m5CRlVGelDT07s4LWfH0OIHPvEzn13wupiP7HqxSvI-fcS7xVdtrUi0hzA5fdAJL8a2lLCtR6klCCzAkgOimyVX37SMXHLagk8UbxYJNNg8YntS37Av9GOq9Ysw8K0z0KBnrchE18sXrBoPuUNAAOMavAwTdsZstWjwYKQYouRcT5DF39Mc8t7-bxkh_inbJ23SXO3xo3ZNekgckVzHplnfC8SI4ar6Z6l41uRm00>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
        <category>SlateUI</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UnrealEnginPython踩坑记录</title>
    <url>/2021/04/22/unreal-python-bug/</url>
    <content><![CDATA[<p>最近项目换成了UE4，脚本用到的是python预研，用到的插件是<a href="https://github.com/20tab/UnrealEnginePython">UnrealEnginePython</a>，在使用这个插件的过程中踩到几个坑，在这里mark下。</p>
<h2 id="1-自动导出接口参数不匹配"><a href="#1-自动导出接口参数不匹配" class="headerlink" title="1. 自动导出接口参数不匹配"></a>1. 自动导出接口参数不匹配</h2><p>   这个bug是同事遇到的，报错的情况很诡异，报错log如下：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">LogPython:</span> <span class="keyword">Error</span> xxx/xxx/xxx.py:<span class="number">27</span> RuntimeWarning: tp_compare didn<span class="comment">&#x27;t return -1 or -2 for exception</span></span><br><span class="line">  ue.log(<span class="string">&quot;this is a test log&quot;</span> + str(test_dict.<span class="keyword">get</span>(<span class="number">10000</span>, None)))</span><br><span class="line"><span class="symbol">LogPython:</span> <span class="keyword">Error</span> argument must be <span class="type">string</span>, <span class="built_in">not</span> int</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>初看这个报错，就找到对应行，结果发现，只是一个对python dict的取值操作，调用的也是dict类型提供的标准函数。最近项目在折腾python版本的问题，以为是同事修改了python底层C++代码，导致的报错。跟同事py了很久，也没找到头绪，在UnrealEnginePython提供的python console命令，直接调用这个dict可以正常取值，而且尝试打印这个get函数的地址，代码逻辑输出的地址跟在python console里输出的是一样的。到这里就陷入了思考了。</p>
<p>中午干饭回来，继续盯log，我偶然发现了个警告</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">LogTemp: Warnin<span class="variable">g:</span> <span class="keyword">argument</span> <span class="keyword">is</span> not <span class="keyword">a</span> FText</span><br></pre></td></tr></table></figure>
<p>便在工程里搜索了下，全局只有一个地方打印了这个日志。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function">FText <span class="title">get_value</span><span class="params">(PyObject* py_object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_Parse</span>(py_object, <span class="string">&quot;s&quot;</span>, &amp;str))</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;argument is not a FText&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="built_in">UTF8_TO_TCHAR</span>(str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我断点调试跟踪堆栈发现调用关系如下：<br><img src="/images/unreal_python_bug/python_stack.png" width=50% height=50% align="center"/> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EXPORT_UOBJECT_FUNC</span>(<span class="string">&quot;set_text&quot;</span>,&amp;UTextBlock::SetText),</span><br></pre></td></tr></table></figure>
<p>UTextBlock::SetText 函数声明如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetText</span><span class="params">(FText InText)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>EXPORT_UOBJECT_FUNC</strong> 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT_UOBJECT_FUNC(func_name, func)\</span></span><br><span class="line">&#123;\</span><br><span class="line">    func_name, \</span><br><span class="line">    [](PyObject *self, PyObject *args)\</span><br><span class="line">    &#123;\</span><br><span class="line">        <span class="keyword">return</span> UePyTemplate::<span class="built_in">invoke_func</span>((ue_PyUObject *)self, args, func);\</span><br><span class="line">    &#125;,\</span><br><span class="line">    METH_VARARGS, <span class="string">&quot;&quot;</span>\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>R是返回值void<br>T是类型UTextBlock<br>Args是传入的参数<br>self是调用对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UEPyTemplate.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">PyObject *<span class="title">invoke_func</span><span class="params">(ue_PyUObject *self, PyObject * args, R(T::*func)(Args...))</span></span></span><br><span class="line"><span class="function">INVOKE_UOBJECT_FUNC</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVOKE_UOBJECT_FUNC \</span></span><br><span class="line">&#123;\</span><br><span class="line">    <span class="built_in">UE_PY_CHECK</span>(self);\</span><br><span class="line">    T *uobject = ue_py_check_type&lt;T&gt;(self);\</span><br><span class="line">    <span class="keyword">if</span> (!uobject)\</span><br><span class="line">    &#123;\</span><br><span class="line">        UClass* uclass = T::<span class="built_in">StaticClass</span>();\</span><br><span class="line">        FString class_name = uclass-&gt;<span class="built_in">GetName</span>();\</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyErr_Format</span>(PyExc_Exception, <span class="string">&quot;uobject is not %s&quot;</span>, <span class="built_in">TCHAR_TO_ANSI</span>(*class_name));\</span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="built_in">CHECK_ARGS_COUNT</span>(args, <span class="keyword">sizeof</span>...(Args));\</span><br><span class="line">    PyObject* ret = ret_type&lt;R&gt;::<span class="keyword">template</span> call_func_with_args&lt;Args...&gt;(uobject, func, args);\</span><br><span class="line">    <span class="keyword">return</span> ret;\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们到处的这个函数只有一个参数，最终会调用CALL_WITH_1_ARG，参数列表是GET_1_ARG获得的，即: get_args<Arg1>::value(args, 0);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_1_ARG auto arg1 = get_args<span class="meta-string">&lt;Arg1&gt;</span>::value(args, 0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_2_ARG GET_1_ARG auto arg2 = get_args<span class="meta-string">&lt;Arg2&gt;</span>::value(args, 1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_3_ARG GET_2_ARG auto arg3 = get_args<span class="meta-string">&lt;Arg3&gt;</span>::value(args, 2);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_4_ARG GET_3_ARG auto arg4 = get_args<span class="meta-string">&lt;Arg4&gt;</span>::value(args, 3);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_5_ARG GET_4_ARG auto arg5 = get_args<span class="meta-string">&lt;Arg5&gt;</span>::value(args, 4);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_6_ARG GET_5_ARG auto arg6 = get_args<span class="meta-string">&lt;Arg6&gt;</span>::value(args, 5);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_7_ARG GET_6_ARG auto arg7 = get_args<span class="meta-string">&lt;Arg7&gt;</span>::value(args, 6);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_8_ARG GET_7_ARG auto arg8 = get_args<span class="meta-string">&lt;Arg8&gt;</span>::value(args, 7);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_9_ARG GET_8_ARG auto arg9 = get_args<span class="meta-string">&lt;Arg9&gt;</span>::value(args, 8);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_1_ARG arg1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_2_ARG CALL_WITH_1_ARG, arg2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_3_ARG CALL_WITH_2_ARG, arg3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_4_ARG CALL_WITH_3_ARG, arg4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_5_ARG CALL_WITH_4_ARG, arg5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_6_ARG CALL_WITH_5_ARG, arg6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_7_ARG CALL_WITH_6_ARG, arg7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_8_ARG CALL_WITH_7_ARG, arg8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_9_ARG CALL_WITH_8_ARG, arg9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_FUNC_WITH_ARGS(args_count)\</span></span><br><span class="line"><span class="keyword">template</span>&lt;DECLARE_##args_count##_ARG, <span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;\</span><br><span class="line">static PyObject* call_func_with_args(T* uobject, F func, PyObject* args)\</span><br><span class="line">&#123;\</span><br><span class="line">    GET_##args_count##_ARG;\</span><br><span class="line">    R ret = (uobject-&gt;*func)(CALL_WITH_##args_count##_ARG);\</span><br><span class="line">    <span class="built_in">RETURN_VALUE</span>(ret);\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">get_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">value</span><span class="params">(PyObject *args, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_args_value&lt;T&gt;(args, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">get_args_value</span><span class="params">(PyObject *args, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyObject* py_object = <span class="built_in">PyTuple_GetItem</span>(args, index);</span><br><span class="line">    <span class="keyword">if</span> (subclass_of&lt;T&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> subclass_of&lt;T&gt;::<span class="built_in">get_subclass_value</span>(py_object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get_value&lt;T&gt;(py_object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get_value模板函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">get_value</span><span class="params">(PyObject* py_object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uobject_derived_type&lt;T&gt;::<span class="built_in">get_value</span>(py_object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是特化版本的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function">UNREALENGINEPYTHON_API FText <span class="title">get_value</span><span class="params">(PyObject* py_object)</span></span>;</span><br></pre></td></tr></table></figure>
<p>产生这个警告的界面里，跟FText相关的只有一个调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_text</span>(<span class="params">self, text_str</span>):</span></span><br><span class="line">    self.uobject.set_text(text_str)</span><br></pre></td></tr></table></figure>
<p>立马打印这text_str，发现传入的参数是int，结合之前FText get_value特化函数，发现了坑点：<br>函数将int类型的py_object进行字符串类型匹配解析时，没有做类型判定，强行按照c风格字符串进行解析，解析的结果是会将连续的内存块解析成字符串，并且在第一个’\0’空间停止，之前的内存空间数据都被当成了字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function">FText <span class="title">get_value</span><span class="params">(PyObject* py_object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_Parse</span>(py_object, <span class="string">&quot;s&quot;</span>, &amp;str))</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;argument is not a FText&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="built_in">UTF8_TO_TCHAR</span>(str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是设置字符串的结果，字符串内容都是乱码：<br><img src="/images/unreal_python_bug/text_error.png" width=50% height=50% align="center"/><br>这就解释清楚，之前的报错，而且报错的地方经常不固定。<br>找到原因，修改方法就容易了。顺势排查了一波对字符串参数解析的特化版本，防止后面留坑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function">FText <span class="title">get_value</span><span class="params">(PyObject* py_object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyString_Check</span>(py_object))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;argument is not a FText&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_Parse</span>(py_object, <span class="string">&quot;s&quot;</span>, &amp;str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="built_in">UTF8_TO_TCHAR</span>(str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-UE4引擎代码的坑"><a href="#2-UE4引擎代码的坑" class="headerlink" title="2.UE4引擎代码的坑"></a>2.UE4引擎代码的坑</h2><p>做UI的时候需要个屏幕坐标空间转换的函数，在谷歌上找到了个下面这个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UnrealEngine/Engine/Source/Runtime/UMG/Public/Blueprint/SlateBlueprintLibrary.h</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Translates local coordinate of the geometry provided into local viewport coordinates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param PixelPosition The position in the game&#x27;s viewport, usable for line traces and </span></span><br><span class="line"><span class="comment"> * other uses where you need a coordinate in the space of viewport resolution units.</span></span><br><span class="line"><span class="comment"> * @param ViewportPosition The position in the space of other widgets in the viewport.  Like if you wanted</span></span><br><span class="line"><span class="comment"> * to add another widget to the viewport at the same position in viewport space as this location, this is</span></span><br><span class="line"><span class="comment"> * what you would use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintPure, Category=<span class="string">&quot;User Interface|Geometry&quot;</span>, meta=( WorldContext=<span class="string">&quot;WorldContextObject&quot;</span> ))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LocalToViewport</span><span class="params">(UObject* WorldContextObject, <span class="keyword">const</span> FGeometry&amp; Geometry, FVector2D LocalCoordinate,</span></span></span><br><span class="line"><span class="function"><span class="params">        FVector2D&amp; PixelPosition, FVector2D&amp; ViewportPosition)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后开始写C++导出接口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">PyObject *<span class="title">py_ue_screen_to_widget_local</span><span class="params">(ue_PyUObject * self, PyObject * args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ue_py_check</span>(self);</span><br><span class="line"></span><br><span class="line">	UWidget* widget = ue_py_check_type&lt;UWidget&gt;(self);</span><br><span class="line">	<span class="keyword">if</span> (!widget)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PyErr_Format</span>(PyExc_Exception, <span class="string">&quot;uobject is not a UWidget&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">float</span> x, y;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">PyArg_ParseTuple</span>(args, <span class="string">&quot;(ff)&quot;</span>, &amp;x, &amp;y))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	</span><br><span class="line">	FVector2D local_pos;</span><br><span class="line">	<span class="function">FVector2D <span class="title">screen_pos</span><span class="params">(x, y)</span></span>;</span><br><span class="line">	FGeometry geometry = widget-&gt;<span class="built_in">GetCachedGeometry</span>();</span><br><span class="line">	</span><br><span class="line">	USlateBlueprintLibrary::<span class="built_in">ScreenToWidgetLocal</span>(widget, geometry, screen_pos, local_pos);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">py_ue_new_fvector2d</span>(local_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>screen_pos在进入函数ScreenToWidgetLocal时，数据一切正常，而进入函数后，数据不对了，像没初始化的样子。查了下源码发现FVector2D没有实现拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FVector2D</span>(<span class="keyword">const</span>&amp; FVector2D)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其实只是开启了编译优化，代码行号跟变量被优化掉了，被优化的变量没法看到具体的内存值。</p>
<h2 id="3-Unreal-C-不允许指针指向不完整的类类型（踩坑）"><a href="#3-Unreal-C-不允许指针指向不完整的类类型（踩坑）" class="headerlink" title="3. Unreal C++不允许指针指向不完整的类类型（踩坑）"></a>3. Unreal C++不允许指针指向不完整的类类型（踩坑）</h2><p>新增如下代码时，突然VS2019爆出警告  C++不允许指针指向不完整的类类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// SHierarchyViewItem.cpp</span></span><br><span class="line">NewSlot = Parent-&gt;<span class="built_in">AddChild</span>(Widget);</span><br><span class="line"><span class="keyword">if</span> (Parent-&gt;<span class="built_in">IsA</span>(UCanvasPanel::<span class="built_in">StaticClass</span>()))</span><br><span class="line">&#123;</span><br><span class="line">    UCanvasPanelSlot* NewCanvasSlot = Cast&lt;UCanvasPanelSlot&gt;(NewSlot);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != NewCanvasSlot)</span><br><span class="line">    &#123;</span><br><span class="line">        NewCanvasSlot-&gt;<span class="built_in">SetAnchors</span>(<span class="built_in">FAnchors</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line">        NewCanvasSlot-&gt;<span class="built_in">SetAlignment</span>(<span class="built_in">FVector2D</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入这两个头文件就能解决这个问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/CanvasPanel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/CanvasPanelSlot.h&quot;</span></span></span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 SlateUI事件机制</title>
    <url>/2021/04/29/ue4-slate-event/</url>
    <content><![CDATA[<p>最近开发过程中，碰到一个比较奇怪的Bug，同事在场景中创建了个3D UI，使用的是WidgetComponent组件，然后动态设置widget实例，第一次创建的3D UI可以正常接收到鼠标事件，通过3D UI进入战斗场景后，第二场战斗的3D UI界面没法相应事件了，然后我就接住这口锅了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wbp_path = <span class="string">&#x27;/Game/test_3d_ui.test_3d_ui&#x27;</span></span><br><span class="line"><span class="comment"># game.ui: 全局ui管理器</span></span><br><span class="line"><span class="comment"># create_3d_ui:加载WidgetBlueprint，并打开</span></span><br><span class="line">widget = game.ui.create_3d_ui(wbp_path)</span><br><span class="line">widget_comp.set_widget(widget)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">PyObject *<span class="title">py_ue_set_widget</span><span class="params">(ue_PyUObject * self, PyObject * args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ue_py_check</span>(self);</span><br><span class="line"></span><br><span class="line">    PyObject *widget;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_ParseTuple</span>(args, <span class="string">&quot;O&quot;</span>, &amp;widget))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    UWidgetComponent *widget_component = ue_py_check_type&lt;UWidgetComponent&gt;(self);</span><br><span class="line">    <span class="keyword">if</span> (!widget_component)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyErr_Format</span>(PyExc_Exception, <span class="string">&quot;uobject is not a UWidgetComponent&quot;</span>);</span><br><span class="line"></span><br><span class="line">    UUserWidget *uwidget = ue_py_check_type&lt;UUserWidget&gt;(widget);</span><br><span class="line">    <span class="keyword">if</span> (!uwidget)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyErr_Format</span>(PyExc_Exception, <span class="string">&quot;argument2 is not a APlayerController&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    widget_component-&gt;<span class="built_in">SetWidget</span>(uwidget);</span><br><span class="line"></span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开始看UE4源码，研究下UE4 SlateUI事件机制</p>
<h2 id="按钮事件调用栈"><a href="#按钮事件调用栈" class="headerlink" title="按钮事件调用栈"></a>按钮事件调用栈</h2><p>下图是从Launch.cpp里里的GEngineLoop Tick调用Windows平台处理事件的代码，最终进入Button代码，响应OnClicked回调的调用栈。<br><img src="/images/ue4_event/button_event_statck.png" width=100% height=100% align="middle"/> </p>
<h2 id="事件来源"><a href="#事件来源" class="headerlink" title="事件来源"></a>事件来源</h2><p>在Windows平台上，鼠标点击，键盘事件都是调用Windows的API，从Windows事件列表中获取的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Ticks the engine loop </span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Launch\Private\Launch.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EngineTick</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//** line:62 **//</span></span><br><span class="line">    GEngineLoop.<span class="built_in">Tick</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\ApplicationCore\Private\Windows\WindowsPlatformApplicationMisc.cpp</span></span><br><span class="line"><span class="comment"> * windows 消息处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WinPumpMessages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        MSG Msg;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">PeekMessage</span>(&amp;Msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,PM_REMOVE) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TranslateMessage</span>( &amp;Msg );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//* line:108 *//</span></span><br><span class="line">            <span class="built_in">DispatchMessage</span>( &amp;Msg ); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\ApplicationCore\Private\Windows\WindowsApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">int32 <span class="title">FWindowsApplication::ProcessMessage</span><span class="params">( HWND hwnd, uint32 msg, WPARAM wParam, LPARAM lParam )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedPtr&lt; FWindowsWindow &gt; CurrentNativeEventWindowPtr = <span class="built_in">FindWindowByHWND</span>( Windows, hwnd );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( Windows.<span class="built_in">Num</span>() &amp;&amp; CurrentNativeEventWindowPtr.<span class="built_in">IsValid</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_SYSKEYUP:</span><br><span class="line">            <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_NCMOUSEMOVE:</span><br><span class="line">            <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">            <span class="keyword">case</span> WM_MOUSEWHEEL:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> WINVER &gt;= 0x0601</span></span><br><span class="line">            <span class="keyword">case</span> WM_TOUCH:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//** line:1042 **//</span></span><br><span class="line">                    <span class="built_in">DeferMessage</span>( CurrentNativeEventWindowPtr, hwnd, msg, wParam, lParam );</span><br><span class="line">                    <span class="comment">// Handled</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\ApplicationCore\Private\Windows\WindowsApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">int32 <span class="title">FWindowsApplication::ProcessDeferredMessage</span><span class="params">( <span class="keyword">const</span> FDeferredWindowsMessage&amp; DeferredMessage )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Windows.<span class="built_in">Num</span>() &amp;&amp; DeferredMessage.NativeWindow.<span class="built_in">IsValid</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        HWND hwnd = DeferredMessage.hWND;</span><br><span class="line">        uint32 msg = DeferredMessage.Message;</span><br><span class="line">        WPARAM wParam = DeferredMessage.wParam;</span><br><span class="line">        LPARAM lParam = DeferredMessage.lParam;</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONUP:</span><br><span class="line">                &#123;</span><br><span class="line">                    POINT CursorPoint;</span><br><span class="line">                    CursorPoint.x = <span class="built_in">GET_X_LPARAM</span>(lParam);</span><br><span class="line">                    CursorPoint.y = <span class="built_in">GET_Y_LPARAM</span>(lParam); </span><br><span class="line"></span><br><span class="line">                    <span class="built_in">ClientToScreen</span>(hwnd, &amp;CursorPoint);</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">const</span> FVector2D <span class="title">CursorPos</span><span class="params">(CursorPoint.x, CursorPoint.y)</span></span>;</span><br><span class="line"></span><br><span class="line">                    EMouseButtons::Type MouseButton = EMouseButtons::Invalid;</span><br><span class="line">                    <span class="keyword">bool</span> bDoubleClick = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">bool</span> bMouseUp = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> WM_LBUTTONDBLCLK:</span><br><span class="line">                            bDoubleClick = <span class="literal">true</span>;</span><br><span class="line">                            MouseButton = EMouseButtons::Left;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">                            bMouseUp = <span class="literal">true</span>;</span><br><span class="line">                            MouseButton = EMouseButtons::Left;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">                            MouseButton = EMouseButtons::Left;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="built_in">check</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (bMouseUp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//** line:2183 **//</span></span><br><span class="line">                        <span class="keyword">return</span> MessageHandler-&gt;<span class="built_in">OnMouseUp</span>( MouseButton, CursorPos ) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (bDoubleClick)</span><br><span class="line">                    &#123;</span><br><span class="line">                        MessageHandler-&gt;<span class="built_in">OnMouseDoubleClick</span>( CurrentNativeEventWindowPtr, MouseButton, CursorPos );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        MessageHandler-&gt;<span class="built_in">OnMouseDown</span>( CurrentNativeEventWindowPtr, MouseButton, CursorPos );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>随后代码进入SlateApplication中，对事件进行封装，然后开始找到响应的Widget，调用对应的响应函数，并最终响应事件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  ==================================</span></span><br><span class="line"><span class="comment">    前面都是从Windows事件队列获取消息</span></span><br><span class="line"><span class="comment">    并对消息进行处理，后面开始进入最难</span></span><br><span class="line"><span class="comment">    的地方了</span></span><br><span class="line"><span class="comment">    ==================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FSlateApplication::OnMouseUp</span><span class="params">( <span class="keyword">const</span> EMouseButtons::Type Button, <span class="keyword">const</span> FVector2D CursorPos )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// convert left mouse click to touch event if we are faking it	</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFakingTouchEvents</span>() &amp;&amp; Button == EMouseButtons::Left)</span><br><span class="line">    &#123;</span><br><span class="line">        bIsFakingTouched = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//** line:5305 **//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">OnTouchEnded</span>(PlatformApplication-&gt;Cursor-&gt;<span class="built_in">GetPosition</span>(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FKey Key = <span class="built_in">TranslateMouseButtonToKey</span>( Button );</span><br><span class="line"></span><br><span class="line">    <span class="function">FPointerEvent <span class="title">MouseEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        GetUserIndexForMouse(),</span></span></span><br><span class="line"><span class="function"><span class="params">        CursorPointerIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">        CursorPos,</span></span></span><br><span class="line"><span class="function"><span class="params">        GetLastCursorPos(),</span></span></span><br><span class="line"><span class="function"><span class="params">        PressedMouseButtons,</span></span></span><br><span class="line"><span class="function"><span class="params">        Key,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        PlatformApplication-&gt;GetModifierKeys()</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ProcessMouseButtonUpEvent</span>( MouseEvent );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FSlateApplication::OnTouchEnded</span><span class="params">( <span class="keyword">const</span> FVector2D&amp; Location, int32 TouchIndex, int32 ControllerId )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedRef&lt;FSlateUser&gt; User = <span class="built_in">GetOrCreateUser</span>(ControllerId);</span><br><span class="line">    <span class="keyword">if</span> (User-&gt;<span class="built_in">IsTouchPointerActive</span>(TouchIndex))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FPointerEvent <span class="title">PointerEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ControllerId,</span></span></span><br><span class="line"><span class="function"><span class="params">            TouchIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">            Location,</span></span></span><br><span class="line"><span class="function"><span class="params">            Location,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">0.0f</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//** line:5912 **//</span></span><br><span class="line">        <span class="built_in">ProcessTouchEndedEvent</span>(PointerEvent);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_SLATE_DEBUGGING</span></span><br><span class="line">        <span class="built_in">ensure</span>(!User-&gt;<span class="built_in">IsTouchPointerActive</span>(TouchIndex));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FSlateApplication::ProcessMouseButtonUpEvent</span><span class="params">( <span class="keyword">const</span> FPointerEvent&amp; MouseEvent )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// An empty widget path is passed in.  As an optimization, one will be generated only if a captured mouse event isn&#x27;t routed</span></span><br><span class="line">    FWidgetPath EmptyPath;</span><br><span class="line">    <span class="comment">//** line:5356 **//</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> bHandled = <span class="built_in">RoutePointerUpEvent</span>( EmptyPath, MouseEvent ).<span class="built_in">IsEventHandled</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( bIsCursorUser &amp;&amp; PressedMouseButtons.<span class="built_in">Num</span>() == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        PlatformApplication-&gt;<span class="built_in">SetCapture</span>( <span class="literal">nullptr</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bHandled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">FReply <span class="title">FSlateApplication::RoutePointerUpEvent</span><span class="params">(<span class="keyword">const</span> FWidgetPath&amp; WidgetsUnderPointer, <span class="keyword">const</span> FPointerEvent&amp; PointerEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TScopeCounter&lt;int32&gt; <span class="title">BeginInput</span><span class="params">(ProcessingInput)</span></span>;</span><br><span class="line"></span><br><span class="line">    FReply Reply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">    TSharedRef&lt;FSlateUser&gt; SlateUser = <span class="built_in">GetOrCreateUser</span>(PointerEvent);</span><br><span class="line">    TSharedPtr&lt;FDragDropOperation&gt; LocalDragDropContent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SlateUser-&gt;<span class="built_in">HasCapture</span>(PointerEvent.<span class="built_in">GetPointerIndex</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        FWidgetPath MouseCaptorPath = SlateUser-&gt;<span class="built_in">GetCaptorPath</span>(PointerEvent.<span class="built_in">GetPointerIndex</span>(), </span><br><span class="line">            FWeakWidgetPath::EInterruptedPathHandling::Truncate, &amp;PointerEvent);</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">ensureMsgf</span>(MouseCaptorPath.Widgets.<span class="built_in">Num</span>() &gt; <span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;A window had a widget with mouse capture. </span></span><br><span class="line"><span class="string">            That entire window has been dismissed before the mouse up could be processed.&quot;</span>)) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Switch worlds widgets in the current path</span></span><br><span class="line">            <span class="function">FScopedSwitchWorldHack <span class="title">SwitchWorld</span><span class="params">( MouseCaptorPath )</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//** line:4815 **//</span></span><br><span class="line">            Reply =</span><br><span class="line">                FEventRouter::Route&lt;FReply&gt;( <span class="keyword">this</span>, FEventRouter::<span class="built_in">FToLeafmostPolicy</span>(MouseCaptorPath), PointerEvent, </span><br><span class="line">                    [<span class="keyword">this</span>]( <span class="keyword">const</span> FArrangedWidget&amp; TargetWidget, <span class="keyword">const</span> FPointerEvent&amp; Event )</span><br><span class="line">                &#123;</span><br><span class="line">                    FReply TempReply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">                    <span class="keyword">if</span> (Event.<span class="built_in">IsTouchEvent</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        TempReply = TargetWidget.Widget-&gt;<span class="built_in">OnTouchEnded</span>(TargetWidget.Geometry, Event);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!Event.<span class="built_in">IsTouchEvent</span>() || (!TempReply.<span class="built_in">IsEventHandled</span>() &amp;&amp; <span class="keyword">this</span>-&gt;bTouchFallbackToMouse))</span><br><span class="line">                    &#123;</span><br><span class="line">                        TempReply = TargetWidget.Widget-&gt;<span class="built_in">OnMouseButtonUp</span>( TargetWidget.Geometry, Event );</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> ( Event.<span class="built_in">IsTouchEvent</span>() &amp;&amp; !<span class="built_in">IsFakingTouchEvents</span>() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Generate a Leave event when a touch ends as well, since a </span></span><br><span class="line">                        <span class="comment">// touch can enter a widget and then end inside it</span></span><br><span class="line">                        TargetWidget.Widget-&gt;<span class="built_in">OnMouseLeave</span>(Event);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> TempReply;</span><br><span class="line">                &#125;, ESlateDebuggingInputEvent::MouseButtonUp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!LocalWidgetsUnderPointer.<span class="built_in">IsValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新屏幕坐标区域中的widget</span></span><br><span class="line">            LocalWidgetsUnderPointer = <span class="built_in">LocateWindowUnderMouse</span>(PointerEvent.<span class="built_in">GetScreenSpacePosition</span>(), </span><br><span class="line">                <span class="built_in">GetInteractiveTopLevelWindows</span>(), <span class="literal">false</span>, SlateUser-&gt;<span class="built_in">GetUserIndex</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Route an event based on the Routing Policy.</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> ReplyType, <span class="keyword">typename</span> RoutingPolicyType, <span class="keyword">typename</span> EventType, <span class="keyword">typename</span> FuncType &gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ReplyType <span class="title">Route</span><span class="params">( FSlateApplication* ThisApplication, RoutingPolicyType RoutingPolicy, EventType EventCopy, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FuncType&amp; Lambda, ESlateDebuggingInputEvent DebuggingInputEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ReplyType Reply = ReplyType::<span class="built_in">Unhandled</span>();</span><br><span class="line">    <span class="keyword">const</span> FWidgetPath&amp; RoutingPath = RoutingPolicy.<span class="built_in">GetRoutingPath</span>();</span><br><span class="line">    <span class="keyword">const</span> FWidgetPath* WidgetsUnderCursor = RoutingPolicy.<span class="built_in">GetWidgetsUnderCursor</span>();</span><br><span class="line"></span><br><span class="line">    EventCopy.<span class="built_in">SetEventPath</span>( RoutingPath );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; !Reply.<span class="built_in">IsEventHandled</span>() &amp;&amp; RoutingPolicy.<span class="built_in">ShouldKeepGoing</span>(); RoutingPolicy.<span class="built_in">Next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> FWidgetAndPointer&amp; ArrangedWidget = RoutingPolicy.<span class="built_in">GetWidget</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM_COMPILER_HAS_IF_CONSTEXPR</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Translate&lt;EventType&gt;::TranslationNeeded())</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> EventType TranslatedEvent = Translate&lt;EventType&gt;::<span class="built_in">PointerEvent</span>(ArrangedWidget.PointerPosition, EventCopy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//** line:378 **//</span></span><br><span class="line">            Reply = <span class="built_in">Lambda</span>(ArrangedWidget, TranslatedEvent).<span class="built_in">SetHandler</span>(ArrangedWidget.Widget);</span><br><span class="line">            <span class="built_in">ProcessReply</span>(ThisApplication, RoutingPath, Reply, WidgetsUnderCursor, &amp;TranslatedEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Reply = <span class="built_in">Lambda</span>(ArrangedWidget, EventCopy).<span class="built_in">SetHandler</span>(ArrangedWidget.Widget);</span><br><span class="line">            <span class="built_in">ProcessReply</span>(ThisApplication, RoutingPath, Reply, WidgetsUnderCursor, &amp;EventCopy);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">const</span> EventType TranslatedEvent = Translate&lt;EventType&gt;::<span class="built_in">PointerEvent</span>(ArrangedWidget.PointerPosition, EventCopy);</span><br><span class="line">        Reply = <span class="built_in">Lambda</span>(ArrangedWidget, TranslatedEvent).<span class="built_in">SetHandler</span>(ArrangedWidget.Widget);</span><br><span class="line">        <span class="built_in">ProcessReply</span>(ThisApplication, RoutingPath, Reply, WidgetsUnderCursor, &amp;TranslatedEvent);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Reply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">FReply <span class="title">FSlateApplication::RoutePointerUpEvent</span><span class="params">(<span class="keyword">const</span> FWidgetPath&amp; WidgetsUnderPointer, <span class="keyword">const</span> FPointerEvent&amp; PointerEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch worlds widgets in the current path</span></span><br><span class="line">    <span class="function">FScopedSwitchWorldHack <span class="title">SwitchWorld</span><span class="params">( MouseCaptorPath )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//** line:4815 **//</span></span><br><span class="line">    Reply = FEventRouter::Route&lt;FReply&gt;( <span class="keyword">this</span>, FEventRouter::<span class="built_in">FToLeafmostPolicy</span>(MouseCaptorPath), PointerEvent, </span><br><span class="line">        [<span class="keyword">this</span>]( <span class="keyword">const</span> FArrangedWidget&amp; TargetWidget, <span class="keyword">const</span> FPointerEvent&amp; Event )</span><br><span class="line">        &#123;</span><br><span class="line">            FReply TempReply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">            <span class="keyword">if</span> (Event.<span class="built_in">IsTouchEvent</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                TempReply = TargetWidget.Widget-&gt;<span class="built_in">OnTouchEnded</span>(TargetWidget.Geometry, Event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Event.<span class="built_in">IsTouchEvent</span>() || (!TempReply.<span class="built_in">IsEventHandled</span>() &amp;&amp; <span class="keyword">this</span>-&gt;bTouchFallbackToMouse))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//** line:4829 **//</span></span><br><span class="line">                TempReply = TargetWidget.Widget-&gt;<span class="built_in">OnMouseButtonUp</span>( TargetWidget.Geometry, Event );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( Event.<span class="built_in">IsTouchEvent</span>() &amp;&amp; !<span class="built_in">IsFakingTouchEvents</span>() )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Generate a Leave event when a touch ends as well, since a </span></span><br><span class="line">                <span class="comment">// touch can enter a widget and then end inside it</span></span><br><span class="line">                TargetWidget.Widget-&gt;<span class="built_in">OnMouseLeave</span>(Event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> TempReply;</span><br><span class="line">        &#125;, ESlateDebuggingInputEvent::MouseButtonUp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\Slate\Private\Widgets\Input\SButton.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">FReply <span class="title">SButton::OnMouseButtonUp</span><span class="params">( <span class="keyword">const</span> FGeometry&amp; MyGeometry, <span class="keyword">const</span> FPointerEvent&amp; MouseEvent )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FReply Reply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//** line:304 **//</span></span><br><span class="line">    Reply = <span class="built_in">ExecuteOnClick</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\Slate\Private\Widgets\Input\SButton.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">FReply <span class="title">SButton::ExecuteOnClick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OnClicked.<span class="built_in">IsBound</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//** line:385 **//</span></span><br><span class="line">        FReply Reply = OnClicked.<span class="built_in">Execute</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Reply;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FReply::<span class="built_in">Handled</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\UMG\Private\Components\Button.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">FReply <span class="title">UButton::SlateHandleClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//** line:203 **//</span></span><br><span class="line">    OnClicked.<span class="built_in">Broadcast</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FReply::<span class="built_in">Handled</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="获取响应控件"><a href="#获取响应控件" class="headerlink" title="获取响应控件"></a>获取响应控件</h2><p>UE4中，为了方便获取鼠标响应控件，会将屏幕区域划分成一个一个区域，然后按照区域，将控件划分到对应的区域中管理，一个控件可能会被划分到多个区域中。例如：1920 * 1080 分辨率会被划分成 15 * 9 个Cell。详细代码参见如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\SlateCore\Private\Input\HittestGrid.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 屏幕分区大小</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> FVector2D <span class="title">CellSize</span><span class="params">(<span class="number">128.0f</span>, <span class="number">128.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算屏幕分区个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FHittestGrid::SetHittestArea</span><span class="params">(<span class="keyword">const</span> FVector2D&amp; HittestPositionInDesktop, <span class="keyword">const</span> FVector2D&amp; HittestDimensions,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FVector2D&amp; HitestOffsetInWindow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bWasCleared = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the size of the hit test area changes we need to clear it out</span></span><br><span class="line">    <span class="keyword">if</span> (GridSize != HittestDimensions)</span><br><span class="line">    &#123;</span><br><span class="line">        GridSize = HittestDimensions;</span><br><span class="line">        NumCells = <span class="built_in">FIntPoint</span>(FMath::<span class="built_in">CeilToInt</span>(GridSize.X / CellSize.X), FMath::<span class="built_in">CeilToInt</span>(GridSize.Y / CellSize.Y));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> int32 NewTotalCells = NumCells.X * NumCells.Y;</span><br><span class="line">        <span class="built_in">ClearInternal</span>(NewTotalCells);</span><br><span class="line"></span><br><span class="line">        bWasCleared = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GridOrigin = HittestPositionInDesktop;</span><br><span class="line">    GridWindowOrigin = HitestOffsetInWindow;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bWasCleared;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过屏幕坐标获取对应分割区Cell坐标</span></span><br><span class="line"><span class="function">FIntPoint <span class="title">FHittestGrid::GetCellCoordinate</span><span class="params">(FVector2D Position)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FIntPoint</span>(</span><br><span class="line">        FMath::<span class="built_in">Min</span>(FMath::<span class="built_in">Max</span>(FMath::<span class="built_in">FloorToInt</span>(Position.X / CellSize.X), <span class="number">0</span>), NumCells.X - <span class="number">1</span>),</span><br><span class="line">        FMath::<span class="built_in">Min</span>(FMath::<span class="built_in">Max</span>(FMath::<span class="built_in">FloorToInt</span>(Position.Y / CellSize.Y), <span class="number">0</span>), NumCells.Y - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HittestGrid 每帧都会刷新，刷新堆栈如下：<br><img src="/images/ue4_event/update_hittest_area.png" width=100% height=100% align="middle"/> </p>
<p>每帧从SWindow根节点开始绘制，调用SetHittestArea函数，刷新HittestGrid：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">SWindow::PaintWindow</span><span class="params">( <span class="keyword">double</span> CurrentTime, <span class="keyword">float</span> DeltaTime, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="keyword">bool</span> bParentEnabled )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 更新HittestArea屏幕大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> HittestCleared = HittestGrid-&gt;<span class="built_in">SetHittestArea</span>(<span class="built_in">GetPositionInScreen</span>(), <span class="built_in">GetViewportSize</span>());</span><br><span class="line">    <span class="function">FPaintArgs <span class="title">PaintArgs</span><span class="params">(<span class="literal">nullptr</span>, GetHittestGrid(), GetPositionInScreen(), CurrentTime, DeltaTime)</span></span>;</span><br><span class="line">    <span class="function">FSlateInvalidationContext <span class="title">Context</span><span class="params">(OutDrawElements, InWidgetStyle)</span></span>;</span><br><span class="line">    Context.bParentEnabled = bParentEnabled;</span><br><span class="line">    Context.PaintArgs = &amp;PaintArgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始绘制窗口界面</span></span><br><span class="line">    FSlateInvalidationResult Result = <span class="built_in">PaintInvalidationRoot</span>(Context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根节点开始Paint后，会以深度优先方式遍历所有子节点，并调用子节点的Paint函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\SlateCore\Private\Widgets\SWidget.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">int32 <span class="title">SWidget::Paint</span><span class="params">(<span class="keyword">const</span> FPaintArgs&amp; Args, <span class="keyword">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="function"><span class="params">    int32 LayerId, <span class="keyword">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="keyword">bool</span> bParentEnabled)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    OutDrawElements.<span class="built_in">PushPaintingWidget</span>(*<span class="keyword">this</span>, LayerId, PersistentState.CachedElementHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bOutgoingHittestability)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//** line:1344 **//</span></span><br><span class="line">        Args.<span class="built_in">GetHittestGrid</span>().<span class="built_in">AddWidget</span>(MutableThis, <span class="number">0</span>, LayerId, FastPathProxyHandle.<span class="built_in">GetIndex</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Paint the geometry of this widget.</span></span><br><span class="line">    int32 NewLayerId = <span class="built_in">OnPaint</span>(UpdatedArgs, AllottedGeometry, CullingBounds, OutDrawElements, LayerId, </span><br><span class="line">        ContentWidgetStyle, bParentEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再调用FHittestGrid::AddWidget函数，对每个Widget进行区域划分，将Widget加入对应的Cell中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FHittestGrid::AddWidget</span><span class="params">(<span class="keyword">const</span> TSharedRef&lt;SWidget&gt;&amp; InWidget, int32 InBatchPriorityGroup, </span></span></span><br><span class="line"><span class="function"><span class="params">    int32 InLayerId, int32 InSecondarySort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Widget不可见，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!InWidget-&gt;<span class="built_in">GetVisibility</span>().<span class="built_in">IsHitTestVisible</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FGeometry GridSpaceGeometry = InWidget-&gt;<span class="built_in">GetPaintSpaceGeometry</span>();</span><br><span class="line">    GridSpaceGeometry.<span class="built_in">AppendTransform</span>(<span class="built_in">FSlateLayoutTransform</span>(-GridWindowOrigin));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FSlateRect BoundingRect = GridSpaceGeometry.<span class="built_in">GetRenderBoundingRect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Widget最左上角跟最右下角的Cell Index</span></span><br><span class="line">    <span class="comment">// 后面循环将Widget加入到对应的Cell区域</span></span><br><span class="line">    <span class="keyword">const</span> FIntPoint UpperLeftCell = <span class="built_in">GetCellCoordinate</span>(BoundingRect.<span class="built_in">GetTopLeft</span>());</span><br><span class="line">    <span class="keyword">const</span> FIntPoint LowerRightCell = <span class="built_in">GetCellCoordinate</span>(BoundingRect.<span class="built_in">GetBottomRight</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bAddWidget)</span><br><span class="line">    &#123;</span><br><span class="line">        int32&amp; WidgetIndex = WidgetMap.<span class="built_in">Add</span>(&amp;*InWidget);</span><br><span class="line">        <span class="keyword">for</span> (int32 XIndex = UpperLeftCell.X; XIndex &lt;= LowerRightCell.X; ++XIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int32 YIndex = UpperLeftCell.Y; YIndex &lt;= LowerRightCell.Y; ++YIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsValidCellCoord</span>(XIndex, YIndex))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CellAt</span>(XIndex, YIndex).<span class="built_in">AddIndex</span>(WidgetIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a>TODO:</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FWidgetPath <span class="title">FSlateApplication::LocateWidgetInWindow</span><span class="params">(FVector2D ScreenspaceMouseCoordinate, <span class="keyword">const</span> TSharedRef&lt;SWindow&gt;&amp; Window, <span class="keyword">bool</span> bIgnoreEnabledStatus, int32 UserIndex)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> bAcceptsInput = Window-&gt;<span class="built_in">IsVisible</span>() &amp;&amp; (Window-&gt;<span class="built_in">AcceptsInput</span>() || <span class="built_in">IsWindowHousingInteractiveTooltip</span>(Window));</span><br><span class="line">    <span class="keyword">if</span> (bAcceptsInput &amp;&amp; Window-&gt;<span class="built_in">IsScreenspaceMouseWithin</span>(ScreenspaceMouseCoordinate))</span><br><span class="line">    &#123;</span><br><span class="line">        TArray&lt;FWidgetAndPointer&gt; WidgetsAndCursors = Window-&gt;<span class="built_in">GetHittestGrid</span>().<span class="built_in">GetBubblePath</span>(ScreenspaceMouseCoordinate, <span class="built_in">GetCursorRadius</span>(), bIgnoreEnabledStatus, UserIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FWidgetPath</span>(<span class="built_in">MoveTemp</span>(WidgetsAndCursors));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FWidgetPath</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TArray&lt;FWidgetAndPointer&gt; <span class="title">FHittestGrid::GetBubblePath</span><span class="params">(FVector2D DesktopSpaceCoordinate, <span class="keyword">float</span> CursorRadius, <span class="keyword">bool</span> bIgnoreEnabledStatus, int32 UserIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">checkSlow</span>(<span class="built_in">IsInGameThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FVector2D CursorPositionInGrid = DesktopSpaceCoordinate - GridOrigin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WidgetArray.<span class="built_in">Num</span>() &gt; <span class="number">0</span> &amp;&amp; Cells.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FGridTestingParams TestingParams;</span><br><span class="line">        TestingParams.CursorPositionInGrid = CursorPositionInGrid;</span><br><span class="line">        TestingParams.CellCoord = <span class="built_in">GetCellCoordinate</span>(CursorPositionInGrid);</span><br><span class="line">        TestingParams.Radius = <span class="number">0.0f</span>;</span><br><span class="line">        TestingParams.bTestWidgetIsInteractive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First add the exact point test results</span></span><br><span class="line">        <span class="keyword">const</span> FIndexAndDistance BestHit = <span class="built_in">GetHitIndexFromCellIndex</span>(TestingParams);</span><br><span class="line">        <span class="keyword">if</span> (BestHit.<span class="built_in">IsValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> FWidgetData&amp; BestHitWidgetData = BestHit.<span class="built_in">GetWidgetData</span>();</span><br><span class="line">            <span class="keyword">const</span> TSharedPtr&lt;SWidget&gt; FirstHitWidget = BestHitWidgetData.<span class="built_in">GetWidget</span>();</span><br><span class="line">            <span class="comment">// Make Sure we landed on a valid widget</span></span><br><span class="line">            <span class="keyword">if</span> (FirstHitWidget.<span class="built_in">IsValid</span>() &amp;&amp; <span class="built_in">IsCompatibleUserIndex</span>(UserIndex, BestHitWidgetData.UserIndex))</span><br><span class="line">            &#123;</span><br><span class="line">                TArray&lt;FWidgetAndPointer&gt; Path;</span><br><span class="line"></span><br><span class="line">                TSharedPtr&lt;SWidget&gt; CurWidget = FirstHitWidget;</span><br><span class="line">                <span class="keyword">while</span> (CurWidget.<span class="built_in">IsValid</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    FGeometry DesktopSpaceGeometry = CurWidget-&gt;<span class="built_in">GetPaintSpaceGeometry</span>();</span><br><span class="line">                    DesktopSpaceGeometry.<span class="built_in">AppendTransform</span>(<span class="built_in">FSlateLayoutTransform</span>(GridOrigin - GridWindowOrigin));</span><br><span class="line"></span><br><span class="line">                    Path.<span class="built_in">Emplace</span>(<span class="built_in">FArrangedWidget</span>(CurWidget.<span class="built_in">ToSharedRef</span>(), DesktopSpaceGeometry), TSharedPtr&lt;FVirtualPointerPosition&gt;());</span><br><span class="line">                    CurWidget = CurWidget-&gt;<span class="built_in">Advanced_GetPaintParentWidget</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!Path.<span class="built_in">Last</span>().Widget-&gt;<span class="built_in">Advanced_IsWindow</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> TArray&lt;FWidgetAndPointer&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Algo::<span class="built_in">Reverse</span>(Path);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">bool</span> bRemovedDisabledWidgets = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!bIgnoreEnabledStatus)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// @todo It might be more correct to remove all disabled widgets and non-hit testable widgets.  It doesn&#x27;t make sense to have a hit test invisible widget as a leaf in the path</span></span><br><span class="line">                    <span class="comment">// and that can happen if we remove a disabled widget. Furthermore if we did this we could then append custom paths in all cases since the leaf most widget would be hit testable</span></span><br><span class="line">                    <span class="comment">// For backwards compatibility changing this could be risky</span></span><br><span class="line">                    <span class="keyword">const</span> int32 DisabledWidgetIndex = Path.<span class="built_in">IndexOfByPredicate</span>([](<span class="keyword">const</span> FArrangedWidget&amp; SomeWidget) &#123; <span class="keyword">return</span> !SomeWidget.Widget-&gt;<span class="built_in">IsEnabled</span>(); &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (DisabledWidgetIndex != INDEX_NONE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        bRemovedDisabledWidgets = <span class="literal">true</span>;</span><br><span class="line">                        Path.<span class="built_in">RemoveAt</span>(DisabledWidgetIndex, Path.<span class="built_in">Num</span>() - DisabledWidgetIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!bRemovedDisabledWidgets &amp;&amp; Path.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (BestHitWidgetData.CustomPath.<span class="built_in">IsValid</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">const</span> TArray&lt;FWidgetAndPointer&gt; BubblePathExtension = BestHitWidgetData.CustomPath.<span class="built_in">Pin</span>()-&gt;<span class="built_in">GetBubblePathAndVirtualCursors</span>(FirstHitWidget-&gt;<span class="built_in">GetTickSpaceGeometry</span>(), DesktopSpaceCoordinate, bIgnoreEnabledStatus);</span><br><span class="line">                        Path.<span class="built_in">Append</span>(BubblePathExtension);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">return</span> Path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TArray&lt;FWidgetAndPointer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FHittestGrid::FIndexAndDistance <span class="title">FHittestGrid::GetHitIndexFromCellIndex</span><span class="params">(<span class="keyword">const</span> FGridTestingParams&amp; Params)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//check if the cell coord </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsValidCellCoord</span>(Params.CellCoord))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the cell and sort it </span></span><br><span class="line">        FCollapsedWidgetsArray WidgetIndexes;</span><br><span class="line">        <span class="built_in">GetCollapsedWidgets</span>(WidgetIndexes, Params.CellCoord.X, Params.CellCoord.Y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Consider front-most widgets first for hittesting.</span></span><br><span class="line">        <span class="keyword">for</span> (int32 i = WidgetIndexes.<span class="built_in">Num</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">check</span>(WidgetIndexes[i].<span class="built_in">IsValid</span>());</span><br><span class="line">            <span class="keyword">const</span> FWidgetData&amp; TestCandidate = WidgetIndexes[i].<span class="built_in">GetWidgetData</span>();</span><br><span class="line">            <span class="keyword">const</span> TSharedPtr&lt;SWidget&gt; TestWidget = TestCandidate.<span class="built_in">GetWidget</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// When performing a point hittest, accept all hittestable widgets.</span></span><br><span class="line">            <span class="comment">// When performing a hittest with a radius, only grab interactive widgets.</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> bIsValidWidget = TestWidget.<span class="built_in">IsValid</span>() &amp;&amp; (!Params.bTestWidgetIsInteractive || TestWidget-&gt;<span class="built_in">IsInteractable</span>());</span><br><span class="line">            <span class="keyword">if</span> (bIsValidWidget)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> FVector2D WindowSpaceCoordinate = Params.CursorPositionInGrid + GridWindowOrigin;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> FGeometry&amp; TestGeometry = TestWidget-&gt;<span class="built_in">GetPaintSpaceGeometry</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">bool</span> bPointInsideClipMasks = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (WidgetIndexes[i].<span class="built_in">GetCullingRect</span>().<span class="built_in">IsValid</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    bPointInsideClipMasks = WidgetIndexes[i].<span class="built_in">GetCullingRect</span>().<span class="built_in">ContainsPoint</span>(WindowSpaceCoordinate);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bPointInsideClipMasks)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> TOptional&lt;FSlateClippingState&gt;&amp; WidgetClippingState = TestWidget-&gt;<span class="built_in">GetCurrentClippingState</span>();</span><br><span class="line">                    <span class="keyword">if</span> (WidgetClippingState.<span class="built_in">IsSet</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Solve non-zero radius cursors?</span></span><br><span class="line">                        bPointInsideClipMasks = WidgetClippingState-&gt;<span class="built_in">IsPointInside</span>(WindowSpaceCoordinate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bPointInsideClipMasks)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Compute the render space clipping rect (FGeometry exposes a layout space clipping rect).</span></span><br><span class="line">                    <span class="keyword">const</span> FSlateRotatedRect WindowOrientedClipRect = <span class="built_in">TransformRect</span>(</span><br><span class="line">                        <span class="built_in">Concatenate</span>(</span><br><span class="line">                            <span class="built_in">Inverse</span>(TestGeometry.<span class="built_in">GetAccumulatedLayoutTransform</span>()),</span><br><span class="line">                            TestGeometry.<span class="built_in">GetAccumulatedRenderTransform</span>()),</span><br><span class="line">                        <span class="built_in">FSlateRotatedRect</span>(TestGeometry.<span class="built_in">GetLayoutBoundingRect</span>())</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">IsOverlappingSlateRotatedRect</span>(WindowSpaceCoordinate, Params.Radius, WindowOrientedClipRect))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// For non-0 radii also record the distance to cursor&#x27;s center so that we can pick the closest hit from the results.</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">bool</span> bNeedsDistanceSearch = Params.Radius &gt; <span class="number">0.0f</span>;</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">float</span> DistSq = (bNeedsDistanceSearch) ? <span class="built_in">DistanceSqToSlateRotatedRect</span>(WindowSpaceCoordinate, WindowOrientedClipRect) : <span class="number">0.0f</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">FIndexAndDistance</span>(WidgetIndexes[i], DistSq);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FIndexAndDistance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
        <category>SlateUI</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UMG源码笔记2-渲染过程</title>
    <url>/2021/06/17/umg-render/</url>
    <content><![CDATA[<h1 id="1-UMG类视图"><a href="#1-UMG类视图" class="headerlink" title="1.UMG类视图"></a>1.UMG类视图</h1><p>UMG 控件跟Unity UGUI不太一样，不是所有的控件节点，都能拥有子节点，为了区分这三种控件，整理了下他们基类：</p>
<ul>
<li><strong>UWidget</strong> : 所有UMG 控件的公共基类，不提供增加子节点功能</li>
<li><strong>UPanelWidget</strong> : 提供了增加子节点功能，可以有多个子节点</li>
<li><strong>UContentWidget</strong> : 继承于 <strong>UPanelWidget</strong> ，是 <strong>UPanelWidget</strong> 的一种特例，只能有一个子节点</li>
</ul>
<p>UMG常用控件的继承关系如下图所示:</p>
<img src="/images/umg_render/umg_class.png" width=70% height=70% align="center"/>

<p><strong>UPanelWidget</strong> 实现了可以增加节点的功能 <strong>AddChild</strong> ，然后提供了是否可以增加多个子节点的标记为，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UPanelSlot* <span class="title">UPanelWidget::AddChild</span><span class="params">(UWidget* Content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Content == <span class="literal">nullptr</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !bCanHaveMultipleChildren &amp;&amp; <span class="built_in">GetChildrenCount</span>() &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Content-&gt;<span class="built_in">RemoveFromParent</span>();</span><br><span class="line"></span><br><span class="line">    EObjectFlags NewObjectFlags = RF_Transactional;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">HasAnyFlags</span>(RF_Transient))</span><br><span class="line">    &#123;</span><br><span class="line">        NewObjectFlags |= RF_Transient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Slot </span></span><br><span class="line">    <span class="comment">// GetSlotClass  : 获取对应节点的Slot类</span></span><br><span class="line"></span><br><span class="line">    UPanelSlot* PanelSlot = NewObject&lt;UPanelSlot&gt;(<span class="keyword">this</span>, <span class="built_in">GetSlotClass</span>(), NAME_None, NewObjectFlags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slot-&gt;Content : 子节点</span></span><br><span class="line">    <span class="comment">// Slot-&gt;Parent  : 父节点 </span></span><br><span class="line">    PanelSlot-&gt;Parent = <span class="keyword">this</span>;</span><br><span class="line">    PanelSlot-&gt;Content = Content;</span><br><span class="line"></span><br><span class="line">    Content-&gt;Slot = PanelSlot;</span><br><span class="line"></span><br><span class="line">    Slots.<span class="built_in">Add</span>(PanelSlot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OnSlotAdded</span>(PanelSlot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InvalidateLayoutAndVolatility</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PanelSlot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UContentWidget</strong> 的实现是将 <strong>bCanHaveMultipleChildren</strong> 设置 <strong>false</strong> ，达到只有一个子节点的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UContentWidget::<span class="built_in">UContentWidget</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">    : <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    bCanHaveMultipleChildren = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中， <strong>GetSlotClass</strong> 返回对应控件的 <strong>Slot</strong> 的类型，下面的表格里给出了对应控件的 <strong>Slot</strong> 类型，即 <strong>GetSlotClass</strong> 返回的 <strong>Slot</strong> 的类型。创建后的 <strong>Slot</strong> 对象会分别指向父节点跟子节点。</p>
<table>
<thead>
<tr>
<th>控件</th>
<th>Slot类</th>
</tr>
</thead>
<tbody><tr>
<td>UWidget/UPanelWidget/UCheckBox/URetainerBox</td>
<td>UPanelSlot</td>
</tr>
<tr>
<td>USafeZone</td>
<td>USafeZoneSlot</td>
</tr>
<tr>
<td>USizeBox</td>
<td>USizeBoxSlot</td>
</tr>
<tr>
<td>UBorder</td>
<td>UBorderSlot</td>
</tr>
<tr>
<td>UButton</td>
<td>UButtonSlot</td>
</tr>
<tr>
<td>UCanvasPanel</td>
<td>UCanvasPanelSlot</td>
</tr>
<tr>
<td>UHorizontalBox</td>
<td>UHorizontalBoxSlot</td>
</tr>
<tr>
<td>UOverlay</td>
<td>UOverlaySlot</td>
</tr>
<tr>
<td>UScrollBox</td>
<td>UScrollBoxSlot</td>
</tr>
<tr>
<td>UGridPanel</td>
<td>UGridSlot</td>
</tr>
</tbody></table>
<h2 id="1-3-Slate控件类视图"><a href="#1-3-Slate控件类视图" class="headerlink" title="1.3 Slate控件类视图"></a>1.3 Slate控件类视图</h2><p><strong>Slate</strong> 中基础类是 <strong>SWidget</strong> ，这是个抽象类，不能实例化，此外还有三个继承 <strong>SWidget</strong> 的基础类，其他控件都是这个三个类的子类型。</p>
<ul>
<li><strong>SPanel</strong> : 有多个子节点，本身是个抽象类，子类需要定义子节点组织方式</li>
<li><strong>SLeafWidget</strong> : 没有子节点，抽象类，子节点需要重写 <strong>Paint</strong> 方法</li>
<li><strong>SCompoundWidget</strong> : 可以有一个子节点</li>
</ul>
<h1><img src="/images/umg_render/slate_class.png" width=100% height=100% align="center"/></h1>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SCompoundWidget</span> :</span> <span class="keyword">public</span> SWidget</span><br><span class="line">&#123;</span><br><span class="line">    FSimpleSlot ChildSlot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SBoxPanel</span> :</span> <span class="keyword">public</span> SPanel</span><br><span class="line">&#123;</span><br><span class="line">    TPanelChildren&lt;FSlot&gt; Children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SlotType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPanelChildren</span> :</span> <span class="keyword">public</span> FChildren, <span class="keyword">private</span> TIndirectArray&lt; SlotType &gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>TPanelChildren<FSlot></strong> : 实际上是一个 <strong>Array&lt;SWidget*&gt;</strong><br><strong>FSimpleSlot</strong> : 持有一个 <strong>SWidget*</strong></p>
</blockquote>
<h1 id="2-UMG渲染流程"><a href="#2-UMG渲染流程" class="headerlink" title="2 UMG渲染流程"></a>2 UMG渲染流程</h1><p>渲染一个SImage的调用栈如下：</p>
<img  src=http://www.plantuml.com/plantuml/svg/ZLDTQy8m57tlhmW-RGF_G1y4TOu9oiGF9WoHp5pRO7OZITHjltwtJUhQhav37vfppxdVkNkuP-rsvsc0YKGOQRsFuxdSxA8Cd2dkeBlVAxdXJcgyQkgYU3Jyz2f50ivU87e62dt2IvI9aKV2VfasablMQZ6N0aQCJjl897NjpXiBnyTa4oxH5HXR_HkUiksdKWbJyybctavvPDxyfSBmReTuv4gAtEzKQnVuTRYYhBgUANsQS9TwIcxDgWZM0bqkb_4BLY2VG5RAGC4784d6V0Sz_Lbb-6Y1CvAMU5qX5YXHEabPVeE8G5dmgcmarD9SEGKKO5RigNG3KvjU9TRqUTX4i-impO8z1QiFPWDZZZp9k8izDGlcyEaE1hfESGktkLvxS9uQu29NrBQaiYbKU6Y43NiHhZtkDcdckSJu8x-ew7FwRT3z8od8GtHWaAkRHFJHU8FXkg9FFIdcbeDHhZaFEuZ3-tdF6EpFMTNQBp6PQ7fANt7SEz3BEQEzmtOBfg7wFFGZTvmM54nIJWWQw4sHIbjke-W7>


<h2 id="2-1-FSlateApplication-渲染"><a href="#2-1-FSlateApplication-渲染" class="headerlink" title="2.1 FSlateApplication 渲染"></a>2.1 FSlateApplication 渲染</h2><p>首先介绍下几个关键的类</p>
<ul>
<li>UGameEngine : 全局对象 <strong>GEngine</strong> 类</li>
<li>FSlateApplication : 单例，游戏窗口类负责渲染 <strong>Slate</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UGameEngine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 游戏窗口句柄</span></span><br><span class="line">    TWeakPtr&lt;<span class="class"><span class="keyword">class</span> <span class="title">SWindow</span>&gt;</span> GameViewportWindow;</span><br><span class="line">    <span class="comment">// 游戏视口</span></span><br><span class="line">    UGameViewportClient* GameViewport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏GameInstance对象 ：WorkingCellGameInstance</span></span><br><span class="line">    UGameInstance* GameInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FSlateApplication</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">FSlateApplication</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存所有窗口</span></span><br><span class="line">    TArray&lt; TSharedRef&lt;SWindow&gt; &gt; SlateWindows;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏加载前闪屏</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FPreLoadScreenManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TWeakPtr&lt;<span class="class"><span class="keyword">class</span> <span class="title">SWindow</span>&gt;</span> MainWindow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">((FSlateRenderer&amp; InSlateRenderer);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> PassPreLoadScreenWindowBackToGame();</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br></pre></td></tr></table></figure>

<p><strong>FSlateApplication</strong> 是一个单例类，会在 <strong>FEngineLoop::PreInit</strong> 调用时创建：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function">int32 <span class="title">FEngineLoop::PreInit</span><span class="params">(<span class="keyword">const</span> TCHAR* CmdLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> int32 rv1 = <span class="built_in">PreInitPreStartupScreen</span>(CmdLine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="function">int32 <span class="title">FEngineLoop::PreInitPreStartupScreen</span><span class="params">(<span class="keyword">const</span> TCHAR* CmdLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    FSlateApplication::<span class="built_in">Create</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完 <strong>FSlateApplication</strong> 后，接下来会在 <strong>FEngineLoop::PreInitPreStartUpScreen</strong> 函数中调用 <strong>UGameEngine::CreateGameWindow()</strong> 创建游戏窗口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function">TSharedRef&lt;SWindow&gt; <span class="title">UGameEngine::CreateGameWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedRef&lt;SWindow&gt; Window = <span class="built_in">SNew</span>(SWindow);</span><br><span class="line"></span><br><span class="line">    FSlateApplication::<span class="built_in">Get</span>().<span class="built_in">AddWindow</span>( Window, bShowImmediately );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2. 如果有**PreLoadScreenManager**，则会在其初始化函数 **Initialize** </span></span><br><span class="line"><span class="comment">///    的时候创建，并赋值给**MainWindow**</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FPreLoadScreenManager::Initialize</span><span class="params">(FSlateRenderer&amp; InSlateRenderer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedRef&lt;SWindow&gt; GameWindow = (GameEngine &amp;&amp; GameEngine-&gt;GameViewportWindow.<span class="built_in">IsValid</span>()) ? </span><br><span class="line">    GameEngine-&gt;GameViewportWindow.<span class="built_in">Pin</span>().<span class="built_in">ToSharedRef</span>() : UGameEngine::<span class="built_in">CreateGameWindow</span>();</span><br><span class="line"></span><br><span class="line">    MainWindow = GameWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3. 然后在**PassPreLoadScreenWindowBackToGame**将窗口</span></span><br><span class="line"><span class="comment">///    赋值给**GameEngine-&gt;GameViewportWindow**</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FPreLoadScreenManager::PassPreLoadScreenWindowBackToGame</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GameEngine-&gt;GameViewportWindow = MainWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建的 <strong>SWindow</strong>会加到 <strong>FSlateApplication</strong> 的 <strong>SlateWindown</strong> 队列:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedRef&lt;SWindow&gt; <span class="title">FSlateApplication::AddWindow</span><span class="params">( TSharedRef&lt;SWindow&gt; InSlateWindow,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> <span class="keyword">bool</span> bShowImmediately )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    FSlateWindowHelper::<span class="built_in">ArrangeWindowToFront</span>(SlateWindows, InSlateWindow);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> InSlateWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染时，会遍历 <strong>SlateWindows</strong> 列表，依次渲染每个 <strong>Window</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateApplication::PrivateDrawWindows</span><span class="params">( TSharedPtr&lt;SWindow&gt; DrawOnlyThisWindow )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( TArray&lt; TSharedRef&lt;SWindow&gt; &gt;::TConstIterator <span class="built_in">CurrentWindowIt</span>( SlateWindows ); </span><br><span class="line">        CurrentWindowIt; ++CurrentWindowIt )</span><br><span class="line">    &#123;</span><br><span class="line">        TSharedRef&lt;SWindow&gt; CurrentWindow = *CurrentWindowIt;</span><br><span class="line">        <span class="comment">// Only draw visible windows or in off-screen rendering mode</span></span><br><span class="line">        <span class="keyword">if</span> (bRenderOffScreen || CurrentWindow-&gt;<span class="built_in">IsVisible</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DrawWindowAndChildren</span>( CurrentWindow, DrawWindowArgs );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateApplication::DrawWindowAndChildren</span><span class="params">( <span class="keyword">const</span> TSharedRef&lt;SWindow&gt;&amp; WindowToDraw, </span></span></span><br><span class="line"><span class="function"><span class="params">    FDrawWindowArgs&amp; DrawWindowArgs )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxLayerId = WindowToDraw-&gt;<span class="built_in">PaintWindow</span>(</span><br><span class="line">        <span class="built_in">GetCurrentTime</span>(),</span><br><span class="line">        <span class="built_in">GetDeltaTime</span>(),</span><br><span class="line">        WindowElementList,</span><br><span class="line">        <span class="built_in">FWidgetStyle</span>(),</span><br><span class="line">        WindowToDraw-&gt;<span class="built_in">IsEnabled</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UGameEngine</strong> 初始化时，还会创建 <strong>UGameViewportClient</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UGameEngine::Init</span><span class="params">(IEngineLoop* InEngineLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(GIsClient)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewportClient = NewObject&lt;UGameViewportClient&gt;(<span class="keyword">this</span>, GameViewportClientClass);</span><br><span class="line">        ViewportClient-&gt;<span class="built_in">Init</span>(*GameInstance-&gt;<span class="built_in">GetWorldContext</span>(), GameInstance);</span><br><span class="line">        GameViewport = ViewportClient;</span><br><span class="line">        GameInstance-&gt;<span class="built_in">GetWorldContext</span>()-&gt;GameViewport = ViewportClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- 游戏中打开的界面**UUserWidget**，都会调用**widiget::AddToViewport()**，将自己挂到**UGameViewportClient**上 -->

<h2 id="2-2-SWindow-渲染"><a href="#2-2-SWindow-渲染" class="headerlink" title="2.2 SWindow 渲染"></a>2.2 SWindow 渲染</h2><p><strong>SWindow</strong> 类的组成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SLATECORE_API</span> <span class="title">SWindow</span> :</span> <span class="keyword">public</span> SCompoundWidget, <span class="keyword">public</span> FSlateInvalidationRoot</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// Slate 事件检测加速类</span></span><br><span class="line">    TUniquePtr&lt;FHittestGrid&gt; HittestGrid;</span><br><span class="line">    SVerticalBox::FSlot* ContentSlot;</span><br><span class="line">    TWeakPtr&lt;SWindow&gt; ParentWindowPtr;</span><br><span class="line">    TArray&lt; TSharedRef&lt;SWindow&gt; &gt; ChildWindows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SWindow</strong>在初始化时，会在 ChildSlot里增加几个 <strong>SOverlay</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SWindow::ConstructWindowInternals</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ChildSlot</span><br><span class="line">    [</span><br><span class="line">        <span class="built_in">SAssignNew</span>(WindowOverlay, SOverlay)</span><br><span class="line">        .<span class="built_in">Visibility</span>(EVisibility::SelfHitTestInvisible)</span><br><span class="line">        <span class="comment">// window background</span></span><br><span class="line">        + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">        [</span><br><span class="line">            WindowBackgroundImage.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window border</span></span><br><span class="line">        + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">        [</span><br><span class="line">            WindowBorder.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window outline</span></span><br><span class="line">        + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">        [</span><br><span class="line">            WindowOutline.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">        ]</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染时，从 <strong>SlateApplication</strong> 对象调用 <strong>SWindow</strong> 的 <strong>PaintWindow</strong> 方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function">int32 <span class="title">SWindow::PaintWindow</span><span class="params">( <span class="keyword">double</span> CurrentTime, <span class="keyword">float</span> DeltaTime, </span></span></span><br><span class="line"><span class="function"><span class="params">    FSlateWindowElementList&amp; OutDrawElements, <span class="keyword">const</span> FWidgetStyle&amp; InWidgetStyle, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> bParentEnabled )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSlateInvalidationResult Result = <span class="built_in">PaintInvalidationRoot</span>(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="function">FSlateInvalidationResult <span class="title">FSlateInvalidationRoot::PaintInvalidationRoot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateInvalidationContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CachedMaxLayerId = <span class="built_in">PaintSlowPath</span>(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3</span></span><br><span class="line"><span class="function">int32 <span class="title">SWindow::PaintSlowPath</span><span class="params">(<span class="keyword">const</span> FSlateInvalidationContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HittestGrid-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FSlateRect WindowCullingBounds = <span class="built_in">GetClippingRectangleInWindow</span>();</span><br><span class="line">    <span class="keyword">const</span> int32 LayerId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> FGeometry WindowGeometry = <span class="built_in">GetWindowGeometryInWindow</span>();</span><br><span class="line"></span><br><span class="line">    int32 MaxLayerId = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    MaxLayerId = <span class="built_in">Paint</span>(*Context.PaintArgs, WindowGeometry, WindowCullingBounds, </span><br><span class="line">        *Context.WindowElementList, LayerId, Context.WidgetStyle,</span><br><span class="line">         Context.bParentEnabled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxLayerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 4. 最终调用到基类 SWidget::Paint 函数</span></span><br><span class="line"><span class="function">int32 <span class="title">SWidget::Paint</span><span class="params">(<span class="keyword">const</span> FPaintArgs&amp; Args, <span class="keyword">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="function"><span class="params">    int32 LayerId, <span class="keyword">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="keyword">bool</span> bParentEnabled)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 NewLayerId = <span class="built_in">OnPaint</span>(UpdatedArgs, AllottedGeometry, CullingBounds, </span><br><span class="line">        OutDrawElements, LayerId, ContentWidgetStyle, bParentEnabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 5</span></span><br><span class="line"><span class="function">int32 <span class="title">SWindow::OnPaint</span><span class="params">(<span class="keyword">const</span> FPaintArgs&amp; Args, <span class="keyword">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="function"><span class="params">    int32 LayerId, <span class="keyword">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="keyword">bool</span> bParentEnabled)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 MaxLayer = SCompoundWidget::<span class="built_in">OnPaint</span>(Args, AllottedGeometry, MyCullingRect, </span><br><span class="line">        OutDrawElements, LayerId, InWidgetStyle, bParentEnabled);</span><br><span class="line">    <span class="keyword">return</span> MaxLayer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不同的节点的<strong>OnPaint</strong>函数实现不一样<br><strong>SCompoundWidget</strong>只有一个子节点，直接调用子节点的Paint函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">SCompoundWidget::OnPaint</span><span class="params">( <span class="keyword">const</span> FPaintArgs&amp; Args, <span class="keyword">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, int32 LayerId, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="keyword">bool</span> bParentEnabled )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( ArrangedChildren.<span class="built_in">Num</span>() &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">check</span>( ArrangedChildren.<span class="built_in">Num</span>() == <span class="number">1</span> );</span><br><span class="line">        FArrangedWidget&amp; TheChild = ArrangedChildren[<span class="number">0</span>];</span><br><span class="line">       </span><br><span class="line">        int32 Layer = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            Layer = TheChild.Widget-&gt;<span class="built_in">Paint</span>( Args.<span class="built_in">WithNewParent</span>(<span class="keyword">this</span>), </span><br><span class="line">                TheChild.Geometry, MyCullingRect, OutDrawElements, LayerId + <span class="number">1</span>,</span><br><span class="line">                CompoundedWidgetStyle, <span class="built_in">ShouldBeEnabled</span>( bParentEnabled ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Layer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SPanel</strong> 有多个子节点，渲染接口如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int32 ChildIndex = <span class="number">0</span>; ChildIndex &lt; ArrangedChildren.<span class="built_in">Num</span>(); ++ChildIndex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> FArrangedWidget&amp; CurWidget = ArrangedChildren[ChildIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsChildWidgetCulled</span>(MyCullingRect, CurWidget))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> int32 CurWidgetsMaxLayerId = CurWidget.Widget-&gt;<span class="built_in">Paint</span>(NewArgs, </span><br><span class="line">            CurWidget.Geometry, MyCullingRect, OutDrawElements, LayerId,</span><br><span class="line">            InWidgetStyle, bShouldBeEnabled);</span><br><span class="line"></span><br><span class="line">        MaxLayerId = FMath::<span class="built_in">Max</span>(MaxLayerId, CurWidgetsMaxLayerId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终渲染到可渲染的子节点上，例如<strong>SImage</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function">int32 <span class="title">SImage::OnPaint</span><span class="params">( <span class="keyword">const</span> FPaintArgs&amp; Args, <span class="keyword">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="function"><span class="params">    int32 LayerId, <span class="keyword">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="keyword">bool</span> bParentEnabled )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> FSlateBrush* ImageBrush = Image.<span class="built_in">GetImage</span>().<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ImageBrush != <span class="literal">nullptr</span>) &amp;&amp; (ImageBrush-&gt;DrawAs != ESlateBrushDrawType::NoDrawType))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> bIsEnabled = <span class="built_in">ShouldBeEnabled</span>(bParentEnabled);</span><br><span class="line">        <span class="keyword">const</span> ESlateDrawEffect DrawEffects = bIsEnabled ? ESlateDrawEffect::None :</span><br><span class="line">            ESlateDrawEffect::DisabledEffect;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">const</span> FLinearColor <span class="title">FinalColorAndOpacity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            InWidgetStyle.GetColorAndOpacityTint() * </span></span></span><br><span class="line"><span class="function"><span class="params">            ColorAndOpacity.Get().GetColor(InWidgetStyle) * </span></span></span><br><span class="line"><span class="function"><span class="params">            ImageBrush-&gt;GetTint( InWidgetStyle ) )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bFlipForRightToLeftFlowDirection &amp;&amp; GSlateFlowDirection == EFlowDirection::RightToLeft)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> FGeometry FlippedGeometry = AllottedGeometry.MakeChild</span><br><span class="line">                (<span class="built_in">FSlateRenderTransform</span>(<span class="built_in">FScale2D</span>(<span class="number">-1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">            FSlateDrawElement::<span class="built_in">MakeBox</span>(OutDrawElements, LayerId,</span><br><span class="line">                FlippedGeometry.<span class="built_in">ToPaintGeometry</span>(), ImageBrush, DrawEffects,</span><br><span class="line">                FinalColorAndOpacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            FSlateDrawElement::<span class="built_in">MakeBox</span>(OutDrawElements, LayerId, AllottedGeometry.<span class="built_in">ToPaintGeometry</span>(), </span><br><span class="line">                ImageBrush, DrawEffects, FinalColorAndOpacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LayerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="comment">/// 最后调用 **FSlateDrawElement** 来生成对应的渲染元素</span></span><br><span class="line"><span class="comment">/// FSlateDrawElement::MakeBox -&gt; FSlateDrawElement::MakeBoxInternal</span></span><br><span class="line"><span class="function">FSlateDrawElement&amp; <span class="title">FSlateDrawElement::MakeBoxInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    FSlateWindowElementList&amp; ElementList,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint32 InLayer,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FPaintGeometry&amp; PaintGeometry,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateBrush* InBrush,</span></span></span><br><span class="line"><span class="function"><span class="params">    ESlateDrawEffect InDrawEffects,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FLinearColor&amp; InTint</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 记住这个 ElementType，后面还有用到</span></span><br><span class="line">    EElementType ElementType = (InBrush-&gt;DrawAs == ESlateBrushDrawType::Border) ? </span><br><span class="line">        EElementType::ET_Border : EElementType::ET_Box;</span><br><span class="line"></span><br><span class="line">    FSlateDrawElement&amp; Element = ElementList.<span class="built_in">AddUninitialized</span>();</span><br><span class="line">    FSlateBoxPayload&amp; BoxPayload = ElementList.CreatePayload&lt;FSlateBoxPayload&gt;(Element);</span><br><span class="line"></span><br><span class="line">    BoxPayload.<span class="built_in">SetTint</span>(InTint);</span><br><span class="line">    BoxPayload.<span class="built_in">SetBrush</span>(InBrush);</span><br><span class="line"></span><br><span class="line">    Element.<span class="built_in">Init</span>(ElementList, ElementType, InLayer, PaintGeometry, InDrawEffects);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>SlateApplication</strong>中的<strong>Renderer</strong>中有专门的渲染buff<strong>DrawBuffer</strong>，调用完OnPaint后都会将自己的渲染数据<strong>Element</strong>添加到 <strong>ElementListd</strong>队列中，给后面合批准备数据。</p>
<h2 id="2-3-真正的Render"><a href="#2-3-真正的Render" class="headerlink" title="2.3 真正的Render"></a>2.3 真正的Render</h2><p>下面进入真正的渲染流程了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateApplication::PrivateDrawWindows</span><span class="params">( TSharedPtr&lt;SWindow&gt; DrawOnlyThisWindow )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 这是上面说的，依次 Paint 每个 SWindow  </span></span><br><span class="line">    <span class="keyword">for</span>( TArray&lt; TSharedRef&lt;SWindow&gt; &gt;::TConstIterator <span class="built_in">CurrentWindowIt</span>( SlateWindows ); </span><br><span class="line">        CurrentWindowIt; ++CurrentWindowIt )</span><br><span class="line">    &#123;</span><br><span class="line">        TSharedRef&lt;SWindow&gt; CurrentWindow = *CurrentWindowIt;</span><br><span class="line">        <span class="comment">// Only draw visible windows or in off-screen rendering mode</span></span><br><span class="line">        <span class="keyword">if</span> (bRenderOffScreen || CurrentWindow-&gt;<span class="built_in">IsVisible</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DrawWindowAndChildren</span>( CurrentWindow, DrawWindowArgs );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 开始准备合批，并且生成 render 指令</span></span><br><span class="line">    <span class="comment">/// OutDrawBuffer : 之前所有Slate控件的Element数据都在这里</span></span><br><span class="line">    Renderer-&gt;<span class="built_in">DrawWindows</span>( DrawWindowArgs.OutDrawBuffer );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateRHIRenderer::DrawWindows</span><span class="params">(FSlateDrawBuffer&amp; WindowDrawBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DrawWindows_Private</span>(WindowDrawBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateRHIRenderer::DrawWindows_Private</span><span class="params">(FSlateDrawBuffer&amp; WindowDrawBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// SlateBlush资源合并图集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DoesThreadOwnSlateRendering</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ResourceManager-&gt;<span class="built_in">UpdateTextureAtlases</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 按照 Window 处理 Element 数据</span></span><br><span class="line">    <span class="keyword">for</span> (int32 ListIndex = <span class="number">0</span>; ListIndex &lt; WindowElementLists.<span class="built_in">Num</span>(); ++ListIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        FSlateWindowElementList&amp; ElementList = *WindowElementLists[ListIndex];</span><br><span class="line"></span><br><span class="line">        ElementBatcher-&gt;<span class="built_in">AddElements</span>(ElementList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 4. ElementBatcher 定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FSlateRHIRenderer</span> :</span> <span class="keyword">public</span> FSlateRenderer</span><br><span class="line">&#123;</span><br><span class="line">    TUniquePtr&lt;FSlateElementBatcher&gt; ElementBatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 5 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateElementBatcher::AddElements</span><span class="params">(FSlateWindowElementList&amp; WindowElementList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">AddElementsInternal</span>(WindowElementList.<span class="built_in">GetUncachedDrawElements</span>(), ViewportSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 6. 之前 SImage 用到的 ElementType ET_Box/ET_Border</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EElementType</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">    ET_Box,</span><br><span class="line">    ET_DebugQuad,</span><br><span class="line">    ET_Text,</span><br><span class="line">    ET_ShapedText,</span><br><span class="line">    ET_Spline,</span><br><span class="line">    ET_Line,</span><br><span class="line">    ET_Gradient,</span><br><span class="line">    ET_Viewport,</span><br><span class="line">    ET_Border,</span><br><span class="line">    ET_Custom,</span><br><span class="line">    ET_CustomVerts,</span><br><span class="line">    ET_PostProcessPass,</span><br><span class="line">    <span class="comment">/** Total number of draw commands */</span></span><br><span class="line">    ET_Count,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateElementBatcher::AddElementsInternal</span><span class="params">(<span class="keyword">const</span> FSlateDrawElementArray&amp; DrawElements, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FVector2D&amp; ViewportSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> FSlateDrawElement&amp; DrawElement : DrawElements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Determine what type of element to add</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> ( DrawElement.<span class="built_in">GetElementType</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 之前 SImage 用到的 ElementType ET_Box/ET_Border</span></span><br><span class="line">        <span class="keyword">case</span> EElementType::ET_Box:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">SCOPED_NAMED_EVENT_TEXT</span>(<span class="string">&quot;Slate::AddBoxElement&quot;</span>, FColor::Magenta);</span><br><span class="line">            <span class="built_in">STAT</span>(ElementStat_Boxes++);</span><br><span class="line">            DrawElement.<span class="built_in">IsPixelSnapped</span>() ? AddBoxElement&lt;ESlateVertexRounding::Enabled&gt;(DrawElement) : </span><br><span class="line">                AddBoxElement&lt;ESlateVertexRounding::Disabled&gt;(DrawElement);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EElementType::ET_Border:</span><br><span class="line">        <span class="keyword">case</span> EElementType::ET_Text:</span><br><span class="line"></span><br><span class="line">        <span class="comment">///...</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 7</span></span><br><span class="line"><span class="keyword">template</span>&lt;ESlateVertexRounding Rounding&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateElementBatcher::AddBoxElement</span><span class="params">(<span class="keyword">const</span> FSlateDrawElement&amp; DrawElement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    FSlateRenderBatch&amp; RenderBatch = <span class="built_in">CreateRenderBatch</span>( Layer, <span class="built_in">FShaderParams</span>(), Resource, </span><br><span class="line">        ESlateDrawPrimitive::TriangleList, ESlateShader::Default, InDrawEffects, DrawFlags, </span><br><span class="line">        DrawElement);</span><br><span class="line">    <span class="comment">// Create 9 quads for the box element based on the following diagram</span></span><br><span class="line">    <span class="comment">//     ___LeftMargin    ___RightMargin</span></span><br><span class="line">    <span class="comment">//    /                /</span></span><br><span class="line">    <span class="comment">//  +--+-------------+--+</span></span><br><span class="line">    <span class="comment">//  |  |c1           |c2| ___TopMargin</span></span><br><span class="line">    <span class="comment">//  +--o-------------o--+</span></span><br><span class="line">    <span class="comment">//  |  |             |  |</span></span><br><span class="line">    <span class="comment">//  |  |c3           |c4|</span></span><br><span class="line">    <span class="comment">//  +--o-------------o--+</span></span><br><span class="line">    <span class="comment">//  |  |             |  | ___BottomMargin</span></span><br><span class="line">    <span class="comment">//  +--+-------------+--+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 一共16个顶点数据</span></span><br><span class="line">    RenderBatch.<span class="built_in">AddVertex</span>( FSlateVertex::Make&lt;Rounding&gt;( RenderTransform, <span class="built_in">FVector2D</span>( Position.X, Position.Y ),</span><br><span class="line">       LocalSize, DrawScale, <span class="built_in">FVector4</span>(StartUV, Tiling), Tint ) ); <span class="comment">//0</span></span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    RenderBatch.<span class="built_in">AddVertex</span>( FSlateVertex::Make&lt;Rounding&gt;( RenderTransform, <span class="built_in">FVector2D</span>( EndPos.X, EndPos.Y ),</span><br><span class="line">       LocalSize, DrawScale, <span class="built_in">FVector4</span>(EndUV, Tiling), Tint ) ); <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Top</span></span><br><span class="line">    RenderBatch.<span class="built_in">AddIndex</span>( IndexStart + <span class="number">0</span> );</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    RenderBatch.<span class="built_in">AddIndex</span>( IndexStart + <span class="number">15</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 8. 所有的Element都会存储Layer Shader参数等信息，添加成待合批数据。</span></span><br><span class="line"><span class="function">FSlateRenderBatch&amp; <span class="title">FSlateElementBatcher::CreateRenderBatch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    int32 Layer, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FShaderParams&amp; ShaderParams,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateShaderResource* InResource,</span></span></span><br><span class="line"><span class="function"><span class="params">    ESlateDrawPrimitive PrimitiveType,</span></span></span><br><span class="line"><span class="function"><span class="params">    ESlateShader ShaderType,</span></span></span><br><span class="line"><span class="function"><span class="params">    ESlateDrawEffect DrawEffects,</span></span></span><br><span class="line"><span class="function"><span class="params">    ESlateBatchDrawFlag DrawFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateDrawElement&amp; DrawElement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSlateRenderBatch&amp; NewBatch = CurrentCachedElementList</span><br><span class="line">        ? CurrentCachedElementList-&gt;<span class="built_in">AddRenderBatch</span>(Layer, ShaderParams, InResource,</span><br><span class="line">            PrimitiveType, ShaderType, DrawEffects, DrawFlags, DrawElement.<span class="built_in">GetSceneIndex</span>())</span><br><span class="line"></span><br><span class="line">        : BatchData-&gt;<span class="built_in">AddRenderBatch</span>(Layer, ShaderParams, InResource, PrimitiveType, </span><br><span class="line">            ShaderType, DrawEffects, DrawFlags, DrawElement.<span class="built_in">GetSceneIndex</span>());</span><br><span class="line"></span><br><span class="line">    NewBatch.ClippingState = <span class="built_in">ResolveClippingState</span>(DrawElement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewBatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 9. 最后新建合批任务，在新建的线程里进行合批</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateRHIRenderer::DrawWindows_Private</span><span class="params">(FSlateDrawBuffer&amp; WindowDrawBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GIsClient &amp;&amp; !<span class="built_in">IsRunningCommandlet</span>() &amp;&amp; !GUsingNullRHI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ENQUEUE_RENDER_COMMAND</span>(SlateDrawWindowsCommand)(</span><br><span class="line">            [Params, ViewInfo](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/// 10. 切换到渲染线程</span></span><br><span class="line">                Params.Renderer-&gt;<span class="built_in">DrawWindow_RenderThread</span>(RHICmdList, *ViewInfo, </span><br><span class="line">                    *Params.WindowElementList, Params);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 10. 切换到渲染线程</span></span><br><span class="line"><span class="comment">/** Draws windows from a FSlateDrawBuffer on the render thread */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateRHIRenderer::DrawWindow_RenderThread</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList,</span></span></span><br><span class="line"><span class="function"><span class="params">    FViewportInfo&amp; ViewportInfo, FSlateWindowElementList&amp; WindowElementList, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct FSlateDrawWindowCommandParams&amp; DrawCommandParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RenderingPolicy-&gt;<span class="built_in">BuildRenderingBuffers</span>(RHICmdList, BatchData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 11. 创建渲染Buffers </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateRHIRenderingPolicy::BuildRenderingBuffers</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, </span></span></span><br><span class="line"><span class="function"><span class="params">    FSlateBatchData&amp; InBatchData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 12. Slate 数据合批</span></span><br><span class="line">    InBatchData.<span class="built_in">MergeRenderBatches</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 12. Slate 数据合批</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateBatchData::MergeRenderBatches</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (int32 TestIndex = BatchIndex + <span class="number">1</span>; TestIndex &lt; BatchIndices.<span class="built_in">Num</span>(); ++TestIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> TPair&lt;int32, int32&gt;&amp; NextBatchIndexPair = BatchIndices[TestIndex];</span><br><span class="line">        FSlateRenderBatch&amp; TestBatch = RenderBatches[NextBatchIndexPair.Key];</span><br><span class="line">        <span class="keyword">if</span> (TestBatch.<span class="built_in">GetLayer</span>() != CurBatch.<span class="built_in">GetLayer</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// none of the batches will be compatible since we encountered an incompatible layer</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///                                       13. 合批规则</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!TestBatch.bIsMerged &amp;&amp; CurBatch.<span class="built_in">IsBatchableWith</span>(TestBatch))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CombineBatches</span>(CurBatch, TestBatch, FinalVertexData, FinalIndexData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 13. 合批规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBatchableWith</span><span class="params">(<span class="keyword">const</span> FSlateRenderBatch&amp; Other)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        ShaderResource == Other.ShaderResource</span><br><span class="line">        &amp;&amp; DrawFlags == Other.DrawFlags</span><br><span class="line">        &amp;&amp; ShaderType == Other.ShaderType</span><br><span class="line">        &amp;&amp; DrawPrimitiveType == Other.DrawPrimitiveType</span><br><span class="line">        &amp;&amp; DrawEffects == Other.DrawEffects</span><br><span class="line">        &amp;&amp; ShaderParams == Other.ShaderParams</span><br><span class="line">        &amp;&amp; InstanceData == Other.InstanceData</span><br><span class="line">        &amp;&amp; InstanceCount == Other.InstanceCount</span><br><span class="line">        &amp;&amp; InstanceOffset == Other.InstanceOffset</span><br><span class="line">        &amp;&amp; DynamicOffset == Other.DynamicOffset</span><br><span class="line">        &amp;&amp; CustomDrawer == Other.CustomDrawer</span><br><span class="line">        &amp;&amp; SceneIndex == Other.SceneIndex</span><br><span class="line">        &amp;&amp; ClippingState == Other.ClippingState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 14. 合批结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateRHIRenderingPolicy::BuildRenderingBuffers</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList,</span></span></span><br><span class="line"><span class="function"><span class="params">    FSlateBatchData&amp; InBatchData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 10/11/12 Draw Element 合批</span></span><br><span class="line">    InBatchData.<span class="built_in">MergeRenderBatches</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 合批结束 开始发送渲染指令</span></span><br><span class="line">    <span class="keyword">const</span> FSlateVertexArray&amp; FinalVertexData = InBatchData.<span class="built_in">GetFinalVertexData</span>();</span><br><span class="line">    <span class="keyword">const</span> FSlateIndexArray&amp; FinalIndexData = InBatchData.<span class="built_in">GetFinalIndexData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> int32 NumVertices = FinalVertexData.<span class="built_in">Num</span>();</span><br><span class="line">    <span class="keyword">const</span> int32 NumIndices = FinalIndexData.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InBatchData.<span class="built_in">GetRenderBatches</span>().<span class="built_in">Num</span>() &gt; <span class="number">0</span> &amp;&amp; NumVertices &gt; <span class="number">0</span> &amp;&amp; NumIndices &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> bShouldShrinkResources = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        RHICmdList.<span class="built_in">EnqueueLambda</span>([</span><br><span class="line">            VertexBuffer = MasterVertexBuffer.VertexBufferRHI.<span class="built_in">GetReference</span>(),</span><br><span class="line">            IndexBuffer = MasterIndexBuffer.IndexBufferRHI.<span class="built_in">GetReference</span>(),</span><br><span class="line">            &amp;InBatchData,</span><br><span class="line">            bAbsoluteIndices</span><br><span class="line">        ](FRHICommandListImmediate&amp; InRHICmdList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_SlateUpdateBufferRTTimeLambda);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Note: Use &quot;Lambda&quot; prefix to prevent clang/gcc warnings of &#x27;-Wshadow&#x27; warning</span></span><br><span class="line">            <span class="keyword">const</span> FSlateVertexArray&amp; LambdaFinalVertexData = InBatchData.<span class="built_in">GetFinalVertexData</span>();</span><br><span class="line">            <span class="keyword">const</span> FSlateIndexArray&amp; LambdaFinalIndexData = InBatchData.<span class="built_in">GetFinalIndexData</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> int32 NumBatchedVertices = LambdaFinalVertexData.<span class="built_in">Num</span>();</span><br><span class="line">            <span class="keyword">const</span> int32 NumBatchedIndices = LambdaFinalIndexData.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">            uint32 RequiredVertexBufferSize = NumBatchedVertices * </span><br><span class="line">                <span class="built_in"><span class="keyword">sizeof</span></span>(FSlateVertex);</span><br><span class="line">            uint8* VertexBufferData = (uint8*)InRHICmdList.<span class="built_in">LockVertexBuffer</span>(VertexBuffer, <span class="number">0</span>, </span><br><span class="line">                RequiredVertexBufferSize, RLM_WriteOnly);</span><br><span class="line"></span><br><span class="line">            uint32 RequiredIndexBufferSize = NumBatchedIndices * <span class="built_in"><span class="keyword">sizeof</span></span>(SlateIndex);</span><br><span class="line">            uint8* IndexBufferData = (uint8*)InRHICmdList.<span class="built_in">LockIndexBuffer</span>(IndexBuffer, <span class="number">0</span>, </span><br><span class="line">                RequiredIndexBufferSize, RLM_WriteOnly);</span><br><span class="line"></span><br><span class="line">            FMemory::<span class="built_in">Memcpy</span>(VertexBufferData, LambdaFinalVertexData.<span class="built_in">GetData</span>(), RequiredVertexBufferSize);</span><br><span class="line">            FMemory::<span class="built_in">Memcpy</span>(IndexBufferData, LambdaFinalIndexData.<span class="built_in">GetData</span>(), RequiredIndexBufferSize);</span><br><span class="line"></span><br><span class="line">            InRHICmdList.<span class="built_in">UnlockVertexBuffer</span>(VertexBuffer);</span><br><span class="line">            InRHICmdList.<span class="built_in">UnlockIndexBuffer</span>(IndexBuffer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 15.回到渲染线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateRHIRenderer::DrawWindow_RenderThread</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 12. Slate 数据合批</span></span><br><span class="line">    InBatchData.<span class="built_in">MergeRenderBatches</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="keyword">const</span> uint32 ViewportWidth = (ViewportRT) ? ViewportRT-&gt;<span class="built_in">GetSizeX</span>() :</span><br><span class="line">        ViewportInfo.Width;</span><br><span class="line">    <span class="keyword">const</span> uint32 ViewportHeight = (ViewportRT) ? ViewportRT-&gt;<span class="built_in">GetSizeY</span>() : </span><br><span class="line">        ViewportInfo.Height;</span><br><span class="line"></span><br><span class="line">    <span class="function">FSlateBackBuffer <span class="title">BackBufferTarget</span><span class="params">(BackBuffer, FIntPoint(ViewportWidth, </span></span></span><br><span class="line"><span class="function"><span class="params">        ViewportHeight))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 16. DrawElements</span></span><br><span class="line">    RenderingPolicy-&gt;DrawElements</span><br><span class="line">    (</span><br><span class="line">        RHICmdList,</span><br><span class="line">        BackBufferTarget,</span><br><span class="line">        BackBuffer,</span><br><span class="line">        PostProcessBuffer,</span><br><span class="line">        ViewportInfo.bRequiresStencilTest ? ViewportInfo.DepthStencil : EmptyTarget,</span><br><span class="line">        BatchData.<span class="built_in">GetFirstRenderBatchIndex</span>(),</span><br><span class="line">        BatchData.<span class="built_in">GetRenderBatches</span>(),</span><br><span class="line">        RenderParams</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 16. DrawElements</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FSlateRHIRenderingPolicy::DrawElements</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    FRHICommandListImmediate&amp; RHICmdList,</span></span></span><br><span class="line"><span class="function"><span class="params">    FSlateBackBuffer&amp; BackBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    FTexture2DRHIRef&amp; ColorTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">    FTexture2DRHIRef&amp; PostProcessTexture,</span></span></span><br><span class="line"><span class="function"><span class="params">    FTexture2DRHIRef&amp; DepthStencilTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">    int32 FirstBatchIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> TArray&lt;FSlateRenderBatch&gt;&amp; RenderBatches,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> FSlateRenderingParams&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (NextRenderBatchIndex != INDEX_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">        VertexBufferPtr = &amp;MasterVertexBuffer;</span><br><span class="line">        IndexBufferPtr = &amp;MasterIndexBuffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// for RHIs that can&#x27;t handle VertexOffset, we need to offset </span></span><br><span class="line">        <span class="comment">// the stream source each time</span></span><br><span class="line">        RHICmdList.<span class="built_in">SetStreamSource</span>(<span class="number">0</span>, VertexBufferPtr-&gt;VertexBufferRHI, </span><br><span class="line">            RenderBatch.VertexOffset * <span class="built_in"><span class="keyword">sizeof</span></span>(FSlateVertex));</span><br><span class="line"></span><br><span class="line">        RHICmdList.<span class="built_in">DrawIndexedPrimitive</span>(IndexBufferPtr-&gt;IndexBufferRHI, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">            RenderBatch.NumVertices, RenderBatch.IndexOffset, PrimitiveCount, </span><br><span class="line">            RenderBatch.InstanceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，就完成了Slate的渲染了。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
        <category>SlateUI</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 static 变量 GC 导致闪退问题</title>
    <url>/2021/06/17/ue4-static/</url>
    <content><![CDATA[<p>最近开发一个 UMG 插件，插件里用到了静态变量，在 UE4 编辑器里运行没有啥问题，然后打了手机包iOS后，运行一段时间后，闪退了，闪退点就是我写的代码里中访问全局变量的时候，使用 UnrealVS 插件在 VS2019 下开启 Window 模式，也出现了类似的闪退问题：</p>
<p>UnrealVS 参数</p>
<blockquote>
<p>“E:\xxx.uproject” -game -windowed -log -verbose</p>
</blockquote>
<p>闪退代码处：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UMGEXT_API</span> <span class="title">UExtTextBlock</span> :</span> <span class="keyword">public</span> UTextBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> UDataTable* ExtTextStyleSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp 文件</span></span><br><span class="line">UDataTable* UExtTextBlock::ExtTextStyleSet = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UExtTextBlock::EnsureTextDataTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == ExtTextStyleSet || !ExtTextStyleSet-&gt;<span class="built_in">IsValidLowLevel</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ExtTextStyleSet = LoadObject&lt;UDataTable&gt;(<span class="literal">nullptr</span>, *DataPath);</span><br><span class="line">        ExtTextStyleSet-&gt;<span class="built_in">AddToRoot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FTextBlockStyle <span class="title">UExtTextBlock::GetTextStyleByName</span><span class="params">(FName StyleName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EnsureTextDataTable</span>();</span><br><span class="line">    FTextBlockStyle Style = FTextBlockStyle::<span class="built_in">GetDefault</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == UExtTextBlock::ExtTextStyleSet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 闪退地方</span></span><br><span class="line">    <span class="keyword">auto</span> RowMap = UExtTextBlock::ExtTextStyleSet-&gt;<span class="built_in">GetRowMap</span>();</span><br><span class="line">    <span class="keyword">if</span>(RowMap.<span class="built_in">Contains</span>(StyleName))</span><br><span class="line">    &#123;</span><br><span class="line">        FRichTextStyleRow* RichTextStyle = (FRichTextStyleRow*)(RowMap[StyleName]);</span><br><span class="line">        Style = RichTextStyle-&gt;TextStyle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Style;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 VS2019 调试闪退点，查看 UExtTextBlock::ExtTextStyleSet 内存，每次都不一样，而且类型对象完全不匹配，所以联想到可能是内存空间被GC，然后之前指向的内存被其他变量占用了，于是去谷歌。</p>
<p>要防止对象被GC，有4种方式：</p>
<ul>
<li>作为成员变量并标记为UPROPERTY()；</li>
<li>创建对象后 AddToRoot() ；（退出游戏时需要RemoveFromRoot()）</li>
<li>FStreamableManager Load资源时，bManageActiveHandle 设置为true；</li>
<li>FGCObjectScopeGuard 在指定代码区域内保持对象；</li>
</ul>
<blockquote>
<p>注意：<br>一个UObject类型的变量，即使是static，默认也会被GC掉。</p>
</blockquote>
<p>知道了原因，就好解决问题了，于是做了一下修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 插件模块代码 </span></span><br><span class="line"><span class="comment">/// 启动时: 加载创建静态变量，并且将 静态变量加到 Root 上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FUMGExtModule::StartupModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogUMGExtModule, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;UMGExtModule StartupModule&quot;</span>));</span><br><span class="line"></span><br><span class="line">    UExtTextBlock::<span class="built_in">EnsureTextDataTable</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 模块卸载时：将静态变量从 Root 拿掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FUMGExtModule::ShutdownModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogUMGExtModule, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;UMGExtModule ShutdownModule&quot;</span>));</span><br><span class="line"></span><br><span class="line">    UExtTextBlock::<span class="built_in">ClearTextDataTable</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 对应类的代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UExtTextBlock::EnsureTextDataTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == ExtTextStyleSet || !ExtTextStyleSet-&gt;<span class="built_in">IsValidLowLevel</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ExtTextStyleSet = LoadObject&lt;UDataTable&gt;(<span class="literal">nullptr</span>, *DataPath);</span><br><span class="line">        <span class="comment">/// AddToRoot : 防止被 GC</span></span><br><span class="line">        ExtTextStyleSet-&gt;<span class="built_in">AddToRoot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UExtTextBlock::ClearTextDataTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != ExtTextStyleSet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// RemoveFromRoot : 可以 GC 了 </span></span><br><span class="line">        ExtTextStyleSet-&gt;<span class="built_in">RemoveFromRoot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
</search>
