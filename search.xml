<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大气散射 ( Atmosphere Scattering)</title>
    <url>/post/8e5d3b12/</url>
    <content><![CDATA[<h2 id="大气散射介绍">大气散射介绍</h2>
<p>当你看到蓝天白云，日落黄昏，或者从太空遥望地球，地球周围一圈蓝色光晕，有没有想过这些现象产生的原因是什么？这些物理现象用一句话解释：太阳光与大气层中的参与介质发生了大气散射现象，从而形成了天空颜色</p>
<p><img src="/images/atmosphere_scatter/atmosphere_intro.png" width="100%" height="100%" /></p>
<!-- ## 大气散射物理模型

传统渲染技术都是假定对象是一个空壳（例如球，立方体），不讨论对象内部内容，所有的图形计算都在对象表面进行。如下图迪士尼材质模型：

<img src="/images/atmosphere_scatter/disney_1.jpeg" width="70%" height="70%" />

但是大气就很难这么处理，因为天空并不是一个“物体”，我们不能只是渲染表面，还需要模拟光线在大气中到底经历了什么。接下来介绍一种比较合适的方法，被称为：体积单次散射（volumetric single scattering）。 -->
<h2 id="散射">散射</h2>
<p>光源的辐射沿着路径前行时，碰到参与介质时会发生几种不同散射现象的行为:</p>
<ul>
<li><p>出射散射（Out-Scattering）
出射散射也就是光子碰到空气中的分子后，原本要射向摄像机的光线发生了偏转，光线的方向改变了</p>
<div data-align="center">
<img src="/images/atmosphere_scatter/scattering01.png" width="50%" height="50%" />
</div></li>
<li><p>入射散射（In-Scattering）
入射散射与出射散射相反，本来不指向相机的光线也可能被偏转到相机的方向，这就是入射散射。</p>
<div data-align="center">
<img src="/images/atmosphere_scatter/scattering_02.png" width="50%" height="50%" />
</div></li>
</ul>
<p>根据粒子大小不同可分为<strong>瑞利散射（Rayleigh
Scattering）</strong> 和 <strong>米氏散射（Mie Scattering）</strong>
&gt;
光碰到不同大小粒子后发生散射，不同方向上的光强如下图，箭头长度表示光线强弱，箭头越长，光线越强。</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/scattering05.png" width="80%" height="80%" /></p>
</div>
<h2 id="大气散射模型">大气散射模型</h2>
<p>大气散射模型分为两种：Single Scattering和Multi Scattering。</p>
<ul>
<li><p>Single Scattering
即只考虑太阳光经过一次散射后抵达我们的眼睛。</p></li>
<li><p>Multi
Scattering，考虑光线多次散射过程的模型。显然这更符合现实世界的情况，但下一级的散射取决于与上一级散射的结果，也就是说这是一个递归方程，实现起来并不太容易。</p></li>
</ul>
<blockquote>
<p>由于第二次散射以上的能量较少，对最终视觉的影响程度有限，所以目前Single
Scattering 还是一种相对实现简单效果也不会差很多的模型，这里也主要介绍
Single Scattering。</p>
</blockquote>
<p>因此单次散射大气模型求解问题如下： 我们从路径 AB 观察大气，并且求解 B
点的大气颜色，光线在大气中只发生一次散射，散射点为 P：</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/scattering_06a.png" width="50%" height="50%" /></p>
</div>
<p>实际上在路径 AB 上有无数个 P 点，因此最终求解是对 AB
路径上每一个点的光照贡献进行累加(求积分)</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/scattering_08a.png" width="50%" height="50%" /></p>
</div>
<p>因此整个模型可以分解成如下问题：</p>
<ul>
<li>P 点光照 ：光线穿过大气会衰减，到达 P 点后的光照强度。</li>
<li>光线在 P 散射：进入相机方向的光照，即入射散射部分</li>
<li>累加所有 P 点光照</li>
</ul>
<h3 id="透射函数">透射函数</h3>
<p>为了计算散射点的光照，我们先考虑如下一段光线：</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/scattering_07.png" width="50%" height="50%" /></p>
</div>
<ul>
<li>光线从太阳传到 C，此时是真空，所以没有损失，我们用 <span
class="math inline">\(I_C\)</span> 指代 C 点的光强</li>
<li>在从 C 点到 P 点的过程在中，经过 CP 路径衰减，我们用 <span
class="math inline">\(I_P\)</span> 指代 P 点的光强</li>
<li><span class="math inline">\(I_P\)</span> 比 <span
class="math inline">\(I_C\)</span> 的值就是
<strong>透射率(Transimittance)</strong> :<span class="math inline">\(T
(CP) = \frac{I_P}{I_C}\)</span></li>
</ul>
<p>P 点的光强也就是: <span class="math display">\[I_P = I_C *
\textcolor{Green}{T(CP)}\]</span></p>
<p>其中，<strong>T项</strong>是<strong>衰减系数（Transmittance）</strong>，它表示在某段路径上的对光照的衰减程度。该公式也可以被认为是<strong>零级散射（zero
scattering）</strong>，即不考虑任何散射事件、直接考虑经过衰减后光强。</p>
<h3 id="散射函数sλθh">散射函数：S(λ,θ,h)</h3>
<p>P点在接受光照后，会因为散射偏转一部分，于是我们需要散射函数 <span
class="math inline">\(S(\lambda,\theta,h)\)</span>
来表示某一方向上光线的偏转情况。如下图，那些偏转了 <span
class="math inline">\(\theta\)</span> 角的光线才能被指向A点的摄像机:</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/scattering_06a.png" width="50%" height="50%" /></p>
</div>
<p>于是我们可以得出从 P 点出发到 A 点的光强：</p>
<p><span
class="math display">\[I_{PA}=\boxed{I_P}\textcolor{DarkRed}{S(\lambda,\theta,h)}
\textcolor{Green}{T(PA)} \]</span></p>
<p>从公式中可以看出，散射跟角度 <span
class="math inline">\(\theta\)</span>、光线波长 <span
class="math inline">\(\lambda\)</span> 以及 <span
class="math inline">\(P\)</span> 点高度 <span
class="math inline">\(h\)</span> 有关系。</p>
<h3 id="散射-1">散射</h3>
<p>散射系数和粒子的大小和折射率有关，这里就得解释一下大气粒子的分类。我们知道大气中有很多不同种类的大气分子/粒子，一般在大气渲染模型里把它们分成两大类。一种是小分子，例如氮气和氧气分子等，另一种是大粒子，例如各种尘埃粒子。之所以要进行分类是因为它们对光线有着不一样的行为（这里忽略对光的吸收，只考虑散射）：</p>
<ul>
<li>小分子：指大小远小于光线波长的粒子。小分子对光的散射在前后方向上分布比较均匀，通常会使用
<strong>Rayleigh散射（Rayleigh Scattering）</strong>
对它们进行建模。由于这些分子大小比波长还要小很多，因此光的<strong>波长</strong>也会影响
Rayleigh 散射的程度。</li>
<li>大粒子：指大小远大于光线波长的粒子。大粒子在发生散射的时候会把更多的光散射到前向，通常会使用
<strong>Mie散射（Mie Scattering）</strong>
对它们进行建模。由于光的波长相较于这些粒子大小来说是可以忽略的，因此我们认为
Mie 散射跟光线<strong>波长无关</strong>。</li>
</ul>
<h4 id="rayleigh-散射">Rayleigh 散射</h4>
<p>对于足够小的粒子，光线在撞击它后会经历什么？我们通常使用瑞利散射来建模。</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/scattering_9.png" width="50%" height="50%" /></p>
</div>
<p>Rayleigh 散射曲线图如下：</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/rayleigh.svg" width="50%" height="50%" /></p>
</div>
<p>散射函数如下，这个方程并不是真正的Rayleigh散射方程，你去维基百科里面查，会发现另外一个公式，这个公式来自<a
href="http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf">这篇论文</a>：</p>
<p><span class="math display">\[\textcolor{DarkRed}{S(\lambda,\theta,h)}
=
\frac{\pi^2(n^2-1)^2}{2}\frac{\textcolor{Gold}{\rho(h)}}{N}\frac{1}{\lambda^4}(1+cos\theta^2)\]</span></p>
<p>其中，</p>
<ul>
<li><strong><span class="math inline">\(\lambda\)</span></strong>
是光的波长</li>
<li><strong><span class="math inline">\(n=1.00029\)</span></strong>
是粒子折射率</li>
<li><strong><span
class="math inline">\(N=2.504*10^{25}\)</span></strong>
是海平面处的大气密度，单位是 分子数/立方米</li>
<li><strong><span class="math inline">\(\rho(h)\)</span></strong> 是高度
<strong><span class="math inline">\(h\)</span></strong>
处的相对大气密度（即相对于海平面的密度，可以理解成 <strong><span
class="math inline">\(h\)</span></strong>
处真正的大气密度与海平面处大气密度的比值，因此它在海平面处值为 1，随着
<strong><span class="math inline">\(h\)</span></strong>
增加不断减小），我们一般会使用指数函数对它的真实曲线进行数学拟合（是一种近似拟合，不要和后面提到的指数函数弄混）：</li>
</ul>
<p><span
class="math display">\[\textcolor{Gold}{\rho(h)}=exp(-\frac{h}{H})\]</span></p>
<p>其中 <strong>H</strong> 为 <strong>“Scale
Height”</strong>，相当于是一个基准的高度。</p>
<ul>
<li>对于 Rayleigh 来说，<strong>H= 8500米</strong>。</li>
<li>对于 Mie 来说，<strong>H = 1200米</strong>。</li>
</ul>
<p>可以看出Rayleigh散射大致和波长的4次幂的成反比，波长越小（越靠近紫光）的光被散射得越厉害。所以白天的时候天空为蓝色，因为蓝光在大气里不断被散射，黄昏的时候天空会变红，因为相比于白天，阳光此时要穿越更厚得多的大气层，在到达人眼之前，大多数蓝光都被散射到其他方向，所以剩下来的就是红光了。</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/rayleigh_rgb.svg" width="80%" height="80%" /></p>
</div>
<h4 id="rayleigh-散射系数">Rayleigh 散射系数</h4>
<p>Rayleigh 散射的公式 <span
class="math inline">\(S(\lambda,\theta,h)\)</span>
表示在某个特定方向上的光强度，要求总散射系数就需要对散射函数做球面积分：</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/rayleigh_co.webp" width="30%" height="30%" /></p>
</div>
<blockquote>
<p>球面积分示意图，这里假定 r 等于 1，对球面积分时，因为 <span
class="math inline">\(d\theta\)</span> 跟 <span
class="math inline">\(d\phi\)</span>
非常小，因此球面可以看成是矩形，因此蓝色框长度为 <span
class="math inline">\(w=rsin\theta d\phi\)</span>
<strong>（弦长公式：蓝色面片上边缘半径 <span
class="math inline">\(rsin\theta\)</span>，角度 <span
class="math inline">\(d\phi\)</span>）</strong>，高为 <span
class="math inline">\(d\theta\)</span>，则面积 <span
class="math inline">\(S=rsin\theta d\phi d\theta\)</span></p>
</blockquote>
<p>因此：</p>
<p><span class="math display">\[\beta(\lambda, h) =
\int_{0}^{2\pi}{\int_{0}^{\pi}{S(\lambda,\theta,h)}sin\theta d\theta
d\phi}\]</span></p>
<p>最后得出：</p>
<p><span class="math display">\[\beta(\lambda, h) =
\frac{8\pi^3(n^2-1)^2}{3}\frac{\textcolor{Gold}{\rho(h)}}{N}\frac{1}{\lambda^4}\]</span></p>
<p>特别地，当 <span class="math inline">\(h=0\)</span>
时，即表示海平面的散射系数：</p>
<p><span class="math display">\[ \beta(\lambda, 0) =
\frac{8\pi^3(n^2-1)^2}{3} \frac{ \textcolor{Gold}{1} }{N}
\frac{1}{\lambda^4} \]</span></p>
<p>举例来说就，对于红绿蓝的波长，在海平面时，可以得出这些结果：</p>
<p><span class="math display">\[\begin{aligned}
\beta(\textcolor{Red}{680nm}) &amp;= 5.2*10^{-6} \\
\beta(\textcolor{Green}{550nm}) &amp;= 12.1*10^{-6} \\
\beta(\textcolor{Blue}{440nm}) &amp;= 29.6*10^{-6}
\end{aligned}\]</span></p>
<blockquote>
<p>有些博客跟论文里计算结果如下: <span
class="math inline">\(\beta_rrgb=(5.8, 13.5, 33.1) \cdot
10^{-6}\)</span>，<span
class="math inline">\(n=1.0003，N=2.545\cdot10^{25}\)</span></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 8*math.pi**3*(1.00029**2-1)**2/3.0/(2.504e25)/((680e-9)**4)</span><br><span class="line">5.196731735928312e-06</span><br><span class="line">&gt;&gt;&gt; 8*math.pi**3*(1.00029**2-1)**2/3.0/(2.504e25)/((550e-9)**4)</span><br><span class="line">1.2142697926864656e-05</span><br><span class="line">&gt;&gt;&gt; 8*math.pi**3*(1.00029**2-1)**2/3.0/(2.504e25)/((440e-9)**4)</span><br><span class="line">2.964525861050941e-05</span><br></pre></td></tr></table></figure>
<p>总散射系数公式也可以拆解为：</p>
<p><span class="math display">\[\beta(\lambda, h) =
\frac{8\pi^3(n^2-1)^2}{3}\frac{\textcolor{Gold}{\rho(h)}}{N}\frac{1}{\lambda^4}=\beta(\lambda)
\textcolor{Gold}{\rho(h)}\]</span></p>
<p>其中：</p>
<p><span class="math display">\[\beta(\lambda) =
\frac{8\pi^3(n^2-1)^2}{3}\frac{1}{N}\frac{1}{\lambda^4}\]</span></p>
<h4 id="rayleigh-相位函数">Rayleigh 相位函数</h4>
<p>Rayleigh
散射的原方程可以分解成两个分量，一个是上面的有关能量强度的散射系数，另一个分量则和它几何形状有关</p>
<p><span class="math display">\[S(\lambda,\theta,h)=\beta(\lambda,
h)\underbrace{\gamma(\theta)}_{geometry}\]</span></p>
<p><span class="math inline">\(\gamma(\theta)\)</span>
可以用前两者之比得到。</p>
<p><span class="math display">\[\begin{aligned}
\gamma(\theta) &amp;= \frac{S(\lambda,\theta,h)}{\beta(\lambda, h)}\\
&amp;=\frac{3}{16\pi}(1+cos^2\theta)
\end{aligned}\]</span></p>
<p>该表达式不依赖波长，<span
class="math inline">\(\gamma(\theta)\)</span>
的函数图像就是之前两瓣的偶极子形状</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/rayleigh.svg" width="50%" height="50%" /></p>
</div>
<blockquote>
<p>PS: 整个散射函数可以拆分成 <span
class="math inline">\(\textcolor{DarkRed}{S(\lambda,\theta,h)}=
\textcolor{DodgerBlue}{ \beta(\lambda)} \textcolor{Gold}{\rho(h)}
\textcolor{Purple}{\gamma(\theta)}\)</span></p>
</blockquote>
<h4 id="mie-散射">Mie 散射</h4>
<p>光线的散射是很复杂的，瑞利散射对原子和分子可以有效模拟，但是对光线和大物体（气溶胶）的交互没什么作用。地球大气布满了气溶胶，所以仅是瑞利散射是不足以复现的，为此常用的就是
<strong>米氏散射（Mie
scattering）</strong>，这种散射类型倾向于扩散光线，让光源看起来比实际大，但不会改变光的颜色</p>
<h4 id="mie-散射系数">Mie 散射系数</h4>
<p>米散射系数很难去推导计算，基于统计数据的结果，米散射系数可以常量进行估计。论文<a
href="#ref-anchor-10"><sup>10</sup></a>中给出海平面的米散射系数:</p>
<p><span
class="math display">\[\beta(\textcolor{Red}{680nm},\textcolor{Green}{550nm}
,
\textcolor{Blue}{440nm} = (2.2*10^{-5}, 2.2*10^{-5},
2.2*10^{-5})\]</span></p>
<h4 id="mie-散射相位函数">Mie 散射相位函数</h4>
<p>真实的 Mie 散射相位函数图像如下：</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/mie.png" width="60%" height="60%" /></p>
</div>
<p>因此 Mie 相位函数也是近似方式得出，我们可以利用Henyey-Greenstein
函数，该函数在1941年提出：</p>
<p><span
class="math display">\[\gamma_{HG}(\theta)=\frac{1}{4\pi}\frac{1-g^2}{(1+g^2-2gcos\theta)^\frac{3}{2}}\]</span></p>
<p>在 1992 年 Cornette 对其进行了改进：</p>
<p><span
class="math display">\[\gamma_{M}(\theta)=\frac{3}{8\pi}\frac{1-g^2}{(2+g^2)}\frac{1+cos^2\theta}{(1+g^2-2gcos\theta)^\frac{3}{2}}\]</span></p>
<p>该函数引入了一个参数 <span
class="math inline">\(g（-1＜g＜1）\)</span>，决定了前后散射的相对强度，代表散射方向的平均余弦。正的
<span class="math inline">\(g\)</span> 值会增加正向散射的光量，负的
<span class="math inline">\(g\)</span> 值表示向后散射的光量。 <span
class="math inline">\(g=0\)</span> 的值导致各向同性散射。</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/mie_g.png" width="60%" height="60%" /></p>
</div>
<p>对于地球大气层，一般可以取 <span
class="math inline">\(g=0.758\)</span>。然后由于上述两个函数计算成本比较高，快速应用可以使用
Schlick 相位函数：</p>
<p><span
class="math display">\[\lambda_S(\theta)=\frac{1}{4\pi}\frac{1-g^2}{(1+gcos\theta)^2}\]</span></p>
<h4 id="衰减系数-textcolorgreent">衰减系数 <span
class="math inline">\(\textcolor{Green}{T}\)</span></h4>
<p><span class="math inline">\(T(a,b)\)</span> 表示 <span
class="math inline">\(a,b\)</span>
之间的透射率（transmittance），其定义为<a
href="#ref-anchor-9"><sup>9</sup></a>：</p>
<p><span
class="math display">\[T(a,b)=exp(-\int_a^b\sigma_t(p)dl_p\]</span></p>
<p>其中 <span class="math inline">\(\sigma_t\)</span>
为介质衰减系数，</p>
<ul>
<li><p>Rayleigh 在大气中，Rayleigh 散射可以用 Rayleigh theory
近似描述：</p>
<p><span class="math inline">\(\sigma_RT(h,\lambda)=\beta(\lambda,
h)\)</span></p></li>
</ul>
<p>即：</p>
<p><span
class="math display">\[\textcolor{Green}{T(PA)}=exp\{-\int_P^A{\textcolor{DodgerBlue}{\beta(\lambda,
h)}}ds\}\]</span></p>
<p>带入之前求解的总散射系数公式： <span
class="math inline">\(\beta(\lambda,h)\)</span></p>
<p><span
class="math display">\[\textcolor{Green}{T(PA)}=exp\{-\textcolor{DodgerBlue}{\beta(\lambda)}\int_P^A{\textcolor{Gold}{\rho(h)}}ds\}\]</span></p>
<p>其中的积分项对应的是路径长度 <span
class="math inline">\(x\)</span>，可以理解为在光传播路径上，对大气密度函数
<span class="math inline">\(\textcolor{Gold}{\rho(h)}\)</span>
求积分，这部分被称为 <strong>光学距离——Optical Depth</strong>：</p>
<p><span
class="math display">\[\textcolor{Darkorange}{D(PA)}=\int_P^A{\textcolor{Gold}{\rho(h)}}ds\}\]</span></p>
<h3 id="总结">总结</h3>
<p>至此，我们简单推导了 <span class="math inline">\(S\)</span> 跟 <span
class="math inline">\(T\)</span>，这样一开始的公式可以写成：</p>
<p><span class="math display">\[\begin{aligned}
I_{PA} &amp;= \boxed{I_P}\textcolor{DarkRed}{S(\lambda,\theta,h)}
\underline {\textcolor{Green}{T(PA)} } \\
&amp;=\boxed{I_S\textcolor{Green}{T(CP)}}  \textcolor{DarkRed}{S(\lambda,\theta,h)}
\underline { \textcolor{Green}{T(PA)} } \\
&amp;= \boxed { I_S
\{exp\{-\textcolor{DodgerBlue}{\beta(\lambda)}\textcolor{Darkorange}{D(CP)}\}\}
}  \textcolor{DarkRed}{ \{ \textcolor{DodgerBlue}{
\beta(\lambda)}  \textcolor{Gold}{\rho(h)}  \textcolor{Purple}{\gamma(\theta)}
\} }  \underline {
\{exp\{-\textcolor{DodgerBlue}{\beta(\lambda)}\textcolor{Darkorange}{D(PA)}\}\}
}\\
&amp;= I_S \textcolor{DarkRed}{ \{
\textcolor{DodgerBlue}{\beta(\lambda)}
\textcolor{Gold}{\rho(h)}  \textcolor{Purple}{\gamma(\theta)}  \} }
\{exp\{  -\textcolor{DodgerBlue}{\beta(\lambda)}
\{  \textcolor{Darkorange}{D(CP)} + \textcolor{Darkorange}{D(PA)}   \}
\} \}
\end{aligned} \]</span></p>
<p>其中，一般情况下，太阳光照角度固定，可以看成是平行光，<span
class="math inline">\(\textcolor{Purple}{\gamma(\theta)}\)</span>
可以看成常量，<span
class="math inline">\(\textcolor{DodgerBlue}{\beta(\lambda)}\)</span>
也是常量，也就是海平面附近的散射系数，在 Shader 中作为输入即可，<span
class="math inline">\(\textcolor{Darkorange}{D(PA)}\)</span> 等在 Shader
中计算。</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/scattering_06a.png" width="50%" height="50%" /></p>
</div>
<p>总结起来，公式表示的含义就是，计算观察路径AB上某一点P的光照贡献：</p>
<ul>
<li>光线从太阳出发，到达大气边缘的C点</li>
<li>经过路径CP上的衰减到达P点（0级散射）</li>
<li>在P点发生一次散射，将一部分光散射到了观察方向上（1级散射）</li>
<li>这部分光又经过AP路径上的衰减最终到达了我们的眼睛</li>
</ul>
<h3 id="数值积分">数值积分</h3>
<p>P只是AB上的某一点，我们需要对路径AB上的每一点进行积分：</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/scattering_08c.png" width="50%" height="50%" /></p>
</div>
<p><span class="math display">\[\begin{aligned}
I_A &amp;= \sum_{i=0}^{n}I_{P_n} \\
&amp;= \int_{A}^{B} I_{PA} ds \\
&amp;= \int_{A}^{B} I_S \textcolor{DarkRed}{ \{
\textcolor{DodgerBlue}{\beta(\lambda)} \textcolor{Gold}{\rho(h)}
\textcolor{Purple}{\gamma(\theta)}  \} } \{
exp\{  -\textcolor{DodgerBlue}{\beta(\lambda)}
\{  \textcolor{Darkorange}{D(CP)} +
\textcolor{Darkorange}{D(PA)}   \}  \} \}  ds \\
&amp;= I_S \textcolor{DodgerBlue}{\beta(\lambda)}
\textcolor{Purple}{\gamma(\theta)}
\int_{A}^{B}  {exp\{  -\textcolor{DodgerBlue}{\beta(\lambda)}
\{  \textcolor{Darkorange}{D(CP)} + \textcolor{Darkorange}{D(PA)} } \}\}
\textcolor{Gold}{\rho(h)}  ds
\end{aligned} \]</span></p>
<blockquote>
<p>在大气shader中，我们将 <span class="math inline">\(AB\)</span>
分割成等长的若干段，然后取这些段的中点记为 <span
class="math inline">\(P_i\)</span>，然后分别计算每个点的 <span
class="math inline">\(I_{P_i}\)</span>，最后将这些点的光照累加起来。 ##
大气球体shader框架思路</p>
</blockquote>
<h3 id="光线与大气相交">光线与大气相交</h3>
<p>从之前得出的公式中可以得知，我们需要在 <span
class="math inline">\(AB\)</span> 路径上求光学距离，我们第一步需要求出
<span class="math inline">\(AB\)</span> 的长度：</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/shader_ab.png" width="50%" height="50%" /></p>
</div>
<p>如下图所示，灰色部分是大气，我们需要求出观察路径 <span
class="math inline">\(AB\)</span>，其中已知：</p>
<ul>
<li><span class="math inline">\(O\)</span>：相机位置</li>
<li><span class="math inline">\(C\)</span>：大气球心位置</li>
<li><span class="math inline">\(L\)</span>：相机到大气球心长度</li>
<li><span class="math inline">\(R\)</span>：大气球半径</li>
<li><span class="math inline">\(\vec{OD}\)</span>
：观察方向，单位向量</li>
</ul>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/shader_ab02.png" width="50%" height="50%" /></p>
</div>
<p>如图可以依次求出，</p>
<ul>
<li><span class="math inline">\(OT = \vec{OC} \cdot
\vec{OD}\)</span></li>
<li><span class="math inline">\(TC = \sqrt{L^2 - OC^2}\)</span></li>
<li><span class="math inline">\(AT = \sqrt{R^2 - TC^2}\)</span></li>
<li><span class="math inline">\(OA = OT-AT\)</span></li>
<li><span class="math inline">\(OB = OT+BT=OT+AT\)</span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RayIntersect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// Ray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    float3 O, <span class="comment">// Origin</span></span></span></span><br><span class="line"><span class="params"><span class="function">    float3 D, <span class="comment">// Direction</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// Sphere</span></span></span></span><br><span class="line"><span class="params"><span class="function">    float3 C, <span class="comment">// Centre</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> R,    <span class="comment">// Radius</span></span></span></span><br><span class="line"><span class="params"><span class="function">    out <span class="type">float</span> AO, <span class="comment">// First intersection time</span></span></span></span><br><span class="line"><span class="params"><span class="function">    out <span class="type">float</span> BO  <span class="comment">// Second intersection time</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float3 L = C - O;</span><br><span class="line">    <span class="type">float</span> DT = <span class="built_in">dot</span> (L, D);</span><br><span class="line">    <span class="type">float</span> R2 = R * R;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> CT2 = <span class="built_in">dot</span>(L,L) - DT*DT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CT 长度超过了求半径 R，此时视线跟大气不相交</span></span><br><span class="line">    <span class="comment">// Intersection point outside the circle</span></span><br><span class="line">    <span class="keyword">if</span> (CT2 &gt; R2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> AT = <span class="built_in">sqrt</span>(R2 - CT2);</span><br><span class="line">    <span class="type">float</span> BT = AT;</span><br><span class="line"></span><br><span class="line">    AO = DT - AT;</span><br><span class="line">    BO = DT + BT;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="光线与行星相交">光线与行星相交</h3>
<p>视线有可能会被行星阻挡，因此需要做两次相交函数，一次判断大气，一次判断行星。</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/shader_ab03.png" width="50%" height="50%" /></p>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Intersections with the atmospheric sphere</span></span><br><span class="line"><span class="comment">//     D    : 观察方向向量</span></span><br><span class="line"><span class="comment">// worldPos : 相机坐标 </span></span><br><span class="line"><span class="type">float</span> tA;    <span class="comment">// Atmosphere entry point (worldPos + D * tA)</span></span><br><span class="line"><span class="type">float</span> tB;    <span class="comment">// Atmosphere exit point  (worldPos + D * tB)</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">RayIntersect</span>(O, D, _PlanetCentre, _AtmosphereRadius, tA, tB))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fixed4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// The view rays is looking into deep space</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Is the ray passing through the planet core?</span></span><br><span class="line"><span class="type">float</span> pA, pB;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RayIntersect</span>(O, D, _PlanetCentre, _PlanetRadius, pA, pB))</span><br><span class="line">    tB = pA;</span><br></pre></td></tr></table></figure>
<h3 id="采样视线">采样视线</h3>
<p>之前我们得到了 <span class="math inline">\(AB\)</span> 路径上每个点
<span class="math inline">\(P\)</span> 的光照公式：</p>
<p><span class="math display">\[\begin{aligned}
I_A &amp;= I_S \textcolor{DodgerBlue}{\beta(\lambda)}
\textcolor{Purple}{\gamma(\theta)}
\int_{A}^{B}  {exp\{  -\textcolor{DodgerBlue}{\beta(\lambda)}
\{  \textcolor{Darkorange}{D(CP)} + \textcolor{Darkorange}{D(PA)} } \}\}
\textcolor{Gold}{\rho(h)}  ds \\
&amp;= I_S \textcolor{DodgerBlue}{\beta(\lambda)}
\textcolor{Purple}{\gamma(\theta)} \sum_{P \in AB}
\textcolor{Green}{T(CP)} \textcolor{Green}{T(PA)}
\textcolor{Gold}{\rho(h)}  ds
\end{aligned}\]</span></p>
<p>线段上有无数个 <span class="math inline">\(P\)</span>
点，为了近似求解 <span
class="math inline">\(I\)</span>，我们需要把线段划分为数个长度为 <span
class="math inline">\(ds\)</span> 的小段</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/shader_ab.png" width="50%" height="50%" /></p>
</div>
<p><span class="math inline">\(AB\)</span>
被划分的段数，就是视线采样数（View Samples），在 Shader
可以这么处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Numerical integration to calculate</span></span><br><span class="line"><span class="comment">// the light contribution of each point P in AB</span></span><br><span class="line">float3 totalViewSamples = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> time = tA;</span><br><span class="line"><span class="type">float</span> ds = (tB - tA) / (<span class="type">float</span>)(_ViewSamples);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _ViewSamples; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Point position</span></span><br><span class="line">    <span class="comment">// (sampling in the middle of the view sample segment)</span></span><br><span class="line">    <span class="comment">// O : 相机位置</span></span><br><span class="line">    <span class="comment">// D : 相机方向向量</span></span><br><span class="line">    float3 P = O + D * (time + ds * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T(CP) * T(PA) * ρ(h) * ds</span></span><br><span class="line">    totalViewSamples += <span class="built_in">ViewSampling</span>(P, ds);</span><br><span class="line"></span><br><span class="line">    time += ds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I = I_S * β(λ) * γ(θ) * totalViewSamples</span></span><br><span class="line">float3 I = _SunIntensity *  _ScatteringCoefficient * phase * totalViewSamples;</span><br></pre></td></tr></table></figure>
<p>接下来就是求解每个 <span class="math inline">\(P\)</span> 点上的
<span class="math inline">\(\textcolor{Green}{T(CP)}
\textcolor{Green}{T(PA)} \textcolor{Gold}{\rho(h)}ds\)</span></p>
<h3 id="光学深度-pa">光学深度 <span
class="math inline">\(PA\)</span></h3>
<p>回顾一下之前的公式：</p>
<p><span class="math display">\[ \textcolor{Green}{T(CP)}
\textcolor{Green}{T(PA)} =
exp\{  -\textcolor{DodgerBlue}{\beta(\lambda)}
\{  \textcolor{Darkorange}{D(CP)} + \textcolor{Darkorange}{D(PA)}  \}
\}\]</span></p>
<p>其中:</p>
<p><span class="math display">\[\textcolor{Darkorange}{D(PA)}=\sum_{Q
\in PA} exp \{ -\frac{h_Q}{H} \}ds\]</span></p>
<p><span class="math inline">\(h_Q\)</span> 表示当前点的高度，有一点注意
<span
class="math inline">\(\textcolor{Gold}{\rho(h)}=exp(-\frac{h_Q}{H})\)</span>，这里顺便可以求解
<span class="math inline">\(AB\)</span> 上的积分 <span
class="math inline">\(\textcolor{Gold}{\rho(h)}ds\)</span>。</p>
<p>Shader 实现如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// + Accumulator for the optical depth</span></span><br><span class="line"><span class="type">float</span> opticalDepthPA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">float3 totalViewSamples = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> time = tA;</span><br><span class="line"><span class="type">float</span> ds = (tB - tA) / (<span class="type">float</span>)(_ViewSamples);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _ViewSamples; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    float3 P = O + D * (time + ds * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////// Begin ViewSampling()</span></span><br><span class="line">    <span class="comment">// T(CP) * T(PA) * ρ(h) * ds</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1: ρ(h) * ds</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//            C : 行星球形坐标</span></span><br><span class="line">    <span class="comment">// _ScaleHeight : Rayleigh/Mie 散射里的基准高度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> height = <span class="built_in">distance</span>(C, P) - _PlanetRadius;</span><br><span class="line">    <span class="type">float</span> opticalDepthSegment = <span class="built_in">exp</span>(-height / _ScaleHeight) * ds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2: D(PA)</span></span><br><span class="line">    opticalDepthPA += opticalDepthSegment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////    End ViewSampling()</span></span><br><span class="line"></span><br><span class="line">    time += ds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I = I_S * β(λ) * γ(θ) * totalViewSamples</span></span><br><span class="line">float3 I = _SunIntensity *  _ScatteringCoefficient * phase * totalViewSamples;</span><br></pre></td></tr></table></figure>
<h3 id="光学深度-cp">光学深度 <span
class="math inline">\(CP\)</span></h3>
<p>累加符号里 <span class="math inline">\(P\)</span> 点的光量贡献还剩下
<span class="math inline">\(CP\)</span> 的光学深度，我们在求 <span
class="math inline">\(CP\)</span> 的光学深度时，建立一个 LightSampling
方法，也就从 <span class="math inline">\(P\)</span>
点出发指向太阳进行采样，把太阳的出射点叫做 <span
class="math inline">\(C\)</span> （注意跟之前的球心坐标 <span
class="math inline">\(C\)</span> 区分），然后注意下面 <span
class="math inline">\(C_0\)</span> 的情况，光线被星球遮挡，此时要忽略
<span class="math inline">\(P_0\)</span> 点的贡献。</p>
<div data-align="center">
<p><img src="/images/atmosphere_scatter/shader_ab04.png" width="50%" height="50%" /></p>
</div>
<p>Shader 实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LightSampling</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    float3 P,    <span class="comment">// Current point within the atmospheric sphere</span></span></span></span><br><span class="line"><span class="params"><span class="function">    float3 S,    <span class="comment">// S 是光照方向，从 P 点到 C 点的平行光</span></span></span></span><br><span class="line"><span class="params"><span class="function">    out <span class="type">float</span> opticalDepthCA</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> _; <span class="comment">// don&#x27;t care about this one</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里 C 是局部变量，表示光线在大气表面的入射点</span></span><br><span class="line">    <span class="type">float</span> C;</span><br><span class="line">    <span class="built_in">RayInstersect</span>(P, S, _PlanetCentre, _AtmosphereRadius, _, C);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Samples on the segment PC</span></span><br><span class="line">    <span class="comment">// _LightSamples : CP 上的分段次数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> ds = <span class="built_in">distance</span>(P, P + S * C) / (<span class="type">float</span>)(_LightSamples);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _LightSamples; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Q 点如上图所示</span></span><br><span class="line">        <span class="comment">// S : 光照方向</span></span><br><span class="line">        float3 Q = P + S * (time + lightSampleSize * <span class="number">0.5</span>);</span><br><span class="line">        <span class="type">float</span> height = <span class="built_in">distance</span>(_PlanetCentre, Q) - _PlanetRadius;</span><br><span class="line">        <span class="comment">// Inside the planet</span></span><br><span class="line">        <span class="keyword">if</span> (height &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optical depth for the light ray</span></span><br><span class="line">        opticalDepthCA += <span class="built_in">exp</span>(-height / _RayScaleHeight) * ds;</span><br><span class="line"></span><br><span class="line">        time += ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后之前的代码加入 <span class="math inline">\(CP\)</span>
的计算如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> opticalDepthPA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">float3 totalViewSamples = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> time = tA;</span><br><span class="line"><span class="type">float</span> ds = (tB - tA) / (<span class="type">float</span>)(_ViewSamples);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _ViewSamples; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    float3 P = O + D * (time + ds * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////// Begin ViewSampling()</span></span><br><span class="line">    <span class="comment">// T(CP) * T(PA) * ρ(h) * ds</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ρ(h) * ds</span></span><br><span class="line">    <span class="type">float</span> height = <span class="built_in">distance</span>(C, P) - _PlanetRadius;</span><br><span class="line">    <span class="type">float</span> opticalDepthSegment = <span class="built_in">exp</span>(-height / _ScaleHeight) * ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// D(PA)</span></span><br><span class="line">    opticalDepthPA += opticalDepthSegment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// D(CP)</span></span><br><span class="line">    <span class="type">float</span> opticalDepthCP = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> overground = <span class="built_in">LightSampling</span>(P, S, opticalDepthCP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (overground)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Combined transmittance</span></span><br><span class="line">        <span class="comment">// T(CP) * T(PA) = T(CPA) = exp&#123; -β(λ) [D(CP) + D(PA)]&#125;</span></span><br><span class="line">        float3 transmittance = <span class="built_in">exp</span>(</span><br><span class="line">            -_ScatteringCoefficient *</span><br><span class="line">            (opticalDepthCP + opticalDepthPA)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Light contribution</span></span><br><span class="line">        <span class="comment">// T(CPA) * ρ(h) * ds</span></span><br><span class="line">        totalViewSamples += transmittance * opticalDepthSegment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////    End ViewSampling()</span></span><br><span class="line"></span><br><span class="line">    time += ds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I = I_S * β(λ) * γ(θ) * totalViewSamples</span></span><br><span class="line">float3 I = _SunIntensity *  _ScatteringCoefficient * phase * totalViewSamples;</span><br></pre></td></tr></table></figure>
<h3 id="散射系数">散射系数</h3>
<p>之前我们重点以 Rayleigh 散射来介绍如何计算单次大气散射，接下来加上
Mie 散射，之前的方程：</p>
<p><span class="math display">\[\begin{aligned}
I &amp;= I_S \textcolor{DodgerBlue}{\beta(\lambda)}
\textcolor{Purple}{\gamma(\theta)} \sum_{P \in AB} L(P) \\
\end{aligned}\]</span></p>
<p>加上 Mie 反射后：</p>
<p><span class="math display">\[\begin{aligned}
I &amp;= \overbrace{ I_S \textcolor{DodgerBlue}{\beta_R(\lambda)}
\textcolor{Purple}{\gamma_R(\theta)} \sum_{P \in AB} L_R(P) }^{Rayleigh
\  Scattering} + \overbrace{ I_S
\textcolor{DodgerBlue}{\beta_M(\lambda)}
\textcolor{Purple}{\gamma_M(\theta)} \sum_{P \in AB} L_M(P) }^{Mie \
Scattering} \\
&amp;=I_S \left( \overbrace{ \textcolor{DodgerBlue}{\beta_R(\lambda)}
\textcolor{Purple}{\gamma_R(\theta)} \sum_{P \in AB} L_R(P) }^{Rayleigh
\  Scattering} + \overbrace{ \textcolor{DodgerBlue}{\beta_M(\lambda)}
\textcolor{Purple}{\gamma_M(\theta)} \sum_{P \in AB} L_M(P) }^{Mie \
Scattering} \right)
\end{aligned}\]</span></p>
<p>因此代码实现也需要做修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LightSampling</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    float3 P,</span></span></span><br><span class="line"><span class="params"><span class="function">    float3 S,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// Modify : float -&gt;  float2  </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 分别计算光学深度 .xy  -&gt;  Rayleight Mie</span></span></span></span><br><span class="line"><span class="params"><span class="function">    out float2 opticalDepthCA</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> _;</span><br><span class="line">    <span class="type">float</span> C;</span><br><span class="line">    <span class="built_in">RayInstersect</span>(P, S, _PlanetCentre, _AtmosphereRadius, _, C);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> ds = <span class="built_in">distance</span>(P, P + S * C) / (<span class="type">float</span>)(_LightSamples);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _LightSamples; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        float3 Q = P + S * (time + lightSampleSize * <span class="number">0.5</span>);</span><br><span class="line">        <span class="type">float</span> height = <span class="built_in">distance</span>(_PlanetCentre, Q) - _PlanetRadius;</span><br><span class="line">        <span class="keyword">if</span> (height &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别计算 Rayleigh、Mie 的光学深度，基准的高度值不一样</span></span><br><span class="line">        opticalDepthCA.x += <span class="built_in">exp</span>(-height / _RayScaleHeight.x) * ds;</span><br><span class="line">        opticalDepthCA.y += <span class="built_in">exp</span>(-height / _RayScaleHeight.y) * ds;</span><br><span class="line"></span><br><span class="line">        time += ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Modify : float -&gt; float2</span></span><br><span class="line">float2 opticalDepthPA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">float3 totalRayViewSamples = <span class="number">0</span>;</span><br><span class="line">float3 totalMieViewSamples = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> time = tA;</span><br><span class="line"><span class="type">float</span> ds = (tB - tA) / (<span class="type">float</span>)(_ViewSamples);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _ViewSamples; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    float3 P = O + D * (time + ds * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////// Begin ViewSampling()</span></span><br><span class="line">    <span class="comment">// T(CP) * T(PA) * ρ(h) * ds</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ρ(h) * ds</span></span><br><span class="line">    <span class="type">float</span> height = <span class="built_in">distance</span>(C, P) - _PlanetRadius;</span><br><span class="line">    <span class="comment">// float -&gt; float2</span></span><br><span class="line">    float2 opticalDepthSegment = <span class="number">0</span>;</span><br><span class="line">    opticalDepthSegment.x = <span class="built_in">exp</span>(-height / _ScaleHeight.x) * ds;</span><br><span class="line">    opticalDepthSegment.y = <span class="built_in">exp</span>(-height / _ScaleHeight.y) * ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// D(PA)</span></span><br><span class="line">    opticalDepthPA += opticalDepthSegment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// D(CP)</span></span><br><span class="line">    <span class="comment">// Modify : float -&gt; float2</span></span><br><span class="line">    float2 opticalDepthCP = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> overground = <span class="built_in">LightSampling</span>(P, S, opticalDepthCP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (overground)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Combined transmittance</span></span><br><span class="line">        <span class="comment">// T(CP) * T(PA) = T(CPA) = exp&#123; -β(λ) [D(CP) + D(PA)]&#125;</span></span><br><span class="line">        float3 transmittanceRay = <span class="built_in">exp</span>(</span><br><span class="line">            -_RayScatteringCoefficient  *</span><br><span class="line">            (opticalDepthCP.x + opticalDepthPA.x)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        float3 transmittranceMie = <span class="built_in">exp</span>(</span><br><span class="line">            -_MieScatteringCoefficient  *</span><br><span class="line">            (opticalDepthCP.x + opticalDepthPA.y)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Light contribution</span></span><br><span class="line">        <span class="comment">// T(CPA) * ρ(h) * ds</span></span><br><span class="line">        totalRayViewSamples  += transmittanceRay * opticalDepthSegment;</span><br><span class="line">        totalMieViewSamples  += transmittanceMie * opticalDepthSegment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////    End ViewSampling()</span></span><br><span class="line"></span><br><span class="line">    time += ds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I = I_S [βr(λ) * γr(θ) * totalRayViewSamples</span></span><br><span class="line"><span class="comment">//     + βm(λ) * γm(θ) * totalMieViewSamples)</span></span><br><span class="line">float3 I = _SunIntensity * (</span><br><span class="line"> _RayScatteringCoefficient * rayPhase * totalRayViewSamples +</span><br><span class="line"> _MieScatteringCoefficient * miePhase * totalMieViewSamples</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span
class="math inline">\(\_RayScatteringCoefficient(\textcolor{Red}{680nm},\textcolor{Green}{550nm},\textcolor{Blue}{440nm})
= (5.8, 13.5, 33.1)*10^{-6}\)</span> <span
class="math inline">\(\_MieScatteringCoefficient(\textcolor{Red}{680nm},\textcolor{Green}{550nm},\textcolor{Blue}{440nm}=(2.2,
2.2, 2.2)*10^{-5}\)</span></p>
</blockquote>
<blockquote>
<p><span class="math inline">\(rayPhase\)</span>、<span
class="math inline">\(miePhase\)</span>
提前计算好的相位函数值，如果光源会改变方向，可以在 Shader
中增加函数来计算数值。 <span class="math inline">\(\_ScaleHeight=(8500,
1200)\)</span></p>
</blockquote>
<!-- ## 简化版本实现 -->
<h2 id="参考资料">参考资料</h2>
<p><a
href="https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/">1.Volumetric
Atmospheric Scattering</a></p>
<p><a
href="https://blog.csdn.net/weixin_43803133/article/details/116354462">2.Unity基于体绘制的大气散射shader</a></p>
<p><a
href="https://zhuanlan.zhihu.com/p/237502022">3.【实战】从零实现一套完整单次大气散射</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/36498679">4.基于物理的大气渲染
-- 冯乐乐</a></p>
<p><a
href="http://igorsklyar.com/main/development_description/26?locale=en">5.Extended
Disney "principled" Shader</a></p>
<p><a
href="https://github.com/SlightlyMad/AtmosphericScattering">6.Atmospheric
Scattering for Unity 5</a></p>
<p><a href="https://sebh.github.io/publications/">7.Sébastien Hillaire
Website</a></p>
<p><a
href="https://freehyan.github.io/2020/03/05/sky-rendering-1/">8.基于物理的大气散射</a></p>
<div id="ref-anchor-9">

</div>
<p><a
href="https://zhuanlan.zhihu.com/p/383020796">9.预计算大气散射模型：原理与实现</a></p>
<div id="ref-anchor-10">

</div>
<p><a
href="https://hal.inria.fr/inria-00288758/file/article.pdf">10.Precomputed
Atmospheric Scattering</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Graphics</category>
      </categories>
      <tags>
        <tag>Atmosphere</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次使用Github + Hexo搭建博客</title>
    <url>/post/568ad23c/</url>
    <content><![CDATA[<p>偶然看到一个大神的文章，讲到怎么使用GitHub跟Hexo搭建博客，便依照大神给的方法尝试了一遍，便有了今天这个博客。大神的<a
href="https://imzlp.com/posts/58952/">博客链接</a></p>
<p>环境: Win10</p>
<h2 id="前期准备">前期准备</h2>
<h3 id="安装必要工具">安装必要工具</h3>
<ul>
<li>node.js</li>
<li>git</li>
<li>github账号</li>
</ul>
<h3 id="创建自己的github.io">创建自己的github.io</h3>
<p>登录你注册号的github账号，在账户下创建一个特殊的仓库(repo)，命名是固定的:your_github_id.github.io</p>
<span id="more"></span>
<h3 id="生成公私钥">生成公私钥</h3>
<p>安装好Git软件后，在cmd命令行中生成SSH keys。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;emain_address@youremail.com&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (C:\Users\your_user_directory/.ssh/id_rsa)::</span><br></pre></td></tr></table></figure>
<p>然后系统会要求你输入秘钥名字，按回车就好，接着按照提示输入密码即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> C:\Users\your_user_directory/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> C:\Users\your_user_directory/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:UWMR/4HrfxACapJAMSyi2aCBcsvsAU1VDw1TBtwmE8c emain_address@youremail.com</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|      .+*.+ .oo. |</span></span><br><span class="line"><span class="string">|       . * ..o.  |</span></span><br><span class="line"><span class="string">|        o oE +o  |</span></span><br><span class="line"><span class="string">|        oo+.+.o  |</span></span><br><span class="line"><span class="string">|       oS= =.. . |</span></span><br><span class="line"><span class="string">|      o B o     .|</span></span><br><span class="line"><span class="string">|       * o. ..  +|</span></span><br><span class="line"><span class="string">|      . .. ...oo+|</span></span><br><span class="line"><span class="string">|        .. .o===B|</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure>
<h3 id="配置ssh-key到github">配置SSH Key到GitHub</h3>
<ul>
<li>打开本地
**C:_user_directory/.ssh/id_rsa.pub**文件，复制文件里的公钥内容。</li>
<li>登录github系统，点击页面上 左上角个人图标 -&gt; Settings -&gt; SSH
keys -&gt; ADD SSH Key</li>
<li>把刚刚复制的密钥复制到Key文本框中，点击add key就ok了</li>
</ul>
<p>测试密钥是否能访问(当前目录下的密钥文件：blog_ssh)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i blog_ssh git@github.com</span><br></pre></td></tr></table></figure>
<p>如果密钥设置了密码访问，则按照提示输入密码，出现以下提示表示访问成功了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:\Blog\blog\doc&gt;ssh -i blog git@github.com</span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;blog&#x27;</span>:</span><br><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi your_github_id! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">Connection to github.com closed.</span></span><br></pre></td></tr></table></figure>
<h2 id="hexo使用">Hexo使用</h2>
<h3 id="安装hexo">安装Hexo</h3>
<p>在你要创建博客的目录下，鼠标右键，打开 gitbash</p>
<p><img src="/images/hello_world/git_bash.png" width=25% height=25% /></p>
<p>在打开的MINGW64窗口输入以下指令安装Hexo(先安装了node.js才能使用npm指令)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<h3 id="部署hexo">部署Hexo</h3>
<p>新建一个Blog文件夹，然后在该文件夹打开Git Bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>Hexo会在这个目录下自动创建建立博客网站需要的文件。
然后我们可以通过执行下面指令，预览本地博客，本地地址：<strong>localhost:4000</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>设置部署到Github前，需要先安装部署插件 hexo-deployer-git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>修改Blog根目录下的_cofig.yml配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:qq317423892/qq317423892.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>执行后就可以使用下列指令部署，注意部署会覆盖你之前在版本库中存放的文件，如果有文件不想被覆盖，可以放到Blog/source目录例如:Blog/source/CNAME</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>或者使用组合命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hexo clean 清理生成的文件 hexo g 或者 hexo generate 可以生成网站文件
hexo s 或者 hexo server 可以启动本地服务器</p>
</blockquote>
<p>注意在gitbash中部署时，要手动添加密钥，可以使用下面指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动ssh服务</span></span><br><span class="line"><span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加ssh文件: c:\Users\your_user_name\.ssh\blog_ssh</span></span><br><span class="line">ssh-add /c/Users/your_use_name/.ssh/blog_ssh </span><br></pre></td></tr></table></figure>
<h3 id="更换主题next">更换主题NexT</h3>
<p>在blog目录下拉取Next主题资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>打开blog跟目录配置文件：_cofig.yml，找到theme选项，改成next</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>由于Hexo在5.0版本把swig给删除了，需要自己手动安装:hexo-renderer-swig</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-swig</span><br></pre></td></tr></table></figure>
<p>即可解决下面的渲染报错
<img src="/images/hello_world/next_theme_err.png" width=100% height=100% /></p>
<h3 id="站点概况">站点概况</h3>
<p><img src="/images/hello_world/site_info.png" width=30% height=30% /></p>
<p>这里对应根目录下的配置文件：_config.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 十三的blog</span><br><span class="line">subtitle: &#x27;安心学技术&#x27;</span><br><span class="line">description: </span><br><span class="line">keywords: &quot;Unity, UE4&quot;</span><br><span class="line">author: 小贤</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/images/hello_world/site_info_avatar.png" width=30% height=30% /></p>
<p>这里对应的是next目录下的配置文件:_config.yml 显示头像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.gif</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure>
<p>显示名字跟描述：在next目录下的配置文件中手动添加下面两行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">author: 小贤</span><br><span class="line">description: Watch and learn, your magic is mine!</span><br></pre></td></tr></table></figure>
<h3 id="新增目录">新增目录</h3>
<p>侧边栏的目录项配置在next主题下的配置文件：_config.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home</span><br><span class="line">  about: /about/|| user</span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>
<p>可以通过下面的指令增加对应的目录，配置文件中的 ||
前面不要留空格，否则标签页访问会失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="新建文章">新建文章</h3>
<p>新增文章用下面的指令，会在默认的文件夹下新增文章（默认的是:blog/source/_posts），打开对应的路径，可以看到新增的md文件，编辑文章就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;test_article&quot;</span></span><br></pre></td></tr></table></figure>
<p>打开md文件，可以设置文章的分类跟标签Tag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Test</span><br><span class="line">date: 2021-03-25 12:52:30</span><br><span class="line">tags: [Unity, C#, InjectFix]</span><br><span class="line">categories: Unity开发</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="设置文章字数">设置文章字数</h3>
<p>先安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure>
<p>打开next主题下的配置文件:_config.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true </span><br><span class="line">  totalcount: true</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wordcount:显示字数 min2read: 显示阅读时长 totalcount：博客总字数</p>
</blockquote>
<h3 id="设置文章分割全部显示">设置文章分割（全部显示）</h3>
<p>推荐自己在文章中插入:<font color=DarkRed><strong>&lt;!-- more
--&gt;</strong> </font> ，也可以设置 auto_excerpt，length 表示字数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Automatically Excerpt. Not recommend.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>
<h3 id="站内搜索">站内搜索</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
<h3 id="plantuml">plantUML</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-plantuml</span><br></pre></td></tr></table></figure>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">title Relationships - Class Diagram</span><br><span class="line"></span><br><span class="line">class Dwelling &#123;</span><br><span class="line">  +Int Windows</span><br><span class="line">  +void LockTheDoor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apartment</span><br><span class="line">class House</span><br><span class="line">class Commune</span><br><span class="line">class Window</span><br><span class="line">class Door</span><br><span class="line"></span><br><span class="line">Dwelling &lt;|-down- Apartment: Inheritance</span><br><span class="line">Dwelling &lt;|-down- Commune: Inheritance</span><br><span class="line">Dwelling &lt;|-down- House: Inheritance</span><br><span class="line">Dwelling &quot;1&quot; <span class="emphasis">*-up- &quot;many&quot; Window: Composition</span></span><br><span class="line"><span class="emphasis">Dwelling &quot;1&quot; *</span>-up- &quot;many&quot; Door: Composition</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下： <img  src=http://www.plantuml.com/plantuml/svg/XP0z2y8m48Rt_8gZanzaS2qkKWSBJY8uXpQqXybTQ5ABgF_TrhQAuCUMbpptt4V0O3Jij541cNo9peE4n2ZlOOsgg9GL8kjZeur1Ak0Y0EOf1JWWvTpuBfuOSzXoTjoNUirSJQRYDXQkdAg2rHI6lE7Qw-6TiBKrZQaNZlrQZH3FhikhRFz8ldGnf5Jg2eEYJ7y01_S_x37E5oXQH32JjPCGMKNdQ9WmxjoEFNP7-q5tAxonTm00></p>
<h3 id="不算子统计访问量">不算子统计访问量</h3>
<p>打开 _config.yml，搜索找到 busuanzi_count，把 enable 设置为
true，并增加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Show</span> <span class="variable constant_">PV</span>/<span class="variable constant_">UV</span> <span class="keyword">of</span> the website/page <span class="keyword">with</span> busuanzi.</span><br><span class="line"># <span class="title class_">Get</span> more information on <span class="attr">http</span>:<span class="comment">//ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="attr">busuanzi_count</span>:</span><br><span class="line">  # count values only <span class="keyword">if</span> the other configs are <span class="literal">false</span></span><br><span class="line">  <span class="attr">enable</span>: <span class="literal">true</span> </span><br><span class="line">  <span class="attr">total_visitors</span>: <span class="literal">true</span>  # 统计访客数</span><br><span class="line">  <span class="attr">total_visitors_icon</span>: user</span><br><span class="line">  <span class="attr">total_views</span>: <span class="literal">true</span>     # 统计访问数</span><br><span class="line">  <span class="attr">total_views_icon</span>: eye</span><br><span class="line">  <span class="attr">post_views</span>: <span class="literal">true</span>      # 统计文章阅读数</span><br><span class="line">  <span class="attr">post_views_icon</span>: eye</span><br></pre></td></tr></table></figure>
<p>在该文件中找到 footer，并在该配置下增加 counter，设置值为 true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">counter</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>来到
themes_partials，找到footer.swig文件，打开编辑，在底下添加代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.<span class="property">footer</span>.<span class="property">counter</span> %&#125;</span><br><span class="line">    &lt;script <span class="keyword">async</span> src=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：（ps 本地测试数字会很大，可以忽视）</p>
<p><img src="/images/hello_world/busuanzi.png" width=70% height=70% /></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客完美支持数学公式</title>
    <url>/post/367fa45b/</url>
    <content><![CDATA[<p>我的博客现在使用的是 NexT
8.10，按照网上的攻略尝试了几种方法，都不是非常好，最终是通过 <a
href="https://theme-next.js.org/pisces/docs/third-party-services/math-equations.html"><font color=DarkBlue>官方文档</font></a>，使用了
<a href="https://pandoc.org/installing.html">pandoc</a>
来显示数学公式。</p>
<h2 id="安装hexo-renderer-pandoc">安装hexo-renderer-pandoc</h2>
<p>为了使用 pandoc 作为 Hexo 的渲染引擎，我们需要安装插件
hexo-renderer-pandoc，步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载Hexo默认渲染插件：</span></span><br><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装pandoc渲染插件：</span></span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
<h2 id="配置使用-mathjax">配置使用 mathjax</h2>
<p>在站点 NexT 配置文件 <font color=DarkRed>_config.yml</font>
文件中添加如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Next v6.3.0 后的版本 tags 要设置成 ams</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">ams</span></span><br></pre></td></tr></table></figure>
<h2 id="安装-pandoc-软件包">安装 pandoc 软件包</h2>
<p>从 <a href="https://pandoc.org/installing.html">pandoc</a>
官网下载所需要的软件包，我这里使用的 Windows10 + GitBash
方式，因此我下载了 Windows 安装包，<font color=DarkRed>
安装完毕后，记得重新打开 GitBash 命令框 </font>，不然执行
<font color=DarkRed> <strong>Hexo g</strong> </font> 会报错。</p>
<p>完成后，执行命令，既可以完美显示公式了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<!-- ## 小提示

在文本中使用公式时，前面的 $ 后面不要跟空格，后面的 $ 之前也不要有空格，不然显示有问题。$ a = 1 $

```c++
这里有个公式 $\eqref{eq1}$。
``` -->
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用 Zeit 托管网页实现百度抓取</title>
    <url>/post/5bf5a952/</url>
    <content><![CDATA[<p>接上篇<a href="/post/fe9b04dd/" title="Hexo + Github 网站添加谷歌跟百度收录">Hexo + Github 网站添加谷歌跟百度收录</a>，说到将博客使用 Github 托管的静态网页，因为
Github 屏蔽了百度的爬虫，因此收录有问题，最近看到一篇博客，可以使用 Zeit
免费托管网页，对于免费用户，每个月流量限额是20G，这点对我来说已经远够用了
<a
href="#ref-anchor-1"><sup>1</sup></a>，便尝试了下，结果成功了，现在记录一下。</p>
<h2 id="注册-zeit">注册 Zeit</h2>
<p>首先打开 <a href="https://vercel.com/">zeit.co</a>
网站，现在好像改名叫 Vercel，注册账号，这里可以直接使用 Github
账号登陆，然后选择你博客的仓库导入：</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/link_github.png" width="50%" height="50%" /></p>
</div>
<p>选择你的 Github.io 仓库</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/link_account.png" width="70%" height="70%" /></p>
</div>
<div data-align="center">
<p><img src="/images/hexo_zeit/select_repo.png" width="70%" height="70%" /></p>
</div>
<p>最后你选择仓库点击 Import 导入：</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/import_github.png" width="50%" height="50%" /></p>
</div>
<p>等待几分钟导入成功后，点击可以访问你的博客主页，这时候静态资源已经部署到
zeit 的边缘 CDN 节点上了，下次你 GitHub 项目的任何更新会触发 zeit
项目更新。</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/import_ok.png" width="90%" height="90%" /></p>
</div>
<h2 id="重定向域名">重定向域名</h2>
<p>接下来的就是切换域名，通过智能 DNS 将国内流量切过去。通过 <a
href="https://vercel.com/">zeit</a> 提供的 DNS
解析服务配置自己的域名，然后在百度站长里配置信息。</p>
<p>在 Domains 下为项目添加你的个人域名。</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/domain.png" width="70%" height="70%" /></p>
</div>
<p>在输入框输入你的域名，然后在弹出的框中，选择推荐项，也就是第一个：</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/add_domain.png" width="50%" height="50%" /></p>
</div>
<p>zeit
会自动创建两个域名解析，但是这个时候因为还没设置域名解析信息，此时解析是失败的。</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/domain_err.png" width="80%" height="80%" /></p>
</div>
<h3 id="使用-a-record">使用 A Record</h3>
<p>这个方法其实就是使用 zeit 提供的域名，替换掉之前 Github
给的域名信息，打开你的域名解析服务，将之前设置好的 Github
的域名停用，然后增加两条 zeit 给的域名信息：</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/github_domain.png" width="80%" height="80%" /></p>
</div>
<p>替换为:</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/zeit_domain.png" width="80%" height="80%" /></p>
</div>
<p>回到 zeit 等待一会后，就会发现域名定向成功，而且自动给你生成 https
证书，完美，重新打开你的网站地址也能正常访问。</p>
<h3 id="nameserver-方式">nameserver 方式</h3>
<p>使用第一种方式需要替换掉之前的 Github 域名，相当于博客不在使用
Github了，对此 zeit 还提供了另外一种方式，就是通过修改
nameserver，我是使用腾讯云来设置域名解析的，因此打开<a
href="https://console.cloud.tencent.com/domain">腾讯云</a>，找到你的域名，点击右侧的
<font color=DarkRed><strong>管理</strong></font>按钮。</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/tencent_domain.png" width="100%" height="100%" /></p>
</div>
<p>找到 DNS 服务器：</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/tencent_domain_modify.png" width="50%" height="50%" /></p>
</div>
<p>改成 zeit 给你的 DNS 服务器，也就是左边的 DNS 服务器：</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/zeit_dns.png" width="70%" height="70%" /></p>
</div>
<p>等待一些时间，就OK了</p>
<h2 id="最后测试抓取">最后测试抓取</h2>
<p>回到<a href="https://ziyuan.baidu.com/">百度站长管理网站</a>，找到
<font color=DarkRed>抓取诊断</font>，手动提交一下你的
Sitemap，重新试一下就能成功啦。</p>
<div data-align="center">
<p><img src="/images/hexo_zeit/baidu_sitemap.png" width="90%" height="90%" /></p>
</div>
<h2 id="参考">参考</h2>
<div id="ref-anchor-1">

</div>
<p><a
href="https://zpjiang.me/2020/01/15/let-baidu-index-github-page/">1.解决百度爬虫无法爬取
Github Pages 个人博客的问题</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/111773896">2.如何让百度收录
GitHub Pages 个人博客</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>InjectFix学习笔记</title>
    <url>/post/5a3da985/</url>
    <content><![CDATA[<h2 id="injectfix-工作流程">1.InjectFix 工作流程</h2>
<ul>
<li>打新包
<ul>
<li>其他预处理</li>
<li>预先配置好需要Patch的类跟函数，提交配置Configure代码</li>
<li>打包机打包时，自动reload被Inject的dll，保证当前的dll没有被注入过</li>
<li>调用InjectFix提供的注入函数，注入WrappersManagerImpl，ILFixInterfaceBridge，ILFixDynamicMethodWrapper，IDMAP-1跟插桩代码dll</li>
<li>执行il2cpp处理</li>
<li>执行其他预处理</li>
</ul></li>
<li>Patch阶段
<ul>
<li>修复代码
<ul>
<li>修复函数：使用标签[IFix.Patch]</li>
<li>新增类、属性、方法：使用标签[IFix.Interpret]</li>
</ul></li>
<li>调用InjectFix提供的打Patch函数，生成Patch文件</li>
<li>生成Patch文件的AssetsBuddle包</li>
<li>上传更新过后的AssetsBuddle包</li>
</ul></li>
</ul>
<blockquote>
<p>ps：在patch过程中，如果没有重新打出新的包体，不要删除Patch标签</p>
</blockquote>
<span id="more"></span>
<h2 id="injectfix-工作原理">2.InjectFix 工作原理</h2>
<h3 id="inject阶段">2.1 Inject阶段</h3>
<h3 id="ifix跟ifix.filter标签">2.1.1 [IFix]跟[IFix.Filter]标签</h3>
<p>在Inject阶段，预先对有可能需要修复的类跟函数提交配置类，调用Inject处理函数时，会对这些写上标签的函数注入插桩代码，例如有如下代码，其中Add跟Sub目前逻辑是错误的，是需要修复的函数：
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">IFix.Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Mult</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Div</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
打包时需要配置对应的配置类，具体配置<strong>Configure</strong>类如下，其中
<strong>[Configure]</strong>
标签是配置类的标签，用来配置注入阶段需要注入或者过滤的内容，配置类必须放在<strong>Editor</strong>目录下。
* <strong>[IFix]</strong> 标签 ：用来配置需要注入的类型 *
<strong>[IFix.Filter]</strong> 标签 ：用来过滤不需要的字段</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Configure</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloworldCfg</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">IFix</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">Type</span>&gt; hotfix</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Type&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">typeof</span>(IFix.Test.Calculator),</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">IFix.Filter</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Filter</span>(<span class="params">System.Reflection.MethodInfo methodInfo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> methodInfo.DeclaringType.FullName == <span class="string">&quot;IFix.Test.Calculator&quot;</span> </span><br><span class="line">            &amp;&amp; (methodInfo.Name == <span class="string">&quot;Div&quot;</span> || methodInfo.Name == <span class="string">&quot;Mult&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>ILSpy工具</strong>查看注入后dll，看到生成如下代码，其中<strong>Add</strong>跟<strong>Sub</strong>方法增加了注入代码，<strong>Mult</strong>跟<strong>Div</strong>函数因为在配置类中被过滤了，没有注入代码。
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IFix.WrappersManagerImpl.IsPatched(<span class="number">6</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> IFix.WrappersManagerImpl.GetPatch(<span class="number">6</span>).__Gen_Wrap_1(<span class="keyword">this</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IFix.WrappersManagerImpl.IsPatched(<span class="number">7</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> IFix.WrappersManagerImpl.GetPatch(<span class="number">7</span>).__Gen_Wrap_1(<span class="keyword">this</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Mult</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Div</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
除了插桩代码，注入阶段还会注入几个相关的代码，其中<strong>IDMAP0</strong>是修复函数的索引ID，当索引值超过32760时，会生成下一个<strong>IDMAP1</strong>，依次类推。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum IDMAP0</span><br><span class="line">&#123;</span><br><span class="line">    IFix-Test-Calculator-Add0 = 6,</span><br><span class="line">    IFix-Test-Calculator-Sub0,</span><br><span class="line">    Helloworld-test0 = 5,</span><br><span class="line">    Helloworld-Start0 = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中的GetPatch(<strong>6</strong>)中的参数<strong>6</strong>对应到注入代码中IDMAP0中<strong>IFix-Test-Calculator-Add0</strong></p>
<p>注入WrappersManagerImpl类代码 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WrappersManagerImpl</span> : <span class="title">WrappersManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> VirtualMachine virtualMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappersManagerImpl</span>(<span class="params">VirtualMachine virtualMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine = virtualMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILFixDynamicMethodWrapper <span class="title">GetPatch</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ILFixDynamicMethodWrapper.wrapperArray[id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsPatched</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id &lt; ILFixDynamicMethodWrapper.wrapperArray.Length &amp;&amp; ILFixDynamicMethodWrapper.wrapperArray[id] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> System.<span class="function">Delegate <span class="title">CreateDelegate</span>(<span class="params">System.Type type, <span class="built_in">int</span> id, <span class="built_in">object</span> anon</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ILFixDynamicMethodWrapper iLFixDynamicMethodWrapper = <span class="keyword">new</span> ILFixDynamicMethodWrapper(<span class="keyword">this</span>.virtualMachine, id, anon);</span><br><span class="line">        <span class="keyword">return</span> Utils.TryAdapterToDelegate(iLFixDynamicMethodWrapper, type, <span class="string">&quot;__Gen_Wrap_&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">CreateWrapper</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ILFixDynamicMethodWrapper(<span class="keyword">this</span>.virtualMachine, id, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">InitWrapperArray</span>(<span class="params"><span class="built_in">int</span> len</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ILFixDynamicMethodWrapper.wrapperArray = <span class="keyword">new</span> ILFixDynamicMethodWrapper[len];</span><br><span class="line">        <span class="keyword">return</span> ILFixDynamicMethodWrapper.wrapperArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnonymousStorey <span class="title">CreateBridge</span>(<span class="params"><span class="built_in">int</span> fieldNum, <span class="built_in">int</span>[] fieldTypes, <span class="built_in">int</span> typeIndex, <span class="built_in">int</span>[] vTable, <span class="built_in">int</span>[] slots, VirtualMachine virtualMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ILFixInterfaceBridge(fieldNum, fieldTypes, typeIndex, vTable, slots, virtualMachine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中使用到的iLFixDynamicMethodWrapper的代码如下，其中 **__Gen_Wrap_X**
函数会根据注入时函数的参数个数，类型来生成，相同的参数只生成一个对应的
**__Gen_Wrap_X** 方法，例子中的Add，Sub方法共用了 **__Gen_Wrap_1** 方法
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ILFixDynamicMethodWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> VirtualMachine virtualMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> methodId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">object</span> anonObj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ILFixDynamicMethodWrapper[] wrapperArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ILFixDynamicMethodWrapper</span>(<span class="params">VirtualMachine virtualMachine, <span class="built_in">int</span> methodId, <span class="built_in">object</span> anonObj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine = virtualMachine;</span><br><span class="line">        <span class="keyword">this</span>.methodId = methodId;</span><br><span class="line">        <span class="keyword">this</span>.anonObj = anonObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> __Gen_Wrap_0(<span class="built_in">string</span> P0)</span><br><span class="line">    &#123;</span><br><span class="line">        Call call = Call.Begin();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            call.PushObject(<span class="keyword">this</span>.anonObj);</span><br><span class="line">        &#125;</span><br><span class="line">        call.PushObject(P0);</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine.Execute(<span class="keyword">this</span>.methodId, <span class="keyword">ref</span> call, (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>) ? <span class="number">2</span> : <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> __Gen_Wrap_1(<span class="built_in">object</span> P0, <span class="built_in">int</span> P1, <span class="built_in">int</span> P2)</span><br><span class="line">    &#123;</span><br><span class="line">        Call call = Call.Begin();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            call.PushObject(<span class="keyword">this</span>.anonObj);</span><br><span class="line">        &#125;</span><br><span class="line">        call.PushObject(P0);</span><br><span class="line">        call.PushInt32(P1);</span><br><span class="line">        call.PushInt32(P2);</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine.Execute(<span class="keyword">this</span>.methodId, <span class="keyword">ref</span> call, (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>) ? <span class="number">4</span> : <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> call.GetInt32(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> __Gen_Wrap_2(<span class="built_in">int</span> P0)</span><br><span class="line">    &#123;</span><br><span class="line">        Call call = Call.Begin();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            call.PushObject(<span class="keyword">this</span>.anonObj);</span><br><span class="line">        &#125;</span><br><span class="line">        call.PushInt32(P0);</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine.Execute(<span class="keyword">this</span>.methodId, <span class="keyword">ref</span> call, (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>) ? <span class="number">2</span> : <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> call.GetInt32(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> __Gen_Wrap_3(<span class="built_in">object</span> P0)</span><br><span class="line">    &#123;</span><br><span class="line">        Call call = Call.Begin();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            call.PushObject(<span class="keyword">this</span>.anonObj);</span><br><span class="line">        &#125;</span><br><span class="line">        call.PushObject(P0);</span><br><span class="line">        <span class="keyword">this</span>.virtualMachine.Execute(<span class="keyword">this</span>.methodId, <span class="keyword">ref</span> call, (<span class="keyword">this</span>.anonObj != <span class="literal">null</span>) ? <span class="number">2</span> : <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">ILFixDynamicMethodWrapper</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ILFixDynamicMethodWrapper.wrapperArray = <span class="keyword">new</span> ILFixDynamicMethodWrapper[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果Patch阶段，有对Add方法进行修复，生成Patch，则执行逻辑会通过IFix.WrappersManagerImpl.GetPatch(6).__Gen_Wrap_1(this,
a, b)调用<strong>ILFixDynamicMethodWrapper
</strong>中的**__Gen_Wrap_1<strong>函数，最终调用</strong>virtualMachine<strong>的函数，通过IFix内部实现的虚拟机，解析执行Patch中的IL指令，执行修复后的代码逻辑，最后然后通过
</strong>call.GetInt32(0)** 获取计算返回的结果，将正确的值返回。</p>
<h3 id="ifix.custombridge-interface和delegate桥接">2.1.2
<strong>[IFix.CustomBridge]</strong> ：interface和delegate桥接</h3>
<p>在注入阶段使用，用来把一个在虚拟机上的类适配到原生interface或者把一个虚拟机的函数适配到原生delegate。
- 修复代码赋值一个闭包到一个delegate变量； -
修复代码的Unity协程用了yield return； -
新增一个函数，赋值到一个delegate变量； -
新增一个类，赋值到一个原生interface变量； - 新增函数，用了yield
return；</p>
<p>例如，原生类代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> running &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置类代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.CustomBridge</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AdditionalBridge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Type&gt; bridge = <span class="keyword">new</span> List&lt;Type&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typeof</span>(ISubSystem),</span><br><span class="line">        <span class="keyword">typeof</span>(IEnumerator),</span><br><span class="line">        <span class="keyword">typeof</span>(Test.MyDelegate)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增函数（或者修复代码[IFix.Patch]的Unity协程），用到了 yield
return</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.Interpret</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">TestInterface</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">    UnityEngine.Debug.Log(<span class="string">&quot;wait one second&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增函数（或者修复代码[IFix.Patch]），赋值到一个delegate变量</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">IFix.Interpret</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyDelegate <span class="title">TestDelegate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (a,b) =&gt; a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增一个类，该类实现了一个接口</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.Interpret</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubSystem</span> : <span class="title">ISubSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> running &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(<span class="string">&quot;SubSystem1.Print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入dll后，使用<strong>ILSpy</strong>能看到dll中有注入的类<strong>ILFixInterfaceBridge</strong></p>
<h3 id="patch阶段">2.2 Patch阶段</h3>
<p>Patch阶段针对修复内容使用对应的Tag * 修复方法 ：[IFix.Patch] *
新增方法、类型 ：[IFix.Interpret]</p>
<h4 id="修复方法">2.2.1 修复方法</h4>
<p>需要修复的方法，再Patch阶段加上[Patch]标签，在执行生成Patch时，被修复的方法就会被写到生成的Patch里，例如，将Add方法从原先的
<strong>a * b</strong> 改成正确的逻辑 <strong>a + b</strong>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Patch</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不支持修复泛型函数，不支持修复构造函数</p>
</blockquote>
<h3 id="新增函数类型">2.2.2 新增函数、类型</h3>
<ul>
<li>新增一个函数</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.Interpret</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Greater</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新增一个类</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">IFix.Interpret</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewClass</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新增一个属性</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;<span class="comment">//这个name字段是原生的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">IFix.Interpret</span>]</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">    	name = <span class="keyword">value</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">IFix.Interpret</span>]</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不支持继承原生类，泛型类，不支持在原生类中新增字段</p>
</blockquote>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Unity开发</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>InjectFix</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 地形 landscape</title>
    <url>/post/310fc368/</url>
    <content><![CDATA[<h1 id="ue4-landscape-mobile">UE4 Landscape Mobile</h1>
<h2 id="ue4-渲染流程">1. UE4 渲染流程</h2>
<h3 id="ue4-渲染线程">1.1 UE4 渲染线程</h3>
<ul>
<li>Game Tread（游戏线程） ：游戏逻辑运算</li>
<li>Rendering Thread（渲染线程） ：从 TaskGraph
中取出任务，并生成平台无关的 Command List （渲染指令列表）</li>
<li>RHI Thread （Render Hardware Interface
线程）：会执行和转换渲染线程的 Command List 成为指定图形 API
的调用（称为Graphical Command），并提交到GPU执行。</li>
</ul>
<figure>
<img src="/images/landscape_mobile/ue4_render_thread.png" alt="stat" />
<figcaption aria-hidden="true">stat</figcaption>
</figure>
<p>这3个线程处理的数据通常是不同帧的，譬如 GameThread
处理N帧数据，RenderThread 和 RHIThread 处理 N-1 帧数据。</p>
<p>但也存在例外，比如 RenderThread 和 RHIThread
运行很快，几乎不存在延迟，这种情况下，GameThread 处理N帧，而
RenderThread 可能处理N或N-1帧，RHIThread 也可能在转换N或N-1帧。</p>
<p>但是，RenderThread 不能落后游戏线程一帧，否则 GameThread 会卡住，直到
RenderThread 处理完所有指令。</p>
<h3 id="渲染概念">1.2 渲染概念</h3>
<ul>
<li><p>UPrimitiveComponent : 场景中需要绘制的 Actor 都会有
UPrimitiveComponent，这个数据是存在于 Game Thread 中</p></li>
<li><p>FPrimitiveSceneProxy 和FPrimitiveSceneInfo :</p>
<ul>
<li><p>FPrimitiveSceneProxy：Render thread 上UPrimitiveComponent
的对应代理，只包含渲染Primitive 所需的数据，但和UPrimitiveComponent
引用同样的数据</p></li>
<li><p>FPrimitiveSceneInfo：和FPrimitiveSceneProxy
一一对应，在引擎的Renderer 模块下</p></li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th>游戏线程</th>
<th>渲染线程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UWorld</td>
<td>FScene</td>
</tr>
<tr class="even">
<td>UPrimitiveComponent</td>
<td>FPrimitiveSceneProxy / FPrimitiveSceneInfo</td>
</tr>
</tbody>
</table>
<h2 id="landscape-渲染流程">2. Landscape 渲染流程</h2>
<h3 id="ue4-地形类结构">2.1 UE4 地形类结构</h3>
<p>我们创建好地形后，场景中会有一个 Landscape 类型的 Actor</p>
<figure>
<img src="/images/landscape_mobile/landscape_actor.png" alt="stat" />
<figcaption aria-hidden="true">stat</figcaption>
</figure>
<p>ALandscape 类型继承关系如下</p>
<p><img src="/images/landscape_mobile/ALandscape.png" width="300" height="188"/></p>
<p>Detail 面板上显示的属性变量都存放在 ALandscapeProxy
类中，这个类主要用来保存地形的详细信息和属性设定值。</p>
<figure>
<img src="/images/landscape_mobile/landscape_actor_info.png"
alt="stat" />
<figcaption aria-hidden="true">stat</figcaption>
</figure>
<p>ALandscape 继承 ALandscapeProxy，在这个基础上实现了更多功能。</p>
<h3 id="ue4-地形渲染过程">2.2 UE4 地形渲染过程</h3>
<h4 id="地形组成结构">2.2.1 地形组成结构</h4>
<p>UE4 地形渲染是以 Component
为基础渲染单元的。我们新建了一个场景，然后创建一个地形，地形参数如下：</p>
<p><img src="/images/landscape_mobile/level_info.png" width="50%" height="50%" /></p>
<p>Landscape 由两个 Component 组成，然后运行中，我们断点获取场景中所有的
Actor，下面是调试信息：</p>
<p><img src="/images/landscape_mobile/actors_in_level.png" width="50%" height="50%" /></p>
<p>找到 Landscape 对象后，我们查看它的
Component，发现当我们给地形设置了两个 Component 后，对应的 ALandscape
对象就会生成两个 LandscapeComponent 组件：</p>
<p><img src="/images/landscape_mobile/components_in_actor.png" width="70%" height="70%" /></p>
<p>然后每个 LandscapeComponent
就是一个基础的渲染单元，如下是地形需要的类的继承关系图，</p>
<figure>
<img src="/images/landscape_mobile/Landscape.svg" alt="stat" />
<figcaption aria-hidden="true">stat</figcaption>
</figure>
<h4 id="创建-sceneproxy">2.2.2 创建 SceneProxy</h4>
<p>按照之前介绍的 UE4 渲染流程，首先会调用 CreateSceneProxy 来创建
SceneProxy（这里对应的就是 FLandscapeComponentSceneProxy 跟
FLandscapeComponentSceneProxyMobile）。</p>
<figure>
<img src="/images/landscape_mobile/step_create_proxy.png" alt="stat" />
<figcaption aria-hidden="true">stat</figcaption>
</figure>
<p>具体调用堆栈如下：</p>
<p><img src="/images/landscape_mobile/add_primitive.png" width="70%" height="70%" /></p>
<p>这里会判断的当前 renderer feature level 来创建对应的
Proxy，下面是对应的平台的 enum 定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ERHIFeatureLevel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/**  OpenGL ES2. Deprecated */</span></span><br><span class="line">        ES2_REMOVED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**  OpenGL ES3.1 &amp; Metal/Vulkan. */</span></span><br><span class="line">        ES3_1,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**  DX10 Shader Model 4.</span></span><br><span class="line"><span class="comment">        * SUPPORT FOR THIS FEATURE LEVEL HAS BEEN ENTIRELY REMOVED. */</span></span><br><span class="line">        SM4_REMOVED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** DX11 Shader Model 5. */</span></span><br><span class="line">        SM5,</span><br><span class="line">        Num</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>移动端跟 PC 端的区别：创建的 Proxy 分别是
FLandscapeComponFLandeneProxy 跟
FLandscapeComponentSceneProxyMobile，FLandscapeComponentSceneProxyMobile
是 FLandscapeComponFLandeneProxy 的子类
两者都会调用基类的构造函数，在构造函数中差异如下：</p>
</blockquote>
<ul>
<li>AvailableMaterials 来源</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FLandscapeComponentSceneProxy::<span class="built_in">FLandscapeComponentSceneProxy</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> FeatureLevel = <span class="built_in">GetScene</span>().<span class="built_in">GetFeatureLevel</span>();</span><br><span class="line">    <span class="comment">// PC</span></span><br><span class="line">    <span class="keyword">if</span> (FeatureLevel &gt;= ERHIFeatureLevel::SM5)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (InComponent-&gt;<span class="built_in">GetLandscapeProxy</span>()-&gt;bUseDynamicMaterialInstance)</span><br><span class="line">        &#123;</span><br><span class="line">            AvailableMaterials.<span class="built_in">Append</span>(InComponent-&gt;MaterialInstancesDynamic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            AvailableMaterials.<span class="built_in">Append</span>(InComponent-&gt;MaterialInstances);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Mobile</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        AvailableMaterials.<span class="built_in">Append</span>(InComponent-&gt;MobileMaterialInterfaces);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SharedBuffersKey : 可以看到如果忽略掉
XYOffsetmapTexture，渲染平台，SharedBuffersKey 只由
SubsectionSizeQuads、NumSubsections 唯一确定。因为所有属于同一个
ALandscape 的 Component 的这两个参数都是一样的，所以这些 Component 的
Proxy 共用一个 SharedBuffersKey.</li>
</ul>
<blockquote>
<p>XYOffsetmapTexture : PC 可以传一张 XYOffsetmapTexture，后面阅读
shader 代码可以看出这个可以对顶点的 xy 坐标做偏移</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SharedBuffer 根据 SharedBufferKey 来创建</span></span><br><span class="line"><span class="type">const</span> int8 SubsectionSizeLog2 = FMath::<span class="built_in">CeilLogTwo</span>(InComponent-&gt;SubsectionSizeQuads + <span class="number">1</span>);</span><br><span class="line">SharedBuffersKey = (SubsectionSizeLog2 &amp; <span class="number">0xf</span>) | ((NumSubsections &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">4</span>) |</span><br><span class="line">    (FeatureLevel &lt;= ERHIFeatureLevel::ES3_1 ? <span class="number">0</span> : <span class="number">1</span> &lt;&lt; <span class="number">30</span>) |</span><br><span class="line">    (XYOffsetmapTexture == <span class="literal">nullptr</span> ? <span class="number">0</span> : <span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>HeightMap</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FLandscapeNeighborInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    UTexture2D* HeightmapTexture; <span class="comment">// PC : Heightmap, Mobile : Weightmap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FLandscapeComponentSceneProxy</span> : <span class="keyword">public</span> FPrimitiveSceneProxy, </span><br><span class="line">    <span class="keyword">public</span> FLandscapeNeighborInfo</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FeatureLevel &lt;= ERHIFeatureLevel::ES3_1)</span><br><span class="line">&#123;</span><br><span class="line">    HeightmapTexture = <span class="literal">nullptr</span>;</span><br><span class="line">    HeightmapSubsectionOffsetU = <span class="number">0</span>;</span><br><span class="line">    HeightmapSubsectionOffsetV = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    HeightmapSubsectionOffsetU = ((<span class="type">float</span>)(InComponent-&gt;SubsectionSizeQuads + <span class="number">1</span>) / </span><br><span class="line">        (<span class="type">float</span>)FMath::<span class="built_in">Max</span>&lt;int32&gt;(<span class="number">1</span>, HeightmapTexture-&gt;<span class="built_in">GetSizeX</span>()));</span><br><span class="line">    HeightmapSubsectionOffsetV = ((<span class="type">float</span>)(InComponent-&gt;SubsectionSizeQuads + <span class="number">1</span>) / </span><br><span class="line">        (<span class="type">float</span>)FMath::<span class="built_in">Max</span>&lt;int32&gt;(<span class="number">1</span>, HeightmapTexture-&gt;<span class="built_in">GetSizeY</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WeightmapTextures 跟 NormalmapTexture</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PC</span></span><br><span class="line">FLandscapeComponentSceneProxy::<span class="built_in">FLandscapeComponentSceneProxy</span>(ULandscapeComponent* InComponent) :</span><br><span class="line">    <span class="built_in">WeightmapTextures</span>(InComponent-&gt;<span class="built_in">GetWeightmapTextures</span>())</span><br><span class="line">    , <span class="built_in">NormalmapTexture</span>(InComponent-&gt;<span class="built_in">GetHeightmap</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mobile</span></span><br><span class="line">FLandscapeComponentSceneProxyMobile::<span class="built_in">FLandscapeComponentSceneProxyMobile</span>(ULandscapeComponent* InComponent)</span><br><span class="line">&#123;</span><br><span class="line">    WeightmapTextures = InComponent-&gt;MobileWeightmapTextures;</span><br><span class="line">    NormalmapTexture = InComponent-&gt;MobileWeightmapTextures[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>HasTessellationEnabled ： 手机不支持曲面细分</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (UMaterialInterface*&amp; MaterialInterface : AvailableMaterials)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> HasTessellationEnabled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// PC</span></span><br><span class="line">        <span class="keyword">if</span> (FeatureLevel &gt;= ERHIFeatureLevel::SM5)</span><br><span class="line">        &#123;</span><br><span class="line">            HasTessellationEnabled = LandscapeMaterial-&gt;D3D11TessellationMode !=</span><br><span class="line">                EMaterialTessellationMode::MTM_NoTessellation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MaterialHasTessellationEnabled.<span class="built_in">Add</span>(HasTessellationEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PC    : true</span></span><br><span class="line"><span class="comment">// Moble : false</span></span><br><span class="line">bSupportsHeightfieldRepresentation = FeatureLevel &lt;= </span><br><span class="line">    ERHIFeatureLevel::ES3_1 ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPrimitiveSceneProxy</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">SupportsHeightfieldRepresentation</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> bSupportsHeightfieldRepresentation; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建渲染资源">2.2.3 创建渲染资源</h4>
<p>创建完 Proxy 然后创建 PrimitiveSceneInfo
并且在渲染进程上创建渲染资源：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FScene::AddPrimitive</span><span class="params">(UPrimitiveComponent* Primitive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 上面的 CreateProxy</span></span><br><span class="line">    FPrimitiveSceneProxy* PrimitiveSceneProxy = Primitive-&gt;<span class="built_in">CreateSceneProxy</span>();</span><br><span class="line">    Primitive-&gt;SceneProxy = PrimitiveSceneProxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the primitive scene info.</span></span><br><span class="line">    FPrimitiveSceneInfo* PrimitiveSceneInfo = <span class="keyword">new</span> <span class="built_in">FPrimitiveSceneInfo</span>(Primitive, <span class="keyword">this</span>);</span><br><span class="line">    PrimitiveSceneProxy-&gt;PrimitiveSceneInfo = PrimitiveSceneInfo;</span><br><span class="line"></span><br><span class="line">    FCreateRenderThreadParameters Params =</span><br><span class="line">    &#123;</span><br><span class="line">        PrimitiveSceneProxy,</span><br><span class="line">        RenderMatrix,</span><br><span class="line">        Primitive-&gt;Bounds,</span><br><span class="line">        AttachmentRootPosition,</span><br><span class="line">        Primitive-&gt;<span class="built_in">CalcBounds</span>(FTransform::Identity)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到渲染线程创建资源</span></span><br><span class="line">    <span class="built_in">ENQUEUE_RENDER_COMMAND</span>(AddPrimitiveCommand)(</span><br><span class="line">        [Params = <span class="built_in">MoveTemp</span>(Params), Scene, PrimitiveSceneInfo, PreviousTransform = <span class="built_in">MoveTemp</span>(PreviousTransform)](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">        &#123;</span><br><span class="line">            FPrimitiveSceneProxy* SceneProxy = Params.PrimitiveSceneProxy;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// SetTransform 这里 mark 一下</span></span><br><span class="line">            SceneProxy-&gt;<span class="built_in">SetTransform</span>(Params.RenderMatrix, Params.WorldBounds, </span><br><span class="line">                Params.LocalBounds, Params.AttachmentRootPosition);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建渲染资源</span></span><br><span class="line">            SceneProxy-&gt;<span class="built_in">CreateRenderThreadResources</span>();</span><br><span class="line">            Scene-&gt;<span class="built_in">AddPrimitiveSceneInfo_RenderThread</span>(PrimitiveSceneInfo, PreviousTransform);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先介绍下 SetTransform 具体做了哪些操作，这个会涉及到后续 Shader 中
Landscape 顶点计算过程，函数参数中包含了 Primitive
的一些基础属性：局部坐标转世界坐标的变换矩阵，包围盒等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPrimitiveSceneProxy::SetTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMatrix&amp; InLocalToWorld, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FBoxSphereBounds&amp; InBounds, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FBoxSphereBounds&amp; InLocalBounds, </span></span></span><br><span class="line"><span class="params"><span class="function">    FVector InActorPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LocalToWorld = InLocalToWorld;</span><br><span class="line">    <span class="comment">// 这里会创建 Primitive 的 UniformBufferObject</span></span><br><span class="line">    <span class="built_in">UpdateUniformBuffer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FPrimitiveUniformShaderParameters PrimitiveUniformShaderParameters = </span><br><span class="line">            <span class="built_in">GetPrimitiveUniformShaderParameters</span>(</span><br><span class="line">                LocalToWorld, </span><br><span class="line">                PreviousLocalToWorld,</span><br><span class="line">                ActorPosition, </span><br><span class="line">                Bounds, </span><br><span class="line">                LocalBounds, </span><br><span class="line">                PreSkinnedLocalBounds,</span><br><span class="line">                bReceivesDecals, </span><br><span class="line">                <span class="built_in">HasDistanceFieldRepresentation</span>(), </span><br><span class="line">                <span class="built_in">HasDynamicIndirectShadowCasterRepresentation</span>(), </span><br><span class="line">                <span class="built_in">UseSingleSampleShadowFromStationaryLights</span>(),</span><br><span class="line">                bHasPrecomputedVolumetricLightmap,</span><br><span class="line">                <span class="built_in">DrawsVelocity</span>(), </span><br><span class="line">                <span class="built_in">GetLightingChannelMask</span>(),</span><br><span class="line">                LpvBiasMultiplier,</span><br><span class="line">                PrimitiveSceneInfo ? PrimitiveSceneInfo-&gt;<span class="built_in">GetLightmapDataOffset</span>() : <span class="number">0</span>,</span><br><span class="line">                SingleCaptureIndex, </span><br><span class="line">                bOutputVelocity || <span class="built_in">AlwaysHasVelocity</span>(),</span><br><span class="line">                <span class="built_in">GetCustomPrimitiveData</span>(),</span><br><span class="line">                <span class="built_in">CastsContactShadow</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UniformBuffer.<span class="built_in">GetReference</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            UniformBuffer.<span class="built_in">UpdateUniformBufferImmediate</span>(PrimitiveUniformShaderParameters);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            UniformBuffer = TUniformBufferRef&lt;FPrimitiveUniformShaderParameters&gt;::<span class="built_in">CreateUniformBufferImmediate</span>(PrimitiveUniformShaderParameters, UniformBuffer_MultiFrame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Primitive Uniform 参数定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> FPrimitiveUniformShaderParameters <span class="title">GetPrimitiveUniformShaderParameters</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMatrix&amp; LocalToWorld,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMatrix&amp; PreviousLocalToWorld,</span></span></span><br><span class="line"><span class="params"><span class="function">    FVector ActorPosition,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FBoxSphereBounds&amp; WorldBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FBoxSphereBounds&amp; LocalBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FBoxSphereBounds&amp; PreSkinnedLocalBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bReceivesDecals,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bHasDistanceFieldRepresentation,   <span class="comment">// Currently unused</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bHasCapsuleRepresentation,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bUseSingleSampleShadowFromStationaryLights,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bUseVolumetricLightmap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bDrawsVelocity,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 LightingChannelMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> LpvBiasMultiplier,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 LightmapDataIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 SingleCaptureIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bOutputVelocity,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FCustomPrimitiveData* CustomPrimitiveData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bCastContactShadow = <span class="literal">true</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FPrimitiveUniformShaderParameters Result;</span><br><span class="line">    Result.LocalToWorld = LocalToWorld;</span><br><span class="line">    Result.WorldToLocal = LocalToWorld.<span class="built_in">Inverse</span>();</span><br><span class="line">    <span class="comment">// 省略一堆参数设置</span></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在渲染进程中调用函数 CreateRenderThreadResource 中初始化顶点
Buffer 以及 Shader 所需要的 UBO</p>
<figure>
<img src="/images/landscape_mobile/step_create_res_mobile.png"
alt="stat" />
<figcaption aria-hidden="true">stat</figcaption>
</figure>
<p>PC 端创建流程如下：</p>
<figure>
<img src="/images/landscape_mobile/step_create_res_pc.png" alt="stat" />
<figcaption aria-hidden="true">stat</figcaption>
</figure>
<ul>
<li>SharedBuffers SharedBuffers 是根据 Proxy 构造时生成的
SharedBuffersKey 来创建，</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SharedBuffers = FLandscapeComponentSceneProxy::SharedBuffersMap.<span class="built_in">FindRef</span>(SharedBuffersKey);</span><br><span class="line"><span class="keyword">if</span> (SharedBuffers == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int32 NumOcclusionVertices = MobileRenderData-&gt;OccluderVerticesSP.<span class="built_in">IsValid</span>() ? </span><br><span class="line">        MobileRenderData-&gt;OccluderVerticesSP-&gt;<span class="built_in">Num</span>() : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">    SharedBuffers = <span class="keyword">new</span> <span class="built_in">FLandscapeSharedBuffers</span>(</span><br><span class="line">        SharedBuffersKey, SubsectionSizeQuads, NumSubsections,</span><br><span class="line">        <span class="built_in">GetScene</span>().<span class="built_in">GetFeatureLevel</span>(), <span class="literal">false</span>, NumOcclusionVertices);</span><br><span class="line"></span><br><span class="line">    FLandscapeComponentSceneProxy::SharedBuffersMap.<span class="built_in">Add</span>(SharedBuffersKey, SharedBuffers);</span><br><span class="line">&#125;</span><br><span class="line">SharedBuffers-&gt;<span class="built_in">AddRef</span>();</span><br></pre></td></tr></table></figure>
<p>FLandscapeSharedBuffer 创建时，会新建 VertexIndex Buff。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FLandscapeSharedBuffers::<span class="built_in">FLandscapeSharedBuffers</span>(...)</span><br><span class="line">    :  <span class="built_in">NumIndexBuffers</span>(FMath::<span class="built_in">CeilLogTwo</span>(InSubsectionSizeQuads + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// SubsectionSizeVerts 7 * 7 : 8 | 15 * 15 : 16</span></span><br><span class="line">    <span class="comment">// NumSubsections      2 * 2 : 2 | 1 * 1 : 1</span></span><br><span class="line">    NumVertices = FMath::<span class="built_in">Square</span>(SubsectionSizeVerts) * </span><br><span class="line">        FMath::<span class="built_in">Square</span>(NumSubsections);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PC </span></span><br><span class="line">    <span class="comment">// Mobile 的 VertextBuffer 在 </span></span><br><span class="line">    <span class="comment">// FLandscapeComponentSceneProxyMobile::MobileRenderData.VertexBuffer</span></span><br><span class="line">    <span class="keyword">if</span> (InFeatureLevel &gt; ERHIFeatureLevel::ES3_1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Vertex Buffer cannot be shared</span></span><br><span class="line">        VertexBuffer = <span class="keyword">new</span> <span class="built_in">FLandscapeVertexBuffer</span>(InFeatureLevel, </span><br><span class="line">            NumVertices, SubsectionSizeVerts, NumSubsections);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 -&gt; 3</span></span><br><span class="line">    <span class="comment">// 15 -&gt; 4</span></span><br><span class="line">    IndexBuffers = <span class="keyword">new</span> FIndexBuffer*[NumIndexBuffers];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NumVertices &gt; <span class="number">65535</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bUse32BitIndices = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">CreateIndexBuffers</span>&lt;uint32&gt;(InFeatureLevel, bRequiresAdjacencyInformation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CreateIndexBuffers</span>&lt;uint16&gt;(InFeatureLevel, bRequiresAdjacencyInformation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CreateIndexBuffer 函数大致如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">int32 MaxLOD = NumIndexBuffers - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐 LOD</span></span><br><span class="line"><span class="keyword">for</span> (int32 Mip = MaxLOD; Mip &gt;= <span class="number">0</span>; Mip--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 每个 Section 2 * 2/ 1 * 1</span></span><br><span class="line">    <span class="keyword">for</span> (int32 SubY = <span class="number">0</span>; SubY &lt; NumSubsections; SubY++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int32 SubX = <span class="number">0</span>; SubX &lt; NumSubsections; SubX++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 逐 Quad 遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶点排列顺序如下</p>
<ul>
<li>Component 只有一个 Section，每个 Section 有 15 * 15 个 Quad 时</li>
</ul>
<p><img src="/images/landscape_mobile/per_quad_1.png" width="50%" height="50%" /></p>
<ul>
<li>Component 有 2 * 2 个 Section，每个 Section 有 7 * 7 个 Quad
时：</li>
</ul>
<p><img src="/images/landscape_mobile/per_quad_2.png" width="50%" height="50%" /></p>
<p>Mobile 计算就稍微有点复杂了，需要计算两个变量 LodSubsectionSizeQuads
和 MipRatio。</p>
<p>假如 Section 构成是 15 * 15，则</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumLOD = NumIndexBuffers <span class="comment">// IndexBuffer 数量</span></span><br><span class="line">       = FMath::<span class="built_in">CeilLogTwo</span>(InSubsectionSizeQuads + <span class="number">1</span>)</span><br><span class="line">       = <span class="built_in">log</span>(<span class="number">2</span>, <span class="number">15</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">MaxLOD = NumLOD - <span class="number">1</span></span><br><span class="line">       = <span class="number">4</span> - <span class="number">1</span> = <span class="number">3</span>  <span class="comment">// LOD(0, 1, 2, 3)</span></span><br><span class="line"></span><br><span class="line">LodSubsectionSizeQuads = (SubsectionSizeVerts &gt;&gt; Mip) - <span class="number">1</span>;</span><br><span class="line">                       = (<span class="number">16</span> &gt;&gt; LOD) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">MipRatio = (<span class="type">float</span>)SubectionSizeQuads / (<span class="type">float</span>)LodSubsectionSizeQuads;</span><br><span class="line">         = <span class="number">15.0</span> / LodSubsectionSizeQuads</span><br></pre></td></tr></table></figure>
<p>于是有如下表格：</p>
<table>
<thead>
<tr class="header">
<th>LOD</th>
<th>LodSubsectionSizeQuads</th>
<th>MipRatio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3</td>
<td>1</td>
<td>15.00</td>
</tr>
<tr class="even">
<td>2</td>
<td>3</td>
<td>5.00</td>
</tr>
<tr class="odd">
<td>1</td>
<td>7</td>
<td>2.143</td>
</tr>
<tr class="even">
<td>0</td>
<td>15</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<p>则 7 * 7 Section 的表格如下：</p>
<table>
<thead>
<tr class="header">
<th>LOD</th>
<th>LodSubsectionSizeQuads</th>
<th>MipRatio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>7.00</td>
</tr>
<tr class="even">
<td>1</td>
<td>3</td>
<td>2.33</td>
</tr>
<tr class="odd">
<td>0</td>
<td>7</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<p>最终计算得出的 LOD 如下：</p>
<ul>
<li>LOD2:</li>
</ul>
<p><img src="/images/landscape_mobile/lod_2_mobile.png" width="50%" height="50%" /></p>
<ul>
<li>LOD1:</li>
</ul>
<p><img src="/images/landscape_mobile/lod_1_mobile.png" width="50%" height="50%" /></p>
<ul>
<li>LOD0:</li>
</ul>
<p><img src="/images/landscape_mobile/quad_empty.png" width="50%" height="50%" /></p>
<p>随后构造
FLandscapeVertexFactoryMobile，主要是用来定义如何将顶点数据以正确的格式发送到
GPU。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FLandscapeVertexFactory</span> : <span class="keyword">public</span> FVertexFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FDataType</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** The stream to read the vertex position from. */</span></span><br><span class="line">        FVertexStreamComponent PositionComponent;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FLandscapeVertexFactoryMobile</span> : <span class="keyword">public</span> FLandscapeVertexFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FDataType</span> : FLandscapeVertexFactory::FDataType</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** stream which has heights of each LOD levels */</span></span><br><span class="line">        TArray&lt;FVertexStreamComponent,TFixedAllocator&lt;LANDSCAPE_MAX_ES_LOD_COMP&gt; &gt; LODHeightsComponent;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LANDSCAPE_MAX_ES_LOD_COMP   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LANDSCAPE_MAX_ES_LOD        6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FLandscapeMobileVertex</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8 Position[<span class="number">4</span>]; <span class="comment">// Pos + LOD 0 Height</span></span><br><span class="line">    uint8 LODHeights[LANDSCAPE_MAX_ES_LOD_COMP*<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLandscapeComponentSceneProxyMobile::CreateRenderThreadResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Init vertex buffer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">check</span>(MobileRenderData-&gt;VertexBuffer);</span><br><span class="line">        MobileRenderData-&gt;VertexBuffer-&gt;<span class="built_in">InitResource</span>();</span><br><span class="line"></span><br><span class="line">        FLandscapeVertexFactoryMobile* LandscapeVertexFactory = <span class="keyword">new</span> <span class="built_in">FLandscapeVertexFactoryMobile</span>(FeatureLevel);</span><br><span class="line">        LandscapeVertexFactory-&gt;MobileData.PositionComponent = <span class="built_in">FVertexStreamComponent</span>(MobileRenderData-&gt;VertexBuffer, </span><br><span class="line">            <span class="built_in">STRUCT_OFFSET</span>(FLandscapeMobileVertex, Position), <span class="built_in">sizeof</span>(FLandscapeMobileVertex), VET_UByte4N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (uint32 Index = <span class="number">0</span>; Index &lt; LANDSCAPE_MAX_ES_LOD_COMP; ++Index)</span><br><span class="line">        &#123;</span><br><span class="line">            LandscapeVertexFactory-&gt;MobileData.LODHeightsComponent.<span class="built_in">Add</span>(<span class="built_in">FVertexStreamComponent</span>(MobileRenderData-&gt;VertexBuffer, </span><br><span class="line">                <span class="built_in">STRUCT_OFFSET</span>(FLandscapeMobileVertex, LODHeights) + <span class="built_in">sizeof</span>(uint8) * <span class="number">4</span> * Index, </span><br><span class="line">                <span class="built_in">sizeof</span>(FLandscapeMobileVertex), VET_UByte4N));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LandscapeVertexFactory-&gt;<span class="built_in">InitResource</span>();</span><br><span class="line">        VertexFactory = LandscapeVertexFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分两个 FVertexStreamComponent：PositionComponent 和
LODHeightsComponent.</p>
<ul>
<li><p>PositionComponent 对应 STRUCT_OFFSET(FLandscapeMobileVertex,
Position)，即来源为 MobileRenderData-&gt;VertexBuffer 的每个顶点数据
(FLandscapeMobileVertex)的高度 Field</p></li>
<li><p>LODHeightsComponent 对应 STRUCT_OFFSET(FLandscapeMobileVertex,
LODHeights) + sizeof(uint8) * 4 * Index，即来源为
MobileRenderData-&gt;VertexBuffer 的每个顶点数据(FLandscapeMobileVertex)
的 LOD 高度(LODHeights)数据，加上此 LOD 的偏移，一共有多少 LOD 就有多少
FVertexStreamComponent 被添加到了 LODHeightsComponent. 这里的
MobileRenderData
就是FLandscapeComponentSceneProxyMobile::MobileRenderData，之前从
Platform 反序列化来的。</p></li>
</ul>
<p>这两个分别对应 Shader 里的参数 PackedPosition 跟 LODHeights</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Engine\Shaders\Private\LandscapeVertexFactory.ush</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FVertexFactoryInput</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FEATURE_LEVEL &gt;= FEATURE_LEVEL_SM4</span></span><br><span class="line">    float4 Position: ATTRIBUTE0;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    float4 PackedPosition: ATTRIBUTE0; <span class="comment">// </span></span><br><span class="line">    float4 LODHeights[<span class="number">2</span>]: ATTRIBUTE1;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里详细解释一下 LODHeights 中的数据
LODHeights：每个顶点的各LOD高度数组，这样编码：
LODHeights[0].x：MinHeight &gt;&gt; 8，其中 MinHeight
为此顶点的所有LOD高度的最小值 LODHeights[0].y：MaxHeight &gt;&gt;
8，其中 MaxHeight 为此顶点的所有LOD高度的最大值 LODHeights[0].zw ~
LODHeight[1].xyzw 为 LOD0~LOD5 的高度值，被归一化到了 LODHeights[0] 到
LODHeight[1] 之间，后面可以看到，在 shader 里会反向解码这些数据。</p>
</blockquote>
<h4 id="顶点数据">2.2.4 顶点数据</h4>
<p>VertextBuffer 里的数据存储如下：Position 是由 4 个 float
组成的，数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FLandscapeVertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> VertexX; <span class="comment">// 对应到 Section 中的 x</span></span><br><span class="line">    <span class="type">float</span> VertexY; <span class="comment">// 对应到 Section 中的 y</span></span><br><span class="line">    <span class="type">float</span> SubX;    <span class="comment">// Component 中 Section 位置</span></span><br><span class="line">    <span class="type">float</span> SubY;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>VertextX/VertexY 表示的是顶点在 Section 中的位置:</p>
<p><img src="/images/landscape_mobile/attribute_1.png" width="50%" height="50%" /></p>
<p>SubX/SubY 表示的是 Section 在 Component 中的位置</p>
<p><img src="/images/landscape_mobile/component_section_quad.png" width="50%" height="50%" /></p>
<p>在 PC 下是在创建 FLandscapeSharedBuffers 时创建，然后通过调用
FLandscapeVertextBuffer::InitRHI，新建的，可以看到顶点是逐 Section
生成的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLandscapeVertexBuffer::InitRHI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRHIResourceCreateInfo CreateInfo;</span><br><span class="line">    <span class="type">void</span>* BufferData = <span class="literal">nullptr</span>;</span><br><span class="line">    int32 VertexIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int32 SubY = <span class="number">0</span>; SubY &lt; NumSubsections; SubY++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int32 SubX = <span class="number">0</span>; SubX &lt; NumSubsections; SubX++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int32 y = <span class="number">0</span>; y &lt; SubsectionSizeVerts; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (int32 x = <span class="number">0</span>; x &lt; SubsectionSizeVerts; x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Vertex-&gt;VertexX = x;</span><br><span class="line">                    Vertex-&gt;VertexY = y;</span><br><span class="line">                    Vertex-&gt;SubX = SubX;</span><br><span class="line">                    Vertex-&gt;SubY = SubY;</span><br><span class="line">                    Vertex++;</span><br><span class="line">                    VertexIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenderDoc 中抓帧数据如下：对应到 ATTRIBUTE 中的数据，下面这个顶点是
Section 0,0 下的顶点 7,2</p>
<p><img src="/images/landscape_mobile/pc_attri.png" width="50%" height="50%" /></p>
<p>Mobile 下则是读取 PlatformData 中的数据，不过这里的数据需要乘以 255
才能得出最终的坐标值：</p>
<p><img src="/images/landscape_mobile/mobile_attri.png" width="50%" height="50%" /></p>
<p>最终地表的顶点数据是在 LandscapeVertextFactory.ush 中生成的，PC 通过
VertexBuffers 跟 HeightMapTexture 生成最终的 Mesh 顶点，Mobile
中的顶点跟高度数据通过读取 PlatformData 中的数据，分别将 VertextBuffers
跟高度数据传给 Shader 计算。</p>
<h4 id="vertext-shader">2.2.5 vertext shader</h4>
<p>下面是从 RenderDoc 抓帧查看 Shader 代码逻辑</p>
<p><img src="/images/landscape_mobile/render_doc_shader.png" width="100%" height="100%" /></p>
<p>下面列出 vertext shader 主要逻辑，GetVertexFactoryIntermediates
。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Engine\Shaders\Private\LandscapeVertexFactory.ush</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FVertexFactoryInput</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FEATURE_LEVEL &gt;= FEATURE_LEVEL_SM4</span></span><br><span class="line">    float4 Position: ATTRIBUTE0;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    float4 PackedPosition: ATTRIBUTE0; <span class="comment">// </span></span><br><span class="line">    float4 LODHeights[<span class="number">2</span>]: ATTRIBUTE1;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mobile</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TERRAIN_ZSCALE (1.0f/128.0f)</span></span><br><span class="line"></span><br><span class="line"><span class="function">FVertexFactoryIntermediates <span class="title">GetVertexFactoryIntermediates</span><span class="params">(FVertexFactoryInput Input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FVertexFactoryIntermediates Intermediates;</span><br><span class="line">    <span class="comment">// 从 PackedPosition 中 xy 读取顶点在 Section 中的位置</span></span><br><span class="line">    Intermediates.InputPosition.xy = Input.PackedPosition.xy * <span class="number">255.f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PackedPosition.z 最后两位存储 Section 编号 00,01,10,11</span></span><br><span class="line">    uint PackedExtraData = (uint)(Input.PackedPosition.z * <span class="number">255.f</span>);</span><br><span class="line">    <span class="type">float</span> SubX = (<span class="type">float</span>)((PackedExtraData &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="type">float</span> SubY = (<span class="type">float</span>)((PackedExtraData &gt;&gt; <span class="number">0</span>) &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Intermediates.InputPosition.zw = <span class="built_in">float2</span>(SubX, SubY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算高度</span></span><br><span class="line">    <span class="type">float</span> MinHeight = <span class="built_in">DecodePackedHeight</span>(<span class="built_in">float2</span>(Input.LODHeights[<span class="number">0</span>].x, Input.LODHeights[<span class="number">0</span>].y));</span><br><span class="line">    <span class="type">float</span> HeightDelta = Input.PackedPosition.w * <span class="number">255.0</span> * <span class="number">256.0</span> * TERRAIN_ZSCALE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略 LOD 计算过程 LODHeightIndex 是计算结果</span></span><br><span class="line">    <span class="type">float</span> InputHeight = Input.LODHeights[LODHeightIndex &gt;&gt; <span class="number">2</span>][LODHeightIndex &amp; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> Height = MinHeight + InputHeight * HeightDelta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 xy</span></span><br><span class="line">    <span class="type">float</span> InvLODScaleFactor = <span class="number">1.f</span> / (<span class="type">float</span>)(<span class="number">1</span> &lt;&lt; (uint)LodValue);</span><br><span class="line">    <span class="comment">// LodValues.x is always 0 on mobile.</span></span><br><span class="line">    float2 ActualLODCoordsInt = <span class="built_in">floor</span>(Intermediates.InputPosition.xy * InvLODScaleFactor);</span><br><span class="line"></span><br><span class="line">    float2 CoordTranslate = <span class="built_in">float2</span>( LandscapeParameters.SubsectionSizeVertsLayerUVPan.x * InvLODScaleFactor - <span class="number">1</span>, </span><br><span class="line">        <span class="built_in">max</span>(LandscapeParameters.SubsectionSizeVertsLayerUVPan.x * <span class="number">0.5f</span> * InvLODScaleFactor, <span class="number">2</span>) - <span class="number">1</span> )</span><br><span class="line">         * LandscapeParameters.SubsectionSizeVertsLayerUVPan.y;</span><br><span class="line">    float2 InputPositionLODAdjusted = ActualLODCoordsInt / CoordTranslate.x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// InputPositionNextLOD : Position for next LOD in base LOD units</span></span><br><span class="line">    float2 NextLODCoordsInt = <span class="built_in">floor</span>(ActualLODCoordsInt * <span class="number">0.5</span>);</span><br><span class="line">    float2 InputPositionNextLOD = NextLODCoordsInt / CoordTranslate.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// InputPositionLODAdjusted 怎么算出来的还没弄懂？</span></span><br><span class="line">    Intermediates.LocalPosition = <span class="built_in">lerp</span>( <span class="built_in">float3</span>(InputPositionLODAdjusted, Height), </span><br><span class="line">        <span class="built_in">float3</span>(InputPositionNextLOD, HeightNextLOD), MorphAlpha );</span><br><span class="line">    <span class="keyword">return</span> Intermediates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后下面是 PC 上的逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FVertexFactoryIntermediates <span class="title">GetVertexFactoryIntermediates</span><span class="params">(FVertexFactoryInput Input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FVertexFactoryIntermediates Intermediates;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FEATURE_LEVEL &gt;= FEATURE_LEVEL_SM4</span></span><br><span class="line">    Intermediates.InputPosition = Input.Position;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 计算采样纹理坐标</span></span><br><span class="line">    float2 SampleCoords = InputPositionLODAdjusted * LandscapeParameters.HeightmapUVScaleBias.xy</span><br><span class="line">        + LandscapeParameters.HeightmapUVScaleBias.zw + <span class="number">0.5</span>*LandscapeParameters.HeightmapUVScaleBias.xy </span><br><span class="line">        + Intermediates.InputPosition.zw * LandscapeParameters.SubsectionOffsetParams.xy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样高度图</span></span><br><span class="line">    float4 SampleValue = <span class="built_in">Texture2DSampleLevel</span>(LandscapeParameters.HeightmapTexture, </span><br><span class="line">        LandscapeParameters.HeightmapTextureSampler, SampleCoords, LodValue-Intermediates.LodBias.x);</span><br><span class="line">    <span class="type">float</span> Height = <span class="built_in">DecodePackedHeight</span>(SampleValue.xy);</span><br><span class="line"></span><br><span class="line">    Intermediates.LocalPosition = <span class="built_in">lerp</span>( <span class="built_in">float3</span>(InputPositionLODAdjusted, Height), </span><br><span class="line">        <span class="built_in">float3</span>(InputPositionNextLOD, HeightNextLOD), MorphAlpha );</span><br><span class="line">    <span class="keyword">return</span> Intermediates;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">GetLocalPosition</span><span class="params">(FVertexFactoryIntermediates Intermediates)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INVARIANT</span>(Intermediates.LocalPosition+<span class="built_in">float3</span>(Intermediates.InputPosition.zw * </span><br><span class="line">        LandscapeParameters.SubsectionOffsetParams.ww,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">VertexFactoryGetWorldPosition</span><span class="params">(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INVARIANT</span>(<span class="built_in">TransformLocalToTranslatedWorld</span>(<span class="built_in">GetLocalPosition</span>(Intermediates)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后是将局部坐标转成世界坐标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">GetLocalPosition</span><span class="params">(FVertexFactoryIntermediates Intermediates)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INVARIANT</span>(Intermediates.LocalPosition + </span><br><span class="line">        <span class="built_in">float3</span>(Intermediates.InputPosition.zw * LandscapeParameters.SubsectionOffsetParams.ww,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">VertexFactoryGetWorldPosition</span><span class="params">(FVertexFactoryInput Input, </span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryIntermediates Intermediates)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INVARIANT</span>(<span class="built_in">TransformLocalToTranslatedWorld</span>(<span class="built_in">GetLocalPosition</span>(Intermediates)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine\Shaders\Private\VertexFactoryCommon.ush</span></span><br><span class="line"><span class="function">float4 <span class="title">TransformLocalToTranslatedWorld</span><span class="params">(float3 LocalPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float3 RotatedPosition = Primitive.LocalToWorld[<span class="number">0</span>].xyz * LocalPosition.xxx + </span><br><span class="line">        Primitive.LocalToWorld[<span class="number">1</span>].xyz * LocalPosition.yyy + </span><br><span class="line">        Primitive.LocalToWorld[<span class="number">2</span>].xyz * LocalPosition.zzz;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float4</span>(RotatedPosition + (Primitive.LocalToWorld[<span class="number">3</span>].xyz + </span><br><span class="line">        ResolvedView.PreViewTranslation.xyz),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Uniform 结构体定义，对应 Shader 中的 LandscapeParameters</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The uniform shader parameters for a landscape draw call. */</span></span><br><span class="line"><span class="built_in">BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT</span>(FLandscapeUniformShaderParameters, LANDSCAPE_API)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(int32, ComponentBaseX)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(int32, ComponentBaseY)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(int32, SubsectionSizeVerts)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(int32, NumSubsections)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(int32, LastLOD)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(FVector4, HeightmapUVScaleBias)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(FVector4, WeightmapUVScaleBias)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(FVector4, LandscapeLightmapScaleBias)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(FVector4, SubsectionSizeVertsLayerUVPan)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(FVector4, SubsectionOffsetParams)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(FVector4, LightmapSubsectionOffsetParams)</span><br><span class="line">    <span class="built_in">SHADER_PARAMETER</span>(FVector4, BlendableLayerMask)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(FMatrix, LocalToWorldNoScaling)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_TEXTURE</span>(Texture2D, HeightmapTexture)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_SAMPLER</span>(SamplerState, HeightmapTextureSampler)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_TEXTURE</span>(Texture2D, NormalmapTexture)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_SAMPLER</span>(SamplerState, NormalmapTextureSampler)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_TEXTURE</span>(Texture2D, XYOffsetmapTexture)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_SAMPLER</span>(SamplerState, XYOffsetmapTextureSampler)</span><br><span class="line"><span class="built_in">END_GLOBAL_SHADER_PARAMETER_STRUCT</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下面函数会对这个 Uniform 进行赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLandscapeComponentSceneProxy::OnTransformChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Set FLandscapeUniformVSParameters for this subsection</span></span><br><span class="line">    FLandscapeUniformShaderParameters LandscapeParams;</span><br><span class="line">    LandscapeParams.ComponentBaseX = ComponentBase.X;</span><br><span class="line">    LandscapeParams.ComponentBaseY = ComponentBase.Y;</span><br><span class="line">    LandscapeParams.SubsectionSizeVerts = SubsectionSizeVerts;</span><br><span class="line">    LandscapeParams.NumSubsections = NumSubsections;</span><br><span class="line">    LandscapeParams.LastLOD = LastLOD;</span><br><span class="line">    LandscapeParams.HeightmapUVScaleBias = HeightmapScaleBias;</span><br><span class="line">    LandscapeParams.WeightmapUVScaleBias = WeightmapScaleBias;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenderDoc 抓帧查看 Uniform Buff 数据</p>
<p><img src="/images/landscape_mobile/uniform_buffer.png" width="100%" height="100%" /></p>
<p>Primitive 数据如下：</p>
<p><img src="/images/landscape_mobile/primitive_param.png" width="80%" height="80%" /></p>
<p>Landscape 参数</p>
<p><img src="/images/landscape_mobile/landscape_param.png" width="80%" height="80%" /></p>
<p>最终计算得出的 Mesh 如下：</p>
<p><img src="/images/landscape_mobile/vs_out.png" width="80%" height="80%" /></p>
<h2 id="参考文献">参考文献</h2>
<p><a href="https://zhuanlan.zhihu.com/p/144031549">1.UE4 Mobile
Landscape 总览及源码解析</a> <a
href="https://zwcloud.net/#blog/109">2.UE4移动端地形理解 -
高度LOD</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
        <tag>Landscape</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 GC原理</title>
    <url>/post/b90b4535/</url>
    <content><![CDATA[<h2 id="uobject概况">UObject概况</h2>
<p>在开始之前，需要先介绍一下UE4是怎样管理UObject的，UObject其实并不是最上层的基类，UE4可能是觉得代码都写在UObject里太多了，看起来比较麻烦，所以就让UObject还继承着别的基类，这样可以把不同代码写到不同的基类里。其中最上层的基类是UObjectBase，他在创建的时候会把自己交给UE4的两个全局容器来管理，在销毁的时候把自己从管理自己的容器中移除
* <strong>GUObjectArray</strong> : 类型是 <strong>FUObjectArray</strong>
* <strong>FUObjectHashTables</strong> :
<strong>FUObjectHashTables::Get()</strong></p>
<h3 id="uobject-继承关系">UObject 继承关系</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UObject</span> : <span class="keyword">public</span> UObjectBaseUtility</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UObjectBaseUtility</span> : <span class="keyword">public</span> UObjectBase</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要防止对象被GC，有4种方式：</p>
<ul>
<li>作为成员变量并标记为UPROPERTY()；</li>
<li>创建对象后 AddToRoot() ；（退出游戏时需要RemoveFromRoot()）</li>
<li>FStreamableManager Load资源时，bManageActiveHandle 设置为true；</li>
<li>FGCObjectScopeGuard 在指定代码区域内保持对象；</li>
</ul>
<p>UObject 创建时，会将自己添加到两个全局容器中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">UObjectBase::<span class="built_in">UObjectBase</span>(UClass* InClass, EObjectFlags InFlags, EInternalObjectFlags InInternalFlags, UObject *InOuter, FName InName)</span><br><span class="line">:   <span class="built_in">ObjectFlags</span>         (InFlags)</span><br><span class="line">,   <span class="built_in">InternalIndex</span>       (INDEX_NONE)</span><br><span class="line">,   <span class="built_in">ClassPrivate</span>        (InClass)</span><br><span class="line">,   <span class="built_in">OuterPrivate</span>        (InOuter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">check</span>(ClassPrivate);</span><br><span class="line">    <span class="comment">// Add to global table.</span></span><br><span class="line">    <span class="built_in">AddObject</span>(InName, InInternalFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UObjectBase::AddObject</span><span class="params">(FName InName, EInternalObjectFlags InSetInternalFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 把自己添加到 UObjectArray 里，并且为 Object 分配 InternalIndex</span></span><br><span class="line">    <span class="built_in">AllocateUObjectIndexForCurrentThread</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">check</span>(InName != NAME_None &amp;&amp; InternalIndex &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把自己添加到 FUObjectHashTables 中</span></span><br><span class="line">    <span class="built_in">HashObject</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fuobjectarray-介绍">FUObjectArray 介绍</h3>
<p><strong>FUObjectArray</strong> 基本代码结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FUObjectArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** First index into objects array taken into account for GC.*/</span></span><br><span class="line">    int32 ObjFirstGCIndex;</span><br><span class="line">    <span class="comment">/** Index pointing to last object created in range disregarded for GC.*/</span></span><br><span class="line">    int32 ObjLastNonGCIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> FChunkedFixedUObjectArray TUObjectArray;</span><br><span class="line">    TUObjectArray ObjObjects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FChunkedFixedUObjectArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        NumElementsPerChunk = <span class="number">64</span> * <span class="number">1024</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Master table to chunks of pointers </span></span><br><span class="line">    FUObjectItem** Objects;</span><br><span class="line">    <span class="comment">// If requested, a contiguous memory where all objects are allocated</span></span><br><span class="line">    FUObjectItem* PreAllocatedObjects;</span><br><span class="line">    <span class="comment">// Maximum number of elements : 64 * 1024</span></span><br><span class="line">    int32 MaxElements;</span><br><span class="line">    <span class="comment">// Number of elements we currently have </span></span><br><span class="line">    int32 NumElements;</span><br><span class="line">    <span class="comment">// Maximum number of chunks</span></span><br><span class="line">    <span class="comment">// Max UObject / NumElementsPerChunk</span></span><br><span class="line">    <span class="comment">// 25165824 = 24 * 1024 * 1024</span></span><br><span class="line">    <span class="comment">// 384</span></span><br><span class="line">    int32 MaxChunks;</span><br><span class="line">    <span class="comment">/** Number of chunks we currently have **/</span></span><br><span class="line">    int32 NumChunks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>FUObjectArray</strong> 会根据当前已有的
<strong>UObject</strong> 个数创建 <strong>Chunk</strong> 数组，每个
<strong>Chunk</strong> 可以容纳 <strong>64 * 1024</strong>
个对象。<strong>UObject-&gt;InternalIndex</strong> 其实就是表示该对象在
<strong>FUObjectArray</strong> 上的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Index = Object-&gt;InternalIndex;</span><br><span class="line"><span class="comment">// NumElementsPerChunk 是个常量 64 * 1024</span></span><br><span class="line"><span class="type">const</span> int32 ChunkIndex = Index / NumElementsPerChunk;</span><br><span class="line"><span class="type">const</span> int32 WithinChunkIndex = Index % NumElementsPerChunk;</span><br></pre></td></tr></table></figure>
<p><img src="/images/ue4_gc/fuobjectarray.png" width=70% height=70% align="center"/></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AllocateUObjectIndexForCurrentThread</span><span class="params">(UObjectBase* Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GUObjectArray.<span class="built_in">AllocateUObjectIndex</span>(Object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUObjectArray::AllocateUObjectIndex</span><span class="params">(UObjectBase* Object, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bMergingThreads <span class="comment">/*= false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前已经有的 UObject个数，计算需要的 Chunk 个数</span></span><br><span class="line">    <span class="comment">// 如果 Chuck满了，则分配新的 Chuck </span></span><br><span class="line">    <span class="comment">// 每个 Chunk 可以放 64 * 1024 个UObject</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空余的Index ：对象销毁的时候，会把自身的 Index</span></span><br><span class="line">    <span class="comment">//              放到 ObjAvailableList 中</span></span><br><span class="line">    int32* AvailableIndex = ObjAvailableList.<span class="built_in">Pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (AvailableIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        Index = (int32)(<span class="type">uintptr_t</span>)AvailableIndex;</span><br><span class="line">        <span class="built_in">check</span>(ObjObjects[Index].Object==<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Index = ObjObjects.<span class="built_in">AddSingle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 FUObjectItem Object 指针 指向 新增的 UObject</span></span><br><span class="line">    <span class="keyword">if</span> (FPlatformAtomics::<span class="built_in">InterlockedCompareExchangePointer</span>((<span class="type">void</span>**)&amp;ObjObjects[Index].Object,</span><br><span class="line">        Object, <span class="literal">NULL</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogUObjectArray, Fatal, <span class="built_in">TEXT</span>(<span class="string">&quot;Unexpected </span></span><br><span class="line"><span class="string">        concurency while adding new object&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object-&gt;InternalIndex = Index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object 销毁</span></span><br><span class="line">UObjectBase::~<span class="built_in">UObjectBase</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If not initialized, skip out.</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">UObjectInitialized</span>() &amp;&amp; ClassPrivate &amp;&amp; !GIsCriticalError )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Validate it.</span></span><br><span class="line">        <span class="built_in">check</span>(<span class="built_in">IsValidLowLevel</span>());</span><br><span class="line">        <span class="built_in">check</span>(<span class="built_in">GetFName</span>() == NAME_None);</span><br><span class="line">        GUObjectArray.<span class="built_in">FreeUObjectIndex</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUObjectArray::FreeUObjectIndex</span><span class="params">(UObjectBase* Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 Index = Object-&gt;InternalIndex;</span><br><span class="line">    <span class="comment">// At this point no two objects exist with the same index so no need to lock here</span></span><br><span class="line">    <span class="keyword">if</span> (FPlatformAtomics::<span class="built_in">InterlockedCompareExchangePointer</span>((<span class="type">void</span>**)&amp;ObjObjects[Index].Object, </span><br><span class="line">        <span class="literal">NULL</span>, Object) == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogUObjectArray, Fatal, <span class="built_in">TEXT</span>(<span class="string">&quot;Unexpected concurency </span></span><br><span class="line"><span class="string">            while adding new object&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Index &gt; ObjLastNonGCIndex &amp;&amp; !GExitPurge)  </span><br><span class="line">    &#123;</span><br><span class="line">        ObjAvailableList.<span class="built_in">Push</span>((int32*)(<span class="type">uintptr_t</span>)Index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fuobjectitem-结构">FUObjectItem 结构</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FUObjectItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Pointer to the allocated object</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UObjectBase</span>* Object;</span><br><span class="line">    <span class="comment">// Internal flags</span></span><br><span class="line">    int32 Flags;</span><br><span class="line">    <span class="comment">// UObject Owner Cluster Index</span></span><br><span class="line">    int32 ClusterRootIndex;</span><br><span class="line">    <span class="comment">// Weak Object Pointer Serial number associated with the object</span></span><br><span class="line">    int32 SerialNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flags : 标记位</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EInternalObjectFlags</span> : int32</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//~ All the other bits are reserved, DO NOT ADD NEW FLAGS HERE!</span></span><br><span class="line"></span><br><span class="line">    ReachableInCluster = <span class="number">1</span> &lt;&lt; <span class="number">23</span>, <span class="comment">///&lt; External reference to object in cluster exists</span></span><br><span class="line">    ClusterRoot = <span class="number">1</span> &lt;&lt; <span class="number">24</span>, <span class="comment">///&lt; Root of a cluster</span></span><br><span class="line">    Native = <span class="number">1</span> &lt;&lt; <span class="number">25</span>, <span class="comment">///&lt; Native (UClass only). </span></span><br><span class="line">    Async = <span class="number">1</span> &lt;&lt; <span class="number">26</span>, <span class="comment">///&lt; Object exists only on a different thread than the game thread.</span></span><br><span class="line">    AsyncLoading = <span class="number">1</span> &lt;&lt; <span class="number">27</span>, <span class="comment">///&lt; Object is being asynchronously loaded.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark</span></span><br><span class="line">    Unreachable = <span class="number">1</span> &lt;&lt; <span class="number">28</span>, <span class="comment">///&lt; Object is not reachable on the object graph.</span></span><br><span class="line"></span><br><span class="line">    PendingKill = <span class="number">1</span> &lt;&lt; <span class="number">29</span>, <span class="comment">///&lt; Objects that are pending destruction (invalid for gameplay but valid objects)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark</span></span><br><span class="line">    RootSet = <span class="number">1</span> &lt;&lt; <span class="number">30</span>, <span class="comment">///&lt; Object will not be garbage collected, even if unreferenced.</span></span><br><span class="line">    <span class="comment">//~ UnusedFlag = 1 &lt;&lt; 31,</span></span><br><span class="line"></span><br><span class="line">    GarbageCollectionKeepFlags = Native | Async | AsyncLoading,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//~ Make sure this is up to date!</span></span><br><span class="line">    AllFlags = ReachableInCluster | ClusterRoot | Native | Async | AsyncLoading | Unreachable | PendingKill | RootSet</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UObject 析构时，会把自己从全局数组中删除，重新创建 UObject
时，原来删除的空位会被重新分配给新的对象，原来的下标会指向新的对象，为了防止业务保存原来的下标取错对象，FUObjectItem
中有一个唯一 ID: SerialNumber。 SerialNumber
是一个自增不重复的的ID，可以用来唯一标识一个 UObject</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">FUObjectArray::AllocateSerialNumber</span><span class="params">(int32 Index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FUObjectItem* ObjectItem = <span class="built_in">IndexToObject</span>(Index);</span><br><span class="line">    <span class="built_in">checkSlow</span>(ObjectItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> int32 *SerialNumberPtr = &amp;ObjectItem-&gt;SerialNumber;</span><br><span class="line">    int32 SerialNumber = *SerialNumberPtr;</span><br><span class="line">    <span class="keyword">if</span> (!SerialNumber)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//////////////////////////////////////////////</span></span><br><span class="line">        SerialNumber = MasterSerialNumber.<span class="built_in">Increment</span>();</span><br><span class="line">        <span class="comment">//////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">UE_CLOG</span>(SerialNumber &lt;= START_SERIAL_NUMBER, LogUObjectArray, Fatal, <span class="built_in">TEXT</span>(<span class="string">&quot;UObject serial numbers overflowed (trying to allocate serial number %d).&quot;</span>), SerialNumber);</span><br><span class="line">        int32 ValueWas = FPlatformAtomics::<span class="built_in">InterlockedCompareExchange</span>((int32*)SerialNumberPtr, SerialNumber, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ValueWas != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// someone else go it first, use their value</span></span><br><span class="line">            SerialNumber = ValueWas;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">checkSlow</span>(SerialNumber &gt; START_SERIAL_NUMBER);</span><br><span class="line">    <span class="keyword">return</span> SerialNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="容器-fuobjectarray-初始化">容器 FUObjectArray 初始化</h3>
<p>在游戏启动时，会初始化全局容器 <strong>FUObjectArray</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UObjectBaseInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 MaxUObjects = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// Default to ~2M UObjects</span></span><br><span class="line">    <span class="keyword">if</span> (FPlatformProperties::<span class="built_in">RequiresCookedData</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Maximum number of UObjects in cooked game</span></span><br><span class="line">        GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsInGame&quot;</span>), MaxUObjects, GEngineIni);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_PROGRAM</span></span><br><span class="line">        <span class="comment">// Maximum number of UObjects for programs can be low</span></span><br><span class="line">        MaxUObjects = <span class="number">100000</span>; <span class="comment">// Default to 100K for programs</span></span><br><span class="line">        GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsInProgram&quot;</span>), MaxUObjects, GEngineIni);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">// Maximum number of UObjects in the editor</span></span><br><span class="line">        GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsInEditor&quot;</span>), MaxUObjects, GEngineIni);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    GUObjectArray.<span class="built_in">AllocateObjectPool</span>(MaxUObjects, MaxObjectsNotConsideredByGC,</span><br><span class="line">        bPreAllocateUObjectArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUObjectArray::AllocateObjectPool</span><span class="params">(int32 InMaxUObjects, </span></span></span><br><span class="line"><span class="params"><span class="function">    int32 InMaxObjectsNotConsideredByGC, <span class="type">bool</span> bPreAllocateObjectArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjObjects.<span class="built_in">PreAllocate</span>(InMaxUObjects, bPreAllocateObjectArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FChunkedFixedUObjectArray::PreAllocate</span><span class="params">(int32 InMaxElements, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bPreAllocateChunks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxChunks = InMaxElements / NumElementsPerChunk + <span class="number">1</span>;</span><br><span class="line">    MaxElements = MaxChunks * NumElementsPerChunk;</span><br><span class="line">    Objects = <span class="keyword">new</span> FUObjectItem*[MaxChunks];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MaxObjects</strong> 配置如下:</p>
<p><img src="/images/ue4_gc/max_uobject_setting.png" width=70% height=70% align="center"/></p>
<p>Android 配置:
<img src="/images/ue4_gc/max_uobject_setting_android.png" width=70% height=70% align="center"/></p>
<h2 id="标记清除gc过程">标记清除GC过程</h2>
<h3 id="gc-标记流程">GC 标记流程</h3>
<p>入口为UObjectGlobals.h中定义的CollectGarbage()函数，如下：</p>
<ul>
<li>获取GC锁</li>
<li>执行CollectGarbageInternal</li>
<li>释放GC锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectGarbage</span><span class="params">(EObjectFlags KeepFlags, <span class="type">bool</span> bPerformFullPurge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// No other thread may be performing UObject operations while we&#x27;re running</span></span><br><span class="line">    <span class="built_in">AcquireGCLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform actual garbage collection</span></span><br><span class="line">    <span class="built_in">CollectGarbageInternal</span>(KeepFlags, bPerformFullPurge);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other threads are free to use UObjects</span></span><br><span class="line">    <span class="built_in">ReleaseGCLock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可达性分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectGarbageInternal</span><span class="params">(EObjectFlags KeepFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bPerformFullPurge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Perform reachability analysis.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">double</span> StartTime = FPlatformTime::<span class="built_in">Seconds</span>();</span><br><span class="line">        FRealtimeGC TagUsedRealtimeGC;</span><br><span class="line">        TagUsedRealtimeGC.<span class="built_in">PerformReachabilityAnalysis</span>(KeepFlags, bForceSingleThreadedGC, bWithClusters);</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogGarbage, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;%f ms for GC&quot;</span>), (FPlatformTime::<span class="built_in">Seconds</span>() - StartTime) * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerformReachabilityAnalysis</span><span class="params">(EObjectFlags KeepFlags, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bForceSingleThreaded, <span class="type">bool</span> bWithClusters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    FGCArrayStruct* ArrayStruct = FGCArrayPool::<span class="built_in">Get</span>().<span class="built_in">GetArrayStructFromPool</span>();</span><br><span class="line">    TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> StartTime = FPlatformTime::<span class="built_in">Seconds</span>();</span><br><span class="line">    (<span class="keyword">this</span>-&gt;*MarkObjectsFunctions[<span class="built_in">GetGCFunctionIndex</span>(!bForceSingleThreaded, bWithClusters)])(ObjectsToSerialize,</span><br><span class="line">         KeepFlags);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> FORCEINLINE int32 <span class="title">GetGCFunctionIndex</span><span class="params">(<span class="type">bool</span> bParallel, <span class="type">bool</span> bWithClusters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int32</span>(bParallel) | (<span class="built_in">int32</span>(bWithClusters) &lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FRealtimeGC</span> : <span class="keyword">public</span> FGarbageCollectionTracer</span><br><span class="line">&#123;</span><br><span class="line">    MarkObjectsFn MarkObjectsFunctions[<span class="number">4</span>];</span><br><span class="line">    ReachabilityAnalysisFn ReachabilityAnalysisFunctions[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">FRealtimeGC</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        MarkObjectsFunctions[<span class="built_in">GetGCFunctionIndex</span>(<span class="literal">false</span>, <span class="literal">false</span>)] = &amp;FRealtimeGC::MarkObjectsAsUnreachable&lt;<span class="literal">false</span>, <span class="literal">false</span>&gt;;</span><br><span class="line">        MarkObjectsFunctions[<span class="built_in">GetGCFunctionIndex</span>(<span class="literal">true</span>, <span class="literal">false</span>)] = &amp;FRealtimeGC::MarkObjectsAsUnreachable&lt;<span class="literal">true</span>, <span class="literal">false</span>&gt;;</span><br><span class="line">        MarkObjectsFunctions[<span class="built_in">GetGCFunctionIndex</span>(<span class="literal">false</span>, <span class="literal">true</span>)] = &amp;FRealtimeGC::MarkObjectsAsUnreachable&lt;<span class="literal">false</span>, <span class="literal">true</span>&gt;;</span><br><span class="line">        MarkObjectsFunctions[<span class="built_in">GetGCFunctionIndex</span>(<span class="literal">true</span>, <span class="literal">true</span>)] = &amp;FRealtimeGC::MarkObjectsAsUnreachable&lt;<span class="literal">true</span>, <span class="literal">true</span>&gt;;</span><br><span class="line"></span><br><span class="line">        ReachabilityAnalysisFunctions[<span class="built_in">GetGCFunctionIndex</span>(<span class="literal">false</span>, <span class="literal">false</span>)] = &amp;FRealtimeGC::PerformReachabilityAnalysisOnObjectsInternal&lt;EFastReferenceCollectorOptions::None | EFastReferenceCollectorOptions::None&gt;;</span><br><span class="line">        ReachabilityAnalysisFunctions[<span class="built_in">GetGCFunctionIndex</span>(<span class="literal">true</span>, <span class="literal">false</span>)] = &amp;FRealtimeGC::PerformReachabilityAnalysisOnObjectsInternal&lt;EFastReferenceCollectorOptions::Parallel | EFastReferenceCollectorOptions::None&gt;;</span><br><span class="line">        ReachabilityAnalysisFunctions[<span class="built_in">GetGCFunctionIndex</span>(<span class="literal">false</span>, <span class="literal">true</span>)] = &amp;FRealtimeGC::PerformReachabilityAnalysisOnObjectsInternal&lt;EFastReferenceCollectorOptions::None | EFastReferenceCollectorOptions::WithClusters&gt;;</span><br><span class="line">        ReachabilityAnalysisFunctions[<span class="built_in">GetGCFunctionIndex</span>(<span class="literal">true</span>, <span class="literal">true</span>)] = &amp;FRealtimeGC::PerformReachabilityAnalysisOnObjectsInternal&lt;EFastReferenceCollectorOptions::Parallel | EFastReferenceCollectorOptions::WithClusters&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标记函数实现如下： UE使用了簇（Cluster）来提高效率，Cluster 是一组
UObject ，在 GC 流程中被视为一个单一的单位，能加速 GC。Cluster
后面再仔细研究下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 标记函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> bParallel, <span class="type">bool</span> bWithClusters&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MarkObjectsAsUnreachable</span><span class="params">(TArray&lt;UObject*&gt;&amp; ObjectsToSerialize, <span class="type">const</span> EObjectFlags KeepFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> EInternalObjectFlags FastKeepFlags = EInternalObjectFlags::GarbageCollectionKeepFlags;</span><br><span class="line">    <span class="comment">// 从全局数组 GUObjectArray 中获取需要 GC UObject 个数</span></span><br><span class="line">    <span class="type">const</span> int32 MaxNumberOfObjects = GUObjectArray.<span class="built_in">GetObjectArrayNum</span>() - GUObjectArray.<span class="built_in">GetFirstGCIndex</span>();</span><br><span class="line">    <span class="comment">// 计算每个 Work 线程需要处理的 UObject 个数</span></span><br><span class="line">    <span class="type">const</span> int32 NumThreads = FMath::<span class="built_in">Max</span>(<span class="number">1</span>, FTaskGraphInterface::<span class="built_in">Get</span>().<span class="built_in">GetNumWorkerThreads</span>());</span><br><span class="line">    <span class="type">const</span> int32 NumberOfObjectsPerThread = (MaxNumberOfObjects / NumThreads) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int32 ThreadIndex = <span class="number">0</span>; ThreadIndex &lt; NumThreads; ++ThreadIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectsToSerializeArrays[ThreadIndex] = FGCArrayPool::<span class="built_in">Get</span>().<span class="built_in">GetArrayStructFromPool</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  worker 线程分段对整个 GUObjectArray 处理</span></span><br><span class="line">    <span class="built_in">ParallelFor</span>(NumThreads, [ObjectsToSerializeArrays, &amp;ClustersToDissolveList, &amp;KeepClusterRefsList, FastKeepFlags, KeepFlags, NumberOfObjectsPerThread, NumThreads, MaxNumberOfObjects](int32 ThreadIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        int32 FirstObjectIndex = ThreadIndex * NumberOfObjectsPerThread + GUObjectArray.<span class="built_in">GetFirstGCIndex</span>();</span><br><span class="line">        int32 NumObjects = (ThreadIndex &lt; (NumThreads - <span class="number">1</span>)) ? NumberOfObjectsPerThread : (MaxNumberOfObjects - (NumThreads - <span class="number">1</span>) * NumberOfObjectsPerThread);</span><br><span class="line">        int32 LastObjectIndex = FMath::<span class="built_in">Min</span>(GUObjectArray.<span class="built_in">GetObjectArrayNum</span>() - <span class="number">1</span>, FirstObjectIndex + NumObjects - <span class="number">1</span>);</span><br><span class="line">        int32 ObjectCountDuringMarkPhase = <span class="number">0</span>;</span><br><span class="line">        TArray&lt;UObject*&gt;&amp; LocalObjectsToSerialize = ObjectsToSerializeArrays[ThreadIndex]-&gt;ObjectsToSerialize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int32 ObjectIndex = FirstObjectIndex; ObjectIndex &lt;= LastObjectIndex; ++ObjectIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            FUObjectItem* ObjectItem = &amp;GUObjectArray.<span class="built_in">GetObjectItemArrayUnsafe</span>()[ObjectIndex];</span><br><span class="line">            <span class="keyword">if</span> (ObjectItem-&gt;Object)</span><br><span class="line">            &#123;</span><br><span class="line">                UObject* Object = (UObject*)ObjectItem-&gt;Object;</span><br><span class="line">                <span class="comment">// Keep track of how many objects are around.</span></span><br><span class="line">                ObjectCountDuringMarkPhase++;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (bWithClusters)</span><br><span class="line">                &#123;</span><br><span class="line">                    ObjectItem-&gt;<span class="built_in">ClearFlags</span>(EInternalObjectFlags::ReachableInCluster);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1.如果一个object属于RootSet 不 GC</span></span><br><span class="line">                <span class="comment">// Object-&gt;AddToRoot()</span></span><br><span class="line">                <span class="keyword">if</span> (ObjectItem-&gt;<span class="built_in">IsRootSet</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bWithClusters)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ObjectItem-&gt;<span class="built_in">HasAnyFlags</span>(EInternalObjectFlags::ClusterRoot) || ObjectItem-&gt;<span class="built_in">GetOwnerIndex</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            KeepClusterRefsList.<span class="built_in">Push</span>(ObjectItem);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    LocalObjectsToSerialize.<span class="built_in">Add</span>(Object);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Regular objects or cluster root objects</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!bWithClusters || ObjectItem-&gt;<span class="built_in">GetOwnerIndex</span>() &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> bMarkAsUnreachable = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 2.如果一个 object 有 Keep 标记位 不 GC</span></span><br><span class="line">                    <span class="keyword">if</span> (ObjectItem-&gt;<span class="built_in">HasAnyFlags</span>(FastKeepFlags))</span><br><span class="line">                    &#123;</span><br><span class="line">                        bMarkAsUnreachable = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!ObjectItem-&gt;<span class="built_in">IsPendingKill</span>() &amp;&amp; KeepFlags != RF_NoFlags &amp;&amp; Object-&gt;<span class="built_in">HasAnyFlags</span>(KeepFlags))</span><br><span class="line">                    &#123;</span><br><span class="line">                        bMarkAsUnreachable = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ObjectItem-&gt;<span class="built_in">IsPendingKill</span>() &amp;&amp; bWithClusters &amp;&amp; </span><br><span class="line">                        ObjectItem-&gt;<span class="built_in">HasAnyFlags</span>(EInternalObjectFlags::ClusterRoot))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ClustersToDissolveList.<span class="built_in">Push</span>(ObjectItem);</span><br><span class="line">                    &#125;</span><br><span class="line">                   </span><br><span class="line">                    <span class="keyword">if</span> (!bMarkAsUnreachable)</span><br><span class="line">                    &#123;</span><br><span class="line">                        LocalObjectsToSerialize.<span class="built_in">Add</span>(Object);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (bWithClusters)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (ObjectItem-&gt;<span class="built_in">HasAnyFlags</span>(EInternalObjectFlags::ClusterRoot))</span><br><span class="line">                            &#123;</span><br><span class="line">                                KeepClusterRefsList.<span class="built_in">Push</span>(ObjectItem);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 不可达 设置 不可达的标记为</span></span><br><span class="line">                        ObjectItem-&gt;<span class="built_in">SetFlags</span>(EInternalObjectFlags::Unreachable);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GObjectCountDuringLastMarkPhase.<span class="built_in">Add</span>(ObjectCountDuringMarkPhase);</span><br><span class="line">    &#125;, !bParallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有收集到的不能被 GC 的 UObject 都会最终添加到 ObjectsToSerialize
中。然后会调用 ReachabilityAnalysisFunctions 数组中的函数分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerformReachabilityAnalysis</span><span class="params">(EObjectFlags KeepFlags, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bForceSingleThreaded, <span class="type">bool</span> bWithClusters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    FGCArrayStruct* ArrayStruct = FGCArrayPool::<span class="built_in">Get</span>().<span class="built_in">GetArrayStructFromPool</span>();</span><br><span class="line">    TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// step 1: 上面的可达性分析</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> StartTime = FPlatformTime::<span class="built_in">Seconds</span>();</span><br><span class="line">    (<span class="keyword">this</span>-&gt;*MarkObjectsFunctions[<span class="built_in">GetGCFunctionIndex</span>(!bForceSingleThreaded, bWithClusters)])(ObjectsToSerialize,</span><br><span class="line">         KeepFlags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// step 2:</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> StartTime = FPlatformTime::<span class="built_in">Seconds</span>();</span><br><span class="line">    <span class="built_in">PerformReachabilityAnalysisOnObjects</span>(ArrayStruct, bForceSingleThreaded, bWithClusters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="收集引用信息">收集引用信息</h3>
<p>基础类概念介绍 先介绍一下ReferenceToken概念
在UObject体系中，每个类有一个UClass实例用于描述该类的反射信息，使用UProperty可描述每个类的成员变量，但在GC中如果直接遍历UProperty来扫描对象引用关系，效率会比较低（因为存在许多非Object引用型Property），所以UE创建了ReferenceToken，它是一组toke流，描述类中对象的引用情况。</p>
<p><img src="/images/ue4_gc/token_exa.png" width=100% height=100% align="center"/></p>
<p><img src="/images/ue4_gc/token_exa2.png" width=100% height=100% align="center"/></p>
<p>下面代码中列举了引用的类型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EGCReferenceType</span></span><br><span class="line">&#123;</span><br><span class="line">    GCRT_None                   = <span class="number">0</span>,</span><br><span class="line">    GCRT_Object,</span><br><span class="line">    GCRT_Class,</span><br><span class="line">    GCRT_PersistentObject,</span><br><span class="line">    GCRT_ExternalPackage,       <span class="comment">// Specific reference type token for UObject external package</span></span><br><span class="line">    GCRT_ArrayObject,</span><br><span class="line">    GCRT_ArrayStruct,</span><br><span class="line">    GCRT_FixedArray,</span><br><span class="line">    GCRT_AddStructReferencedObjects,</span><br><span class="line">    GCRT_AddReferencedObjects,</span><br><span class="line">    GCRT_AddTMapReferencedObjects,</span><br><span class="line">    GCRT_AddTSetReferencedObjects,</span><br><span class="line">    GCRT_AddFieldPathReferencedObject,</span><br><span class="line">    GCRT_ArrayAddFieldPathReferencedObject,</span><br><span class="line">    GCRT_EndOfPointer,</span><br><span class="line">    GCRT_EndOfStream,</span><br><span class="line">    GCRT_NoopPersistentObject,</span><br><span class="line">    GCRT_NoopClass,</span><br><span class="line">    GCRT_ArrayObjectFreezable,</span><br><span class="line">    GCRT_ArrayStructFreezable,</span><br><span class="line">    GCRT_WeakObject,</span><br><span class="line">    GCRT_ArrayWeakObject,</span><br><span class="line">    GCRT_LazyObject,</span><br><span class="line">    GCRT_ArrayLazyObject,</span><br><span class="line">    GCRT_SoftObject,</span><br><span class="line">    GCRT_ArraySoftObject,</span><br><span class="line">    GCRT_Delegate,</span><br><span class="line">    GCRT_ArrayDelegate,</span><br><span class="line">    GCRT_MulticastDelegate,</span><br><span class="line">    GCRT_ArrayMulticastDelegate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是 FGCReferenceInfo 类型定义</p>
<ul>
<li>ReturnCount：返回的嵌套深度</li>
<li>Type：引用的类型，就是 <strong>EGCRefenceType</strong></li>
<li>Offset：这个引用对应的属性在类中的地址偏移</li>
</ul>
<p>UE巧妙的把这3个信息编码成了一个uint32，因此
<strong>FGCReferenceTokenStream</strong> 可以通过
<strong>TArray<uint32></strong> 形式存储 <strong>tokens</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FGCReferenceInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/** Return depth, e.g. 1 for last entry in an array, 2 for last entry in an array of structs of arrays, ... */</span></span><br><span class="line">            uint32 ReturnCount  : <span class="number">8</span>;</span><br><span class="line">            <span class="comment">/** Type of reference */</span></span><br><span class="line">            uint32 Type         : <span class="number">5</span>; <span class="comment">// The number of bits needs to match TFastReferenceCollector::FStackEntry::ContainerHelperType</span></span><br><span class="line">            <span class="comment">/** Offset into struct/ object */</span></span><br><span class="line">            uint32 Offset       : <span class="number">19</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** uint32 value of reference info, used for easy conversion to/ from uint32 for token array */</span></span><br><span class="line">        uint32 Value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FGCReferenceTokenStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** Token array */</span></span><br><span class="line">    TArray&lt;uint32&gt; Tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是我截图的一个堆栈： 这是一个 UMG 测试蓝图 WBP_TestForm_C 初始化
ReferenceTokenStream 时，断点处的内存信息，两个引用 Object 分别是
BtnBack 跟 ImageTest，然后每个 Object
在整个对象的内存空间的偏移地址为：1128 跟 1136，它们嵌套深度都是0。
<img src="/images/ue4_gc/token_add.png" width=100% height=100% align="center"/></p>
<p><img src="/images/ue4_gc/token_add_2.png" width=50% height=50% align="center"/></p>
<ul>
<li>Offset            : 1136 -&gt; 0100 0111 0000</li>
<li>Type              : 1      -&gt; 0 0001</li>
<li>ReturnCount  : 0      -&gt; 0000 0000</li>
</ul>
<p><img src="/images/ue4_gc/token_memory.png" width=50% height=50% align="center"/></p>
<p><img src="/images/ue4_gc/wbp_test_form.png" width=50% height=50% align="center"/></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessObjectArray</span><span class="params">(FGCArrayStruct&amp; InObjectsToSerializeStruct, <span class="type">const</span> FGraphEventRef&amp; MyCompletionGraphEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (CurrentIndex &lt; ObjectsToSerialize.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        CurrentObject = ObjectsToSerialize[CurrentIndex++];</span><br><span class="line">        <span class="comment">// Get pointer to token stream and jump to the start.</span></span><br><span class="line">        FGCReferenceTokenStream* RESTRICT TokenStream = &amp;CurrentObject-&gt;<span class="built_in">GetClass</span>()-&gt;ReferenceTokenStream;</span><br><span class="line">        uint32 TokenStreamIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Keep track of index to reference info. Used to avoid LHSs.</span></span><br><span class="line">        uint32 ReferenceTokenStreamIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        FStackEntry* RESTRICT StackEntry = Stack.<span class="built_in">GetData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象的起始地址</span></span><br><span class="line">        uint8* StackEntryData = (uint8*)CurrentObject;</span><br><span class="line">        StackEntry-&gt;Data = StackEntryData;</span><br><span class="line">        StackEntry-&gt;ContainerType = GCRT_None;</span><br><span class="line">        StackEntry-&gt;Stride = <span class="number">0</span>;</span><br><span class="line">        StackEntry-&gt;Count = <span class="number">-1</span>;</span><br><span class="line">        StackEntry-&gt;LoopStartIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep track of token return count in separate integer as arrays need to fiddle with it.</span></span><br><span class="line">        int32 TokenReturnCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse the token stream.</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">////</span></span><br><span class="line">            <span class="keyword">switch</span>(ReferenceInfo.Type)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> GCRT_Object:</span><br><span class="line">                <span class="keyword">case</span> GCRT_Class:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re dealing with an object reference (this code should be identical to GCRT_NoopClass if ShouldProcessNoOpTokens())</span></span><br><span class="line">                    <span class="comment">// 引用对象的地址： 起始地址 + Offset</span></span><br><span class="line">                    UObject**   ObjectPtr = (UObject**)(StackEntryData + ReferenceInfo.Offset);</span><br><span class="line">                    UObject*&amp;   Object = *ObjectPtr;</span><br><span class="line">                    TokenReturnCount = ReferenceInfo.ReturnCount;</span><br><span class="line">                    ReferenceProcessor.<span class="built_in">HandleTokenStreamObjectReference</span>(NewObjectsToSerialize, CurrentObject, Object, ReferenceTokenStreamIndex, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> GCRT_ArrayObject:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re dealing with an array of object references.</span></span><br><span class="line">                    TArray&lt;UObject*&gt;&amp; ObjectArray = *((TArray&lt;UObject*&gt;*)(StackEntryData + ReferenceInfo.Offset));</span><br><span class="line">                    TokenReturnCount = ReferenceInfo.ReturnCount;</span><br><span class="line">                    <span class="keyword">for</span> (int32 ObjectIndex = <span class="number">0</span>, ObjectNum = ObjectArray.<span class="built_in">Num</span>(); ObjectIndex &lt; ObjectNum; ++ObjectIndex)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ReferenceProcessor.<span class="built_in">HandleTokenStreamObjectReference</span>(NewObjectsToSerialize, CurrentObject, ObjectArray[ObjectIndex], ReferenceTokenStreamIndex, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用到 HandleObjectReference 对引用的对象设置可达标记位，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FORCEINLINE <span class="type">void</span> <span class="title">HandleObjectReference</span><span class="params">(TArray&lt;UObject*&gt;&amp; ObjectsToSerialize, <span class="type">const</span> UObject * <span class="type">const</span> ReferencingObject, UObject*&amp; Object, <span class="type">const</span> <span class="type">bool</span> bAllowReferenceElimination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Disregard NULL objects and perform very fast check to see whether object is part of permanent</span></span><br><span class="line">    <span class="comment">// object pool and should therefore be disregarded. The check doesn&#x27;t touch the object and is</span></span><br><span class="line">    <span class="comment">// cache friendly as it&#x27;s just a pointer compare against to globals.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> IsInPermanentPool = GUObjectAllocator.<span class="built_in">ResidesInPermanentPool</span>(Object);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> int32 ObjectIndex = GUObjectArray.<span class="built_in">ObjectToIndex</span>(Object);</span><br><span class="line">    FUObjectItem* ObjectItem = GUObjectArray.<span class="built_in">IndexToObjectUnsafeForGC</span>(ObjectIndex);</span><br><span class="line">    <span class="comment">// Remove references to pending kill objects if we&#x27;re allowed to do so.</span></span><br><span class="line">    <span class="keyword">if</span> (ObjectItem-&gt;<span class="built_in">IsPendingKill</span>() &amp;&amp; bAllowReferenceElimination)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清理操作">清理操作</h3>
<p>标记阶段完成后，会进入清理阶段，收集所有不可达的 UObject
整理到全局列表 GUnreachableObjects</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CollectGarbageInternal</span><span class="params">(EObjectFlags KeepFlags, <span class="type">bool</span> bPerformFullPurge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GatherUnreachableObjects</span>(bForceSingleThreadedGC);</span><br><span class="line">    <span class="built_in">NotifyUnreachableObjects</span>(GUnreachableObjects);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnhashUnreachableObjects</span><span class="params">(<span class="type">bool</span> bUseTimeLimit, <span class="type">float</span> TimeLimit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> StartTime = FPlatformTime::<span class="built_in">Seconds</span>();</span><br><span class="line">    <span class="type">const</span> int32 TimeLimitEnforcementGranularityForBeginDestroy = <span class="number">10</span>;</span><br><span class="line">    int32 Items = <span class="number">0</span>;</span><br><span class="line">    int32 TimePollCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bFirstIteration = (GUnrechableObjectIndex == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (GUnrechableObjectIndex &lt; GUnreachableObjects.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        FUObjectItem* ObjectItem = GUnreachableObjects[GUnrechableObjectIndex++];</span><br><span class="line">        &#123;</span><br><span class="line">            UObject* Object = <span class="built_in">static_cast</span>&lt;UObject*&gt;(ObjectItem-&gt;Object);</span><br><span class="line">            <span class="function">FScopedCBDProfile <span class="title">Profile</span><span class="params">(Object)</span></span>;</span><br><span class="line">            <span class="comment">// Begin the object&#x27;s asynchronous destruction.</span></span><br><span class="line">            Object-&gt;<span class="built_in">ConditionalBeginDestroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GC 尝试</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UObject::ConditionalBeginDestroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !UE_BUILD_SHIPPING</span></span><br><span class="line">    <span class="comment">// if this object wasn&#x27;t marked (but some were) then that means it was created and destroyed since the SpikeMark command was given</span></span><br><span class="line">    <span class="comment">// this object is contributing to the spike that is being investigated</span></span><br><span class="line">    <span class="keyword">if</span> (DebugSpikeMarkAnnotation.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!DebugSpikeMarkAnnotation.<span class="built_in">Get</span>(<span class="keyword">this</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            DebugSpikeMarkNames.<span class="built_in">Add</span>(<span class="built_in">GetFullName</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">check</span>(<span class="built_in">IsValidLowLevel</span>());</span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">HasAnyFlags</span>(RF_BeginDestroyed) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SetFlags</span>(RF_BeginDestroyed);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(UE_BUILD_SHIPPING || UE_BUILD_TEST)</span></span><br><span class="line">        <span class="built_in">checkSlow</span>(!DebugBeginDestroyed.<span class="built_in">Contains</span>(<span class="keyword">this</span>));</span><br><span class="line">        DebugBeginDestroyed.<span class="built_in">Add</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PROFILE_ConditionalBeginDestroy</span></span><br><span class="line">        <span class="type">double</span> StartTime = FPlatformTime::<span class="built_in">Seconds</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">BeginDestroy</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终完成 GC 清理。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 landscape 使用 Texture Array</title>
    <url>/post/e4cef16/</url>
    <content><![CDATA[<h1 id="landscape-使用-texturearray">Landscape 使用 TextureArray</h1>
<p>UE4 中 Landscape
一般会用到多张贴图来丰富地形地貌，例如下面是一个地形的例子：</p>
<p><img src="/images/landscape_texture_array/landscape_layer.png" width="50%" height="50%" /></p>
<p>这个地形包含 7 个 Layer，每个 Layer 由三张贴图组成：</p>
<p><img src="/images/landscape_texture_array/landscape_texture.png" width="100%" height="100%" /></p>
<p>然后再加上权重图，在打安卓包时，就会出现如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UATHelper: Packaging (Android (ASTC)):   LogShaderCompilers: Display: shader uses 19 samplers exceeding the <span class="built_in">limit</span> of 16</span><br><span class="line">UATHelper: Packaging (Android (ASTC)):   LogShaderCompilers: Display: shader uses 21 samplers exceeding the <span class="built_in">limit</span> of 16</span><br><span class="line">UATHelper: Packaging (Android (ASTC)):   LogShaderCompilers: Display: shader uses 20 samplers exceeding the <span class="built_in">limit</span> of 16</span><br><span class="line">UATHelper: Packaging (Android (ASTC)):   LogShaderCompilers: Warning: Failed to compile Material /Game/STF/Pack03-Lands</span><br><span class="line">capePro/Environment/Landscape/Landscape/M_landscapeGround_ajustabel.M_landscapeGround_ajustabel (MI:/Game/STF/Pack03-La</span><br><span class="line">ndscapePro/Maps/TestMap.testmap:PersistentLevel.Landscape_1.LandscapeMaterialInstanceConstant_290) <span class="keyword">for</span> platform GLSL_ES3_1</span><br><span class="line">_ANDROID, Default Material will be used <span class="keyword">in</span> game.</span><br></pre></td></tr></table></figure>
<p>然后真机上测试，地形会使用默认的材质，这显然不是我们想要的效果，要解决这个问题一个是减少贴图数量，另外一个办法就是使用
TextureArray。</p>
<h2 id="texturearray">1 TextureArray</h2>
<p>在 UE4 4.26 版本，TextureArray 功能是默认开启的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> TAutoConsoleVariable&lt;int32&gt; <span class="title">CVarAllowTexture2DArrayAssetCreation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TEXT(<span class="string">&quot;r.AllowTexture2DArrayCreation&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    TEXT(<span class="string">&quot;Enable UTexture2DArray assets&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    ECVF_Default</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建-texturearray">1.1 创建 TextureArray</h3>
<p>创建 TextureArray
的方法有两种，一种是直接创建，通过右键菜单，直接创建资源：</p>
<p><img src="/images/landscape_texture_array/create_texture_array.png" width="80%" height="80%" /></p>
<p>然后打开 TextureArray 资源，既可设置 TextureArray
中的贴图列表，注意：只有大小、格式一致的贴图才可以放到通一个
TextureArray 里，如果新增加的贴图不匹配，TextureArray
会自动删除最后一个新增的贴图。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UTexture2DArray::CheckArrayTexturesCompatibility</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bError = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextureSourceCmp.<span class="built_in">GetSizeX</span>() != SizeX || TextureSourceCmp.<span class="built_in">GetSizeY</span>() != SizeY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTexture, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Texture2DArray creation failed. </span></span><br><span class="line"><span class="string">            Textures %s and %s have different sizes.&quot;</span>), *TextureName, *TextureNameCmp);</span><br><span class="line">        bError = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PixelFormatCmp != PixelFormat)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTexture, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Texture2DArray creation failed. </span></span><br><span class="line"><span class="string">            Textures %s and %s have incompatible pixel formats.&quot;</span>), *TextureName, *TextureNameCmp);</span><br><span class="line">        bError = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (!bError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们也可以选中一堆贴图，然后将选中的贴图直接生成一个 TextureArray
资源。</p>
<p><img src="/images/landscape_texture_array/create_texture_array_batch.png" width="100%" height="100%" /></p>
<p>往 TextureArray 中增加贴图</p>
<p><img src="/images/landscape_texture_array/add_texture.png" width="100%" height="100%" /></p>
<p>然后可以在编辑界面，修改 TextureArray 的一些属性：</p>
<ul>
<li>开启 Mipmaps</li>
</ul>
<p><img src="/images/landscape_texture_array/mipmaps.png" width="50%" height="50%" /></p>
<ul>
<li>修改压缩格式</li>
</ul>
<p><img src="/images/landscape_texture_array/compression.png" width="50%" height="50%" /></p>
<h3 id="使用-texturearray">1.2 使用 TextureArray</h3>
<p>创建好 TextureArray
后，在材质中使用的方法如下，正常我们采样贴图做法如下：</p>
<p><img src="/images/landscape_texture_array/mat_normal.png" width="100%" height="100%" /></p>
<p>使用 TextureArray 后，UVs
坐标不再是“二维”的了，而是“三维”，第三个分量需要指定采样 TextureArray
中第几张贴图的索引值（0 ~ num - 1）：</p>
<p><img src="/images/landscape_texture_array/mat_texture_array.png" width="100%" height="100%" /></p>
<h3 id="sample-对比">1.3 sample 对比</h3>
<p>使用 unlit 模式下查看，不使用 TextureArray 的 Sample 数目为 3：</p>
<p><img src="/images/landscape_texture_array/normal_sample.png" width="100%" height="100%" /></p>
<p>同样模式下查看，使用 TextureArray 的 Sample 数目为 3：</p>
<p><img src="/images/landscape_texture_array/texture_array_sample.png" width="100%" height="100%" /></p>
<blockquote>
<p>Lit 模式下，会有额外的 sample 次数，因此在 lit 模式下对应的 sample
不一样。</p>
</blockquote>
<p><img src="/images/landscape_texture_array/lit_sample.png" width="100%" height="100%" /></p>
<h3 id="texture2darray-源码">1.4 Texture2DArray 源码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FTextureResource* <span class="title">UTexture2DArray::CreateResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FPixelFormatInfo&amp; FormatInfo = GPixelFormats[<span class="built_in">GetPixelFormat</span>()];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetNumMips</span>() &gt; <span class="number">0</span> &amp;&amp; FormatInfo.Supported)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FTexture2DArrayResource</span>(<span class="keyword">this</span>, </span><br><span class="line">            <span class="built_in">GetResourcePostInitState</span>(PlatformData, GSupportsTexture2DArrayStreaming));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FStreamableTextureResource::InitRHI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CreateTexture</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FTexture2DArrayResource</span> : <span class="keyword">public</span> FStreamableTextureResource</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateTexture</span><span class="params">()</span> <span class="keyword">final</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       </span><br><span class="line">        TRefCountPtr&lt;FRHITexture2DArray&gt; TextureArray = <span class="built_in">RHICreateTexture2DArray</span>(FirstMip.SizeX, </span><br><span class="line">            FirstMip.SizeY, FirstMip.SizeZ, PixelFormat, State.NumRequestedLODs, <span class="number">1</span>, CreationFlags, </span><br><span class="line">            CreateInfo);</span><br><span class="line">        TextureRHI = TextureArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用，然后转成平台相关接口</span></span><br><span class="line">GDynamicRHI-&gt;<span class="built_in">RHICreateTexture2DArray</span>(SizeX, SizeY, </span><br><span class="line">    SizeZ, Format, NumMips, NumSamples, Flags, InResourceState, CreateInfo);</span><br></pre></td></tr></table></figure>
<h3 id="修改地形材质">1.5 修改地形材质</h3>
<p>演示 Demo 的材质原先如下，将单独的贴图采样，修改成 TextureArray：</p>
<p><img src="/images/landscape_texture_array/shader_before.png" width="100%" height="100%" /></p>
<p><img src="/images/landscape_texture_array/shader_after.png" width="100%" height="100%" /></p>
<p>这里注意下贴图格式跟采样格式要匹配</p>
<p>贴图格式:</p>
<p><img src="/images/landscape_texture_array/texture_type.png" width="50%" height="50%" /></p>
<p>采样类型：</p>
<p><img src="/images/landscape_texture_array/sample_type.png" width="40%" height="40%" /></p>
<blockquote>
<p>这里 Diffuse 采样需要使用 Color Normal 采样使用 Normal Roughness
这里给的是 Grayscale，因此采样类型需要改成 Grayscale</p>
</blockquote>
<p>使用 TextureArray 修改之前的地形材质，打包然后在真机运行：</p>
<p><img src="/images/landscape_texture_array/android_pic.jpg" width="100%" height="100%" /></p>
<p>地形有部分区域出现了明显的方格，以及死黑区域。</p>
<h3 id="解决方块问题">1.6 解决方块问题</h3>
<p>经过尝试，发现当靠近地形时，会有明显方块，但是远距离查看地形时，采样正确，猜测是顶点采样的
UV 出问题了</p>
<p>这是近处的效果：</p>
<p><img src="/images/landscape_texture_array/android_near.jpg" width="100%" height="100%" /></p>
<p>这是远处的效果：</p>
<p><img src="/images/landscape_texture_array/android_far.jpg" width="100%" height="100%" /></p>
<p>然后经过尝试发现，使用普通的 TextureCord 能正常显示贴图，然后使用了
LandscapeCorrd 然后配合 Divide，且当除数不为 1 时，就会出现方块：</p>
<p>于是查看 Landscape shader 源码，来尝试解决问题。</p>
<h2 id="landscape-材质">2 Landscape 材质</h2>
<p>新建一个简单的地形材质，节点如下：</p>
<p><img src="/images/landscape_texture_array/shader.png" width="80%" height="80%" /></p>
<p>使用 RenderDoc 抓帧，可以看到在手机上，地形的 Shader 主要有两个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MobileBasePassVertexShader.usf</span><br><span class="line">MobileBasePassPixelShader.usf</span><br></pre></td></tr></table></figure>
<h3 id="pixel-shader">2.1 Pixel Shader</h3>
<p>通过 RenderDoc 截取到地形渲染的 PS shadner 代码如下，采样贴图的 UV
数据来源 TexCorrds</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Engine\Shaders\Private\MobileBasePassPixelShader.usf</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryInterpolantsVSToPS Interpolants, </span></span></span><br><span class="line"><span class="params"><span class="function">    FMobileBasePassInterpolantsVSToPS BasePassInterpolants,</span></span></span><br><span class="line"><span class="params"><span class="function">    in float4 SvPosition</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FPixelMaterialInputs PixelMaterialInputs;</span><br><span class="line">    FMaterialPixelParameters MaterialParameters = <span class="built_in">GetMaterialPixelParameters</span>(Interpolants, SvPosition);</span><br><span class="line">    <span class="comment">// CalcMaterialParametersEx 定义</span></span><br><span class="line">    <span class="comment">// 材质编辑器 -&gt; windows -&gt; shader code -&gt; hlsl 导出代码</span></span><br><span class="line">    <span class="built_in">CalcMaterialParametersEx</span>(MaterialParameters, PixelMaterialInputs, </span><br><span class="line">        In.SvPosition, ScreenPosition, In.bIsFrontFace, TranslatedWorldPosition, </span><br><span class="line">        TranslatedWorldPosition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CalcPixelMaterialInputs</span>(MaterialParameters, PixelMaterialInputs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Local7 Local8 其实就是将 TexCorrd X Y 分别取出来</span></span><br><span class="line">            <span class="type">float</span> Local7 = <span class="built_in">dot</span>(MaterialParameters.TexCoords[<span class="number">0</span>].xy,  <span class="built_in">float2</span> (<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            <span class="type">float</span> Local8 = <span class="built_in">dot</span>(MaterialParameters.TexCoords[<span class="number">0</span>].xy,  <span class="built_in">float2</span> (<span class="number">1</span> ,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            float2  Local9 = (<span class="number">1</span> *  <span class="built_in">float2</span>(Local8, Local7));</span><br><span class="line">            float2  Local10 = (Local9 +  <span class="built_in">float2</span>(<span class="number">0</span>, <span class="number">0</span>)); </span><br><span class="line">            <span class="comment">// 这里是材质编辑器中采样用到的 Param_1</span></span><br><span class="line">            float2  Local11 = (Local10 * Material_ScalarExpressions[<span class="number">0</span>].y); </span><br><span class="line">            float4 Local13 = <span class="built_in">ProcessMaterialColorTextureLookup</span>(<span class="built_in">Texture2DSampleBias</span>(Material_Texture2D_1,</span><br><span class="line">                Material_Texture2D_1Sampler, Local11, View_MaterialTextureMipBias));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/landscape_texture_array/render_debug.png" width="80%" height="80%" /></p>
<p>TexCorrd 来源这个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FMaterialPixelParameters <span class="title">GetMaterialPixelParameters</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryInterpolantsVSToPS Interpolants, </span></span></span><br><span class="line"><span class="params"><span class="function">    float4 SvPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FMaterialPixelParameters Result = <span class="built_in">MakeInitializedMaterialPixelParameters</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NUM_MATERIAL_TEXCOORDS     <span class="comment">// XY layer</span></span></span><br><span class="line">    Result.TexCoords[<span class="number">0</span>] = Interpolants.LayerTexCoord.xy;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是 VS 到 PS 参数的类型定义：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FMobileShadingBasePassVSToPS</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FVertexFactoryInterpolantsVSToPS</span></span><br><span class="line">    &#123;</span><br><span class="line">        float2  LayerTexCoord   : TEXCOORD0; <span class="comment">// xy == texcoord</span></span><br><span class="line">    &#125;;  FactoryInterpolants;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FSharedMobileBasePassInterpolants</span></span><br><span class="line">    &#123;</span><br><span class="line">        float4 PixelPosition    : TEXCOORD8; <span class="comment">// xyz = world position, w = clip z</span></span><br><span class="line">    &#125;  BasePassInterpolants;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    float4 Position : SV_POSITION;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，FMobileShadingBasePassVSToPS 就是 VS
中的输出结果对象类型，接下来就看下 FactoryInterpolants
这个变量的生成过程。</p>
<h3 id="顶点-shader-逻辑">2.2 顶点 Shader 逻辑</h3>
<p>PS 里的输入就是从 C++ 中传入的 Index Buff</p>
<p><img src="/images/landscape_texture_array/fs_index_detail.png" width="100%" height="100%" /></p>
<p>Uniform 主要包含两个</p>
<p><img src="/images/landscape_texture_array/fs_uniform.png" width="50%" height="50%" /></p>
<p>Primitive Uniform</p>
<p><img src="/images/landscape_texture_array/fs_uniform_primitive.png" width="100%" height="100%" /></p>
<p><img src="/images/landscape_texture_array/uniform_primitive.png" width="50%" height="50%" /></p>
<p>Landscape Uniform</p>
<p><img src="/images/landscape_texture_array/fs_uniform_landscape.png" width="100%" height="100%" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Engine\Shaders\Private\MobileBasePassVertexShader.usf</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryInput Input, </span></span></span><br><span class="line"><span class="params"><span class="function">    out FMobileShadingBasePassVSOutput Output</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里之前讲过，如果不考虑 LOD 的情况，返回的坐标是每个顶点位置偏移</span></span><br><span class="line">    FVertexFactoryIntermediates VFIntermediates = <span class="built_in">GetVertexFactoryIntermediates</span>(Input);</span><br><span class="line"></span><br><span class="line">    float4 WorldPositionExcludingWPO = <span class="built_in">VertexFactoryGetWorldPosition</span>(Input, VFIntermediates);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/landscape_texture_array/fs_out.png" width="100%" height="100%" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">GetLocalPosition</span><span class="params">(FVertexFactoryIntermediates Intermediates)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LocalPosition 可以看做是每个顶点在各自 Section 中的 x y</span></span><br><span class="line">    <span class="comment">// ZW 是对应 Section  (0, 0) (0, 1) (1, 0) (1, 1)</span></span><br><span class="line">    <span class="comment">// SubsectionOffsetParams : (0.5, 0.5, 0.5, 7)，w 表示每个 Section 的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INVARIANT</span>(Intermediates.LocalPosition + <span class="built_in">float3</span>(Intermediates.InputPosition.zw</span><br><span class="line">        * LandscapeParameters.SubsectionOffsetParams.ww,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">VertexFactoryGetWorldPosition</span><span class="params">(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">INVARIANT</span>(<span class="built_in">TransformLocalToTranslatedWorld</span>(<span class="built_in">GetLocalPosition</span>(Intermediates)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Primive.LocalToWorld</span></span><br><span class="line"><span class="comment">// 100   0     0     0</span></span><br><span class="line"><span class="comment">// 0     100   0     0</span></span><br><span class="line"><span class="comment">// 0     0     100   0</span></span><br><span class="line"><span class="comment">// 100   200   0     1</span></span><br><span class="line"><span class="function">float4 <span class="title">TransformLocalToTranslatedWorld</span><span class="params">(float3 LocalPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float3 RotatedPosition = Primitive.LocalToWorld[<span class="number">0</span>].xyz * LocalPosition.xxx </span><br><span class="line">        + Primitive.LocalToWorld[<span class="number">1</span>].xyz * LocalPosition.yyy </span><br><span class="line">        + Primitive.LocalToWorld[<span class="number">2</span>].xyz * LocalPosition.zzz;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float4</span>(RotatedPosition + (Primitive.LocalToWorld[<span class="number">3</span>].xyz + ResolvedView.PreViewTranslation.xyz),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就能计算出每个顶点的坐标了，我们主要关注的是 PS 中采样用到的
TexCoord_0，因此继续查看这个变量的计算过程。</p>
<p>VS 向 PS 传参的类型是 FMobileShadingBasePassVSOutput</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FMobileShadingBasePassVSOutput FMobileShadingBasePassVSToPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VertexFactoryGetInterpolants VertexFactoryGetInterpolantsVSToPS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine\Shaders\Private\MobileBasePassVertexShader.usf</span></span><br><span class="line"><span class="comment">// VS Main 函数入口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryInput Input</span></span></span><br><span class="line"><span class="params"><span class="function">    , out FMobileShadingBasePassVSOutput Output</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 省去一堆代码</span></span><br><span class="line">    <span class="comment">// 之前的坐标计算</span></span><br><span class="line">    float4 WorldPositionExcludingWPO = <span class="built_in">VertexFactoryGetWorldPosition</span>(Input, VFIntermediates);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FactoryInterpolants 的生成在这里</span></span><br><span class="line">    Output.FactoryInterpolants = <span class="built_in">VertexFactoryGetInterpolants</span>(Input, VFIntermediates, VertexParameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine\Shaders\Private\LandscapeVertexFactory.ush</span></span><br><span class="line"><span class="function">FVertexFactoryInterpolantsVSToPS <span class="title">VertexFactoryGetInterpolantsVSToPS</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryInput Input, </span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryIntermediates Intermediates, </span></span></span><br><span class="line"><span class="params"><span class="function">    FMaterialVertexParameters VertexParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FVertexFactoryInterpolantsVSToPS Interpolants;</span><br><span class="line"></span><br><span class="line">    Interpolants = (FVertexFactoryInterpolantsVSToPS)<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 随后计算 TexCorrd</span></span><br><span class="line">    FLandscapeTexCoords LandscapeTexCoords = <span class="built_in">GetLandscapeTexCoords</span>(InputPosition, Intermediates)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (ES3_1_PROFILE)</span></span><br><span class="line">    Interpolants.LayerTexCoord = LandscapeTexCoords.LayerTexCoord;</span><br><span class="line">    Interpolants.WeightMapTexCoord  = LandscapeTexCoords.WeightMapTexCoord; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FLandscapeTexCoords <span class="title">GetLandscapeTexCoords</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryInput Input, </span></span></span><br><span class="line"><span class="params"><span class="function">    FVertexFactoryIntermediates Intermediates)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    FLandscapeTexCoords Result;</span><br><span class="line">    <span class="comment">// 根据输入跟 Uniform 中的值，输出 Texcorrd</span></span><br><span class="line">    <span class="comment">// LocalPosition :  0,0 ~ 7,7</span></span><br><span class="line">    <span class="comment">// SubsectionSizeVertsLayerUVPan : 8, 0.14286, 0, 0</span></span><br><span class="line">    <span class="comment">// InputPosition.zw : 0,0 ~ 1,1</span></span><br><span class="line">    <span class="comment">// SubsectionOffsetParams : 0.5, 0.5, 0.5, 7</span></span><br><span class="line">    Result.LayerTexCoord.xy = Intermediates.LocalPosition.xy + </span><br><span class="line">        LandscapeParameters.SubsectionSizeVertsLayerUVPan.zw + </span><br><span class="line">        Intermediates.InputPosition.zw * LandscapeParameters.SubsectionOffsetParams.ww;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以得出计算得出的 LayerTexCoord 其实就是 Landscape 中每个顶点对应在
Component 中的位置。最终计算出来的 TextCorrd_0
结果如下图，可以看到计算得出的 UV 其实大部分都会大于
1，采样的时候贴图设置的是 Wrap，因此最终地形上的纹理会平铺。</p>
<p><img src="/images/landscape_texture_array/fs_out_texcoord0.png" width="100%" height="100%" /></p>
<p>下面是不同方式采样贴图，跟是否使用高精度的对照图，左边列的是使用
TextureCoord 采样贴图的（Corrd），右边列是使用 LandScapeCorrd
方式（LandScape），上面一排是未勾选高精度（normal），下面一排是勾选了高精度的（hp）。
<img src="/images/landscape_texture_array/compare.png" width="100%" height="100%" /></p>
<p>而且离地形远点越远，偏差越大</p>
<p><img src="/images/landscape_texture_array/block_bug.png" width="100%" height="100%" /></p>
<p>RenderDoc 抓帧，FS 输出的 TextureCorrd0 数据完全一致。顶点 Shader
没问题，只能继续分析 Pixel Shader，通过 RenderDoc 抓取 PS 代码发现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  LandscapeCorrd</span></span><br><span class="line">highp vec2 v31 = <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="type">float</span> h32 = <span class="built_in">dot</span>(in_TEXCOORD0, v31);</span><br><span class="line">vec2 v30;</span><br><span class="line">v30.x = h32;</span><br><span class="line">highp vec2 v33 = <span class="built_in">vec2</span>(<span class="number">-0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">float</span> h34 = <span class="built_in">dot</span>(in_TEXCOORD0, v33);</span><br><span class="line">v30.y = h34;</span><br><span class="line">vec2 v35 = v30 * _30.pu_m[<span class="number">2</span>].xx;</span><br><span class="line">highp <span class="type">float</span> f36 = <span class="number">0.5</span>;</span><br><span class="line">highp <span class="type">float</span> f5 = f36;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">highp vec2 v38 = v35;</span><br><span class="line">highp vec4 v39 = _30.pu_m[<span class="number">0</span>];</span><br><span class="line"><span class="type">float</span> h40 = <span class="built_in">dot</span>(v7, v39);</span><br><span class="line">highp vec2 v41 = v35;</span><br><span class="line">highp vec4 v42 = _30.pu_m[<span class="number">1</span>];</span><br><span class="line"><span class="type">float</span> h43 = <span class="built_in">dot</span>(v7, v42);</span><br><span class="line">vec3 v37 = <span class="built_in">clamp</span>((<span class="built_in">texture</span>(Material_Texture2D_0, v38).xyz * <span class="built_in">vec3</span>(h40)) + </span><br><span class="line">    (<span class="built_in">texture</span>(Material_Texture2D_1, v41).xyz * <span class="built_in">vec3</span>(h43)), <span class="built_in">vec3</span>(<span class="number">0.0</span>), <span class="built_in">vec3</span>(<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextureCord</span></span><br><span class="line">highp <span class="type">float</span> f31 = _30.pu_m[<span class="number">2</span>].x;</span><br><span class="line">vec2 v32 = in_TEXCOORD0 * <span class="built_in">vec2</span>(f31);</span><br><span class="line">vec2 v30 = v32;</span><br><span class="line">highp <span class="type">float</span> f33 = <span class="number">0.5</span>;</span><br><span class="line">highp <span class="type">float</span> f5 = f33;</span><br><span class="line">highp vec2 v35 = v30;</span><br><span class="line">highp vec4 v36 = _30.pu_m[<span class="number">0</span>];</span><br><span class="line"><span class="type">float</span> h37 = <span class="built_in">dot</span>(v7, v36);</span><br><span class="line">highp vec2 v38 = v30;</span><br><span class="line">highp vec4 v39 = _30.pu_m[<span class="number">1</span>];</span><br><span class="line"><span class="type">float</span> h40 = <span class="built_in">dot</span>(v7, v39);</span><br><span class="line">vec3 v34 = <span class="built_in">clamp</span>((<span class="built_in">texture</span>(Material_Texture2D_0, v35).xyz * <span class="built_in">vec3</span>(h37)) + </span><br><span class="line">    (<span class="built_in">texture</span>(Material_Texture2D_1, v38).xyz * <span class="built_in">vec3</span>(h40)), <span class="built_in">vec3</span>(<span class="number">0.0</span>), <span class="built_in">vec3</span>(<span class="number">1.0</span>));</span><br></pre></td></tr></table></figure>
<p>精简后得到的 Diff 如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  LandscapeCorrd</span></span><br><span class="line">highp vec2 v31 = <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="type">float</span> h32 = <span class="built_in">dot</span>(in_TEXCOORD0, v31);</span><br><span class="line">vec2 v30;</span><br><span class="line">v30.x = h32;</span><br><span class="line">highp vec2 v33 = <span class="built_in">vec2</span>(<span class="number">-0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">float</span> h34 = <span class="built_in">dot</span>(in_TEXCOORD0, v33);</span><br><span class="line">v30.y = h34;</span><br><span class="line">vec2 v35 = v30 * _30.pu_m[<span class="number">2</span>].xx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextureCord</span></span><br><span class="line">highp <span class="type">float</span> f31 = _30.pu_m[<span class="number">2</span>].x;</span><br><span class="line">vec2 v32 = in_TEXCOORD0 * <span class="built_in">vec2</span>(f31);</span><br><span class="line">vec2 v30 = v32;</span><br></pre></td></tr></table></figure>
<p>两种方式只是最终获取 UV 的计算方式不同，尝试修改 Shader
代码，将出现偏差的代码改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  LandscapeCorrd</span></span><br><span class="line">highp vec2 v31 = <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="type">float</span> h32 = <span class="built_in">dot</span>(in_TEXCOORD0, v31);</span><br><span class="line">vec2 v30;</span><br><span class="line">v30.x = h32;</span><br><span class="line">highp vec2 v33 = <span class="built_in">vec2</span>(<span class="number">-0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">float</span> h34 = <span class="built_in">dot</span>(in_TEXCOORD0, v33);</span><br><span class="line">v30.y = h34;</span><br><span class="line">- vec2 v35 = v30 * _30.pu_m[<span class="number">2</span>].xx;</span><br><span class="line">+ vec2 v35 = in_TEXCOORD0 * _30.pu_m[<span class="number">2</span>].xx;</span><br></pre></td></tr></table></figure>
<p>应用修改后，采样完全正确，因此定位到问题是计算 UV
坐标阶段，然后分别使用 Debug
功能，获取最终反编译后的代码，对比后发现如下差异：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改后                           // 修改前</span></span><br><span class="line">*_277 = _276;                      *_277 = _276;</span><br><span class="line">float2 _279 = *in_TEXCOORD0;       float2 _279 = *v30 : [[RelaxedPrecision]];</span><br></pre></td></tr></table></figure>
<p>发现修改前后差异是变量 V30 后有个：
RelaxedPrecision，不强制驱动使用fp16计算，具体解析在<a
href="https://www.zhihu.com/pin/1176097684682895360">此链接</a></p>
<p>然后尝试回退代码，将其中用到的变量都改成高精度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">highp vec2 v31 = <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">- <span class="type">float</span> h32 = <span class="built_in">dot</span>(in_TEXCOORD0, v31);</span><br><span class="line">+ highp <span class="type">float</span> h32 = <span class="built_in">dot</span>(in_TEXCOORD0, v31);</span><br><span class="line">- vec2 v30;</span><br><span class="line">+ highp vec2 v30;</span><br><span class="line">v30.x = h32;</span><br><span class="line">highp vec2 v33 = <span class="built_in">vec2</span>(<span class="number">-0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">- <span class="type">float</span> h34 = <span class="built_in">dot</span>(in_TEXCOORD0, v33);</span><br><span class="line">+ highp <span class="type">float</span> h34 = <span class="built_in">dot</span>(in_TEXCOORD0, v33);</span><br><span class="line">v30.y = h34;</span><br><span class="line">vec2 v35 = v30 * _30.pu_m[<span class="number">2</span>].xx;</span><br></pre></td></tr></table></figure>
<p>反编译后的代码 diff 如下：</p>
<p><img src="/images/landscape_texture_array/hp_diff.png" width="80%" height="80%" /></p>
<p>应用修改后，效果也完全正确，因此，当使用 LandscapeCord 节点获取 UV
坐标时，UE4 编译生成的代码，会对变量做优化，增加
RelaxedPrecision，这就导致在不同的设备上，运行计算的精度是不确定的，因此在使用该节点时需要注意。</p>
<p>最后抓帧查看 Landscape 开启高精度后的 ps
代码，来验证一下之前的问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启高精度后，v13 被定义成了 highp，对比未开启高精度的 v30</span></span><br><span class="line">highp vec2 v13;</span><br><span class="line">v13.x = <span class="built_in">dot</span>(in_TEXCOORD0, <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">v13.y = <span class="built_in">dot</span>(in_TEXCOORD0, <span class="built_in">vec2</span>(<span class="number">-0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">highp vec2 v14 = v13 * _16.pu_h[<span class="number">7</span>].xx;</span><br><span class="line">highp vec3 v15 = <span class="built_in">clamp</span>((<span class="built_in">texture</span>(Material_Texture2D_0, v14).xyz * <span class="built_in">vec3</span>(<span class="built_in">dot</span>(v5, _16.pu_h[<span class="number">5</span>]))) + </span><br><span class="line">    (<span class="built_in">texture</span>(Material_Texture2D_1, v14).xyz * <span class="built_in">vec3</span>(<span class="built_in">dot</span>(v5, _16.pu_h[<span class="number">6</span>]))), <span class="built_in">vec3</span>(<span class="number">0.0</span>), <span class="built_in">vec3</span>(<span class="number">1.0</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
        <tag>Landscape</tag>
        <tag>TextureArray</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 Render Pipeline</title>
    <url>/post/f83cc9a1/</url>
    <content><![CDATA[<p>终于发奋去研究 UE4
渲染管线了，下面是从网上搜集到的资料，后续会逐步了解渲染管线各个步骤的技术方案。</p>
<p>下图的渲染图详细解释在如下链接中 <a
href="https://www.bilibili.com/video/BV1yb411c7in/">虚幻引擎中文技术直播
第1期 虚幻引擎4的实时渲染流程</a> <img
src="/images/ue4_render_pipline/render_1.jpg" alt="render_1" /></p>
<figure>
<img src="/images/ue4_render_pipline/render_3.jpg" alt="render_2" />
<figcaption aria-hidden="true">render_2</figcaption>
</figure>
<p>下面是官方的完整管线图</p>
<figure>
<img src="/images/ue4_render_pipline/ue_render.jpg"
alt="render_pipline" />
<figcaption aria-hidden="true">render_pipline</figcaption>
</figure>
<h2 id="参考">参考</h2>
<p><a
href="https://www.cnblogs.com/shiroe/p/15571757.html">代码质疑人生：渲染管线Pipeline</a>
<a href="https://learn.unrealengine.com/home/dashboard">Unreal Engine
官网在线课程</a> <a
href="https://learn.unrealengine.com/home/LearningPath/94219">介绍实时渲染原理</a>
<a
href="https://blog.csdn.net/leonwei/article/details/84821849">UE4渲染系统概览：列举了UE4
渲染类视图跟流程图</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>RenderPipline</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 反射系统</title>
    <url>/post/6605f9f/</url>
    <content><![CDATA[<h2 id="ue4-反射系统">UE4 反射系统</h2>
<p>反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力，即在运行过程中检查自己的C++类，函数，成员变量，结构体等等。</p>
<p>在UE4里面，通过如下的宏定义，来实现发射：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UPROPERTY(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UFUNCTION(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTRUCT(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UMETA(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPARAM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENUM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDELEGATE(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCLASS(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_PROLOG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UINTERFACE(...) UCLASS()</span></span><br></pre></td></tr></table></figure>
<p>这些宏分别用在属性，函数，结构体/类型定义等，然后有这些宏定义的属性，函数，类型就能够被蓝图调用</p>
<h2 id="反射实现机制和基本原理">反射实现机制和基本原理</h2>
<p>在了解反射系统之前，我们必须要知道两个UE4特有的文件类型</p>
<ul>
<li>.generate.h</li>
<li>.gen.cpp</li>
</ul>
<p>UE4 在编译之前，会给每一个带有 UCLASS 的文件生成一个对应的
<strong>".generate.h"</strong>，并且要求代码 include
这个头文件（并且是在其他 include
之后），否则无法正常编译。这两个文件都是通过 UBT 和 UHT 生成的。</p>
<h2 id="ubt-和-uht">UBT 和 UHT</h2>
<p><strong>UnrealHeaderTool
（UHT，C++）</strong>：UE4的C++代码解析生成工具，我们在代码里写的那些宏
UCLASS 等和 #include "*.generated.h" 都为 UHT 提供了信息来生成相应的 C++
反射代码
<strong>UnrealBuildTool（UBT，C#）</strong>：UE4的自定义工具，来编译 UE4
的逐个模块并处理依赖等。我们编写的 Target.cs，Build.cs
都是为这个工具服务的。</p>
<p>UE4 中代码编译分两个阶段进行：</p>
<ul>
<li>UHT 被调用。它将解析 C++
头中引擎相关类元数据，并生成自定义代码，以实现诸多 UObject
相关的功能。</li>
<li>普通 C++ 编译器被调用，以便对结果进行编译。</li>
</ul>
<h3 id="ubt">UBT</h3>
<p>UBT主要责任是UE4的各个模块的编译并处理各模块之间的依赖关系的。build.cs和Target.cs都是为这个工具来服务的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Test.Target.cs</span></span><br><span class="line"><span class="keyword">using</span> UnrealBuildTool;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestTarget</span> : <span class="title">TargetRules</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestTarget</span>(<span class="params"> TargetInfo Target</span>) : <span class="title">base</span>(<span class="params">Target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type = TargetType.Game;</span><br><span class="line">        DefaultBuildSettings = BuildSettingsVersion.V2;</span><br><span class="line">        ExtraModuleNames.AddRange( <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Test&quot;</span> &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ubt-支持多种-targettype">UBT 支持多种 TargetType</h3>
<ul>
<li>Game - 需要烘焙数据来运行的独立游戏；</li>
<li>Client - 与Game相同，但包不含任何服务器代码，适用于联网游戏。</li>
<li>Server -
与Game相同，但不包含客户端代码，适用于联网游戏种的独立服务器。</li>
<li>Editor - 扩展编辑器的一种targetType。</li>
<li>Program - 基于虚幻引擎打造的独立工具程序。</li>
</ul>
<h3 id="modules">Modules</h3>
<p>UE4 引擎是由大量的模块集合实现的，模块是通过 C#
源文件声明的，扩展名为 .build.cs，存储在项目的 Source 目录下，每一个
.build.cs 都声明一个类，继承 ModuleRules 基类。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnrealBuildTool;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyModule</span> :<span class="title">ModuleRules</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyModule</span>(<span class="params">ReadOnlyTargetRules Target</span>) : <span class="title">base</span>(<span class="params">Target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Settings go here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uht-预处理">UHT 预处理</h2>
<p>我们编写过程中用到的 UCLASS 、UFUNCTION 这些宏就是参与这个阶段，当
UHT 处理代码时，遇到这些宏标记，就会对代码进行对应的预处理，在正常的 C++
编译预处理过程中，这些宏会被展开，只不过展开内容是空。</p>
<p>UHT 生成的代码分别在 generated.h 和 gen.cpp 中，generated.h
中的代码大多是一些宏定义，用在所声明的类中，编译器预处理时可以增加通用成员，gen.cpp
则是 UHT 给予反射标记生成的用来描述类反射信息的具体代码。</p>
<p>UE4 与反射相关的 UHT 宏标记大多定义在以下几个头文件中：</p>
<ul>
<li>Runtime/CoreUObject/Public/Object/ObjectMacros.h （UHT 标记
UPROPERY等）</li>
<li>Runtime/CoreUObject/Public/Object/ScriptMacros.h（大多是 P_*
的宏，可以利用反射从 Stack 中获取数据）</li>
<li>Runtime/CoreUObject/Public/UObject/Class.h （反射基类的定义
UField/UEnum/UStruct/UClass 等）</li>
</ul>
<p>下面是我们通过 UE4 编辑器生成的一个 C++ 类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyActor.h</span></span><br><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyActor.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TEST_API</span> AMyActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()  <span class="comment">// Line:12</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyActor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">int</span> InValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetValueNoneU</span><span class="params">(<span class="type">int</span> IntValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="type">int</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// MyActor.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyActor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AMyActor::<span class="built_in">AMyActor</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AMyActor::GetValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::SetValue</span><span class="params">(<span class="type">int</span> InValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Value = InValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::SetValueNoneU</span><span class="params">(<span class="type">int</span> InValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Value = InValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在编译时，UBT 会驱动 UHT 为这个类生成 MyActor.generated.h 和
MyActor.gen.cpp 文件。 <em>.generated.h 与 </em>.gen.cpp
文件存放与下列路径 (相对于项目根目录)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Intermediate\Build\Win64\UE4Editor\Inc\&#123;PROJECT_NAME&#125;</span><br></pre></td></tr></table></figure>
<h3 id="generated_body">GENERATED_BODY</h3>
<p>在正式分析这两个文件前，先介绍下 GENERATED_BODY 与
GENERATED_UCLASS_BODY 宏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This pair of macros is used to help implement GENERATED_BODY() and GENERATED_USTRUCT_BODY()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Include a redundant semicolon at the end of the generated code block, so that intellisense parsers can start parsing</span></span><br><span class="line"><span class="comment">// a new declaration if the line number/generated code is out of date.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_BODY_LEGACY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY_LEGACY);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_USTRUCT_BODY(...) GENERATED_BODY()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_UCLASS_BODY(...) GENERATED_BODY_LEGACY()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_UINTERFACE_BODY(...) GENERATED_BODY_LEGACY()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATED_IINTERFACE_BODY(...) GENERATED_BODY_LEGACY()</span></span><br></pre></td></tr></table></figure>
<p>单纯的从宏展开角度看，GENERATED_BODY 与 GENERATED_UCLASS_BODY
区别就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GENERATED_BODY最终生成了这样的一串字符：</span></span><br><span class="line">&#123;CURRENT_FILE_ID&#125;_&#123;__LINE__&#125;_GENERATED_BODY</span><br><span class="line"><span class="comment">// GENERATED_UCLASS_BODY最终生成的是这样的一串字符串：</span></span><br><span class="line">&#123;CURRENT_FILE_ID&#125;_&#123;__LINE__&#125;_GENERATED_BODY_LEGACY</span><br></pre></td></tr></table></figure>
<p>注意：这里用 {}
括着的是其他的宏组成的，这里只是列出来两个宏的不同形式。</p>
<blockquote>
<p>CURRENT_FILE_ID 为项目所在的文件夹的名字_源文件相对路径_h __LINE__
为代码所在行号，也就是上面代码 GENERATED_BODY 所在的第 12 行。</p>
</blockquote>
<p>则这两个宏实际拼接后的字符串如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e.g</span></span><br><span class="line"><span class="comment">// Test\Source\Test\MyActor.h</span></span><br><span class="line"><span class="comment">// GENERATED_BODY</span></span><br><span class="line">Test_Source_Test_MyActor_h_12_GENERATED_BODY</span><br><span class="line"></span><br><span class="line"><span class="comment">// GENERATED_BODY_LEGACY</span></span><br><span class="line">Test_Source_Test_MyActor_h_12_GENERATED_BODY_LEGACY</span><br></pre></td></tr></table></figure>
<p>然后打开 MyActor.generated.h 文件，仔细看其中定义的宏代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright Epic Games, Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment">    Generated code exported from UnrealHeaderTool.</span></span><br><span class="line"><span class="comment">    DO NOT modify this manually! Edit the corresponding .h files instead!</span></span><br><span class="line"><span class="comment">===========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/ObjectMacros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/ScriptMacros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST_MyActor_generated_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;MyActor.generated.h already included, missing &#x27;#pragma once&#x27; in MyActor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_MyActor_generated_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_SPARSE_DATA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_RPC_WRAPPERS \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">    DECLARE_FUNCTION(execSetValue); \</span></span><br><span class="line"><span class="meta">    DECLARE_FUNCTION(execGetValue);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_RPC_WRAPPERS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">    DECLARE_FUNCTION(execSetValue); \</span></span><br><span class="line"><span class="meta">    DECLARE_FUNCTION(execGetValue);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_INCLASS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">    static void StaticRegisterNativesAMyActor(); \</span></span><br><span class="line"><span class="meta">    friend struct Z_Construct_UClass_AMyActor_Statics; \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    DECLARE_CLASS(AMyActor, AActor, COMPILED_IN_FLAGS(0 | CLASS_Config), CASTCLASS_None, TEXT(<span class="string">&quot;/Script/Test&quot;</span>), NO_API) \</span></span><br><span class="line"><span class="meta">    DECLARE_SERIALIZER(AMyActor)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_INCLASS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">    static void StaticRegisterNativesAMyActor(); \</span></span><br><span class="line"><span class="meta">    friend struct Z_Construct_UClass_AMyActor_Statics; \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    DECLARE_CLASS(AMyActor, AActor, COMPILED_IN_FLAGS(0 | CLASS_Config), CASTCLASS_None, TEXT(<span class="string">&quot;/Script/Test&quot;</span>), NO_API) \</span></span><br><span class="line"><span class="meta">    DECLARE_SERIALIZER(AMyActor)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_STANDARD_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">    <span class="comment">/** Standard constructor, called after all reflected properties have been initialized */</span> \</span></span><br><span class="line"><span class="meta">    NO_API AMyActor(const FObjectInitializer&amp; ObjectInitializer); \</span></span><br><span class="line"><span class="meta">    DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(AMyActor) \</span></span><br><span class="line"><span class="meta">    DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, AMyActor); \</span></span><br><span class="line"><span class="meta">DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AMyActor); \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">    <span class="comment">/** Private move- and copy-constructors, should never be used */</span> \</span></span><br><span class="line"><span class="meta">    NO_API AMyActor(AMyActor&amp;&amp;); \</span></span><br><span class="line"><span class="meta">    NO_API AMyActor(const AMyActor&amp;); \</span></span><br><span class="line"><span class="meta">public:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_ENHANCED_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">    <span class="comment">/** Private move- and copy-constructors, should never be used */</span> \</span></span><br><span class="line"><span class="meta">    NO_API AMyActor(AMyActor&amp;&amp;); \</span></span><br><span class="line"><span class="meta">    NO_API AMyActor(const AMyActor&amp;); \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, AMyActor); \</span></span><br><span class="line"><span class="meta">DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(AMyActor); \</span></span><br><span class="line"><span class="meta">    DEFINE_DEFAULT_CONSTRUCTOR_CALL(AMyActor)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_PRIVATE_PROPERTY_OFFSET \</span></span><br><span class="line"><span class="meta">    FORCEINLINE static uint32 __PPO__Value() &#123; return STRUCT_OFFSET(AMyActor, Value); &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_9_PROLOG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_GENERATED_BODY_LEGACY \</span></span><br><span class="line"><span class="meta">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_PRIVATE_PROPERTY_OFFSET \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_SPARSE_DATA \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_RPC_WRAPPERS \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_INCLASS \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_STANDARD_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_GENERATED_BODY \</span></span><br><span class="line"><span class="meta">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_PRIVATE_PROPERTY_OFFSET \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_SPARSE_DATA \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_RPC_WRAPPERS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_INCLASS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_ENHANCED_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; TEST_API UClass* <span class="built_in">StaticClass</span>&lt;<span class="keyword">class</span> <span class="title class_">AMyActor</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CURRENT_FILE_ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CURRENT_FILE_ID Test_Source_Test_MyActor_h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br></pre></td></tr></table></figure>
<p>里面包含了我们刚刚写的那些宏定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CURRENT_FILE_ID Test_Source_Test_MyActor_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_GENERATED_BODY_LEGACY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_GENERATED_BODY</span></span><br></pre></td></tr></table></figure>
<p>因此我们 MyActor.h 用到的 GENERATED_BODY 的代码对应如下宏定义：</p>
<blockquote>
<p>其实 GENERATED_BODY 与 GENERATED_UCLASS_BODY
的区别在于：Test_Source_Test_MyActor_h_12_ENHANCED_CONSTRUCTORS 跟
Test_Source_Test_MyActor_h_12_STANDARD_CONSTRUCTORS
这两个宏，GENERATED_UCLASS_BODY 多了一个 AMyActor(const
FObjectInitializer&amp; ObjectInitializer); 的声明。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Test_Source_Test_MyActor_h_12_GENERATED_BODY \</span></span><br><span class="line"><span class="meta">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_PRIVATE_PROPERTY_OFFSET \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_SPARSE_DATA \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_RPC_WRAPPERS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_INCLASS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">    Test_Source_Test_MyActor_h_12_ENHANCED_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span></span><br></pre></td></tr></table></figure>
<p>展开之后代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MyActor.generated.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMyActor</span> : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">///  begin  GENERATED_BODY()</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// mark 1:</span></span><br><span class="line">    <span class="built_in">DECLARE_FUNCTION</span>(execSetValue);</span><br><span class="line">    <span class="built_in">DECLARE_FUNCTION</span>(execGetValue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">StaticRegisterNativesAMyActor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">Z_Construct_UClass_AMyActor_Statics</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// mark 2:</span></span><br><span class="line">    <span class="built_in">DECLARE_CLASS</span>(AMyActor, AActor, <span class="built_in">COMPILED_IN_FLAGS</span>(<span class="number">0</span> | CLASS_Config), CASTCLASS_None, <span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Test&quot;</span>), NO_API)</span><br><span class="line">    <span class="comment">// mark 3:</span></span><br><span class="line">    <span class="built_in">DECLARE_SERIALIZER</span>(AMyActor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** Private move- and copy-constructors, should never be used */</span></span><br><span class="line">    <span class="function">NO_API <span class="title">AMyActor</span><span class="params">(AMyActor&amp;&amp;)</span></span>;</span><br><span class="line">    <span class="function">NO_API <span class="title">AMyActor</span><span class="params">(<span class="type">const</span> AMyActor&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DECLARE_VTABLE_PTR_HELPER_CTOR</span>(NO_API, AMyActor);</span><br><span class="line">    <span class="built_in">DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER</span>(AMyActor);</span><br><span class="line">    <span class="built_in">DEFINE_DEFAULT_CONSTRUCTOR_CALL</span>(AMyActor)</span><br><span class="line"></span><br><span class="line"><span class="comment">///  end  GENERATED_BODY()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyActor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">int</span> InValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetValueNoneU</span><span class="params">(<span class="type">int</span> IntValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="type">int</span> Value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyActor.gen.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Test/MyActor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_FUNCTION</span>(AMyActor::execSetValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">P_GET_PROPERTY</span>(FIntProperty,Z_Param_InValue);</span><br><span class="line">    P_FINISH;</span><br><span class="line">    P_NATIVE_BEGIN;</span><br><span class="line">    P_THIS-&gt;<span class="built_in">SetValue</span>(Z_Param_InValue);</span><br><span class="line">    P_NATIVE_END;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DEFINE_FUNCTION</span>(AMyActor::execGetValue)</span><br><span class="line">&#123;</span><br><span class="line">    P_FINISH;</span><br><span class="line">    P_NATIVE_BEGIN;</span><br><span class="line">    *(int32*)Z_Param__Result=P_THIS-&gt;<span class="built_in">GetValue</span>();</span><br><span class="line">    P_NATIVE_END;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::StaticRegisterNativesAMyActor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UClass* Class = AMyActor::<span class="built_in">StaticClass</span>();</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> FNameNativePtrPair Funcs[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;GetValue&quot;</span>, &amp;AMyActor::execGetValue &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;SetValue&quot;</span>, &amp;AMyActor::execSetValue &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    FNativeFunctionRegistrar::<span class="built_in">RegisterFunctions</span>(Class, Funcs, <span class="built_in">UE_ARRAY_COUNT</span>(Funcs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_CLASS</span>(AMyActor, <span class="number">1716205458</span>);</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; TEST_API UClass* <span class="built_in">StaticClass</span>&lt;AMyActor&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AMyActor::<span class="built_in">StaticClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>DECLARE_FUNCTION 为使用 UFUNCIONT 标记的函数创建中间函数；</li>
<li>DECLARE_CLASS ：声明定义当前类的几个关键信息：Super 和 ThisClass 等
typedef 在此处被定义，以及
StaticClass/StaticPackage/StaticClassCastFlags 和重载的 new
也被定义；</li>
<li>DECLARE_SERIALIZER：重载 &lt;&lt; 使可以被 FArchive 序列化；</li>
<li>DECLARE_VTABLE_PTR_HELPER_CTOR：声明一个接收 FVTableHelper&amp;
参数的构造函数；</li>
<li>DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL：定义一个名为__DefaultConstructor
的静态函数，其中是调用 placement-new
创建类对象（用于统一的内存分配），引擎中唯一调用的位置是在 Class.h
的模板函数 InternalConstructor；</li>
</ul>
<blockquote>
<p>placement-new :
就是在用户指定的内存位置上构建新的对象，这个构建过程不需要额外分配内存，只需要调用对象的构造函数即可。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* buff = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">sizeof</span>(Foo) * N ];</span><br><span class="line"><span class="built_in">memset</span>( buff, <span class="number">0</span>, <span class="built_in">sizeof</span>(Foo)*N );</span><br><span class="line"></span><br><span class="line"><span class="comment">/// placement-new</span></span><br><span class="line">Foo* pfoo = <span class="built_in">new</span> (buff)Foo;</span><br></pre></td></tr></table></figure>
<h3 id="declare_class">DECLARE_CLASS</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    MyActor&amp; <span class="keyword">operator</span>=(MyActor&amp;&amp;);   </span><br><span class="line">    MyActor&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyActor&amp;);   </span><br><span class="line">    <span class="function">TRequiredAPI <span class="type">static</span> UClass* <span class="title">GetPrivateStaticClass</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">/** Bitwise union of #EClassFlags pertaining to this class.*/</span> </span><br><span class="line">    <span class="keyword">enum</span> &#123;StaticClassFlags=TStaticFlags&#125;; </span><br><span class="line">    <span class="comment">/** Typedef for the base class (&#123;&#123; typedef-type &#125;&#125;) */</span> </span><br><span class="line">    <span class="keyword">typedef</span> AActor Super;</span><br><span class="line">    <span class="comment">/** Typedef for &#123;&#123; typedef-type &#125;&#125;. */</span> </span><br><span class="line">    <span class="keyword">typedef</span> MyActor ThisClass;</span><br><span class="line">    <span class="comment">/** Returns a UClass object representing this class at runtime */</span> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> UClass* <span class="title">StaticClass</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetPrivateStaticClass</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/** Returns the package this class belongs in */</span> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> TCHAR* <span class="title">StaticPackage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Test&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/** Returns the static cast flags for this class */</span> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> EClassCastFlags <span class="title">StaticClassCastFlags</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> CASTCLASS_None; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/** For internal use only; use StaticConstructObject() to create new objects. */</span> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> InSize, EInternal InInternalOnly, UObject* InOuter = </span></span></span><br><span class="line"><span class="params"><span class="function">        (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">StaticAllocateObject</span>(<span class="built_in">StaticClass</span>(), InOuter, InName, InSetFlags); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/** For internal use only; use StaticConstructObject() to create new objects. */</span> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">const</span> <span class="type">size_t</span> InSize, EInternal* InMem )</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)InMem; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里包含了一系列函数、typedef 以及序列化、new 等。</p>
<h3 id="implement_class">IMPLEMENT_CLASS</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IMPLEMENT_CLASS(AMyActor, 1716205458);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a class at startup time.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMPLEMENT_CLASS(TClass, TClassCrc) \</span></span><br><span class="line"><span class="meta">    static TClassCompiledInDefer<span class="string">&lt;TClass&gt;</span> AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \</span></span><br><span class="line"><span class="meta">    UClass* TClass::GetPrivateStaticClass() \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        static UClass* PrivateStaticClass = NULL; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!PrivateStaticClass) \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">            <span class="comment">/* this could be handled with templates, but we want it external to avoid code bloat */</span> \</span></span><br><span class="line"><span class="meta">            GetPrivateStaticClassBody( \</span></span><br><span class="line"><span class="meta">                StaticPackage(), \</span></span><br><span class="line"><span class="meta">                (TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0), \</span></span><br><span class="line"><span class="meta">                PrivateStaticClass, \</span></span><br><span class="line"><span class="meta">                StaticRegisterNatives##TClass, \</span></span><br><span class="line"><span class="meta">                sizeof(TClass), \</span></span><br><span class="line"><span class="meta">                alignof(TClass), \</span></span><br><span class="line"><span class="meta">                (EClassFlags)TClass::StaticClassFlags, \</span></span><br><span class="line"><span class="meta">                TClass::StaticClassCastFlags(), \</span></span><br><span class="line"><span class="meta">                TClass::StaticConfigName(), \</span></span><br><span class="line"><span class="meta">                (UClass::ClassConstructorType)InternalConstructor<span class="string">&lt;TClass&gt;</span>, \</span></span><br><span class="line"><span class="meta">                (UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<span class="string">&lt;TClass&gt;</span>, \</span></span><br><span class="line"><span class="meta">                &amp;TClass::AddReferencedObjects, \</span></span><br><span class="line"><span class="meta">                &amp;TClass::Super::StaticClass, \</span></span><br><span class="line"><span class="meta">                &amp;TClass::WithinClass::StaticClass \</span></span><br><span class="line"><span class="meta">            ); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">        return PrivateStaticClass; \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>
<p>GetPrivateStaticClass (定义在
Class.cpp)，作用是从当前类的信息构造出一个 UClass 单例对象，调用
GetPrivateStaticClassBody 创建 UClass 对象，并保存为 PrivateStaticClass
变量，在 DECLARE_CLASS 展开的 StaticClass
函数中，返回的就是这个对象。</p>
<h3 id="ufuction">UFUCTION</h3>
<p>UHT 扫描代码中所有标记了 UFUCTION 的函数，会生成对应名为
execFUNC_NAME 的中间函数定义（也称作 thunk 函数）。它统一了所有
UFUNCTION
函数调用规则（this/调用参数/函数返回值），并且包裹了真正要执行的函数。</p>
<p>所有 UNFUNCTION 函数注册过程如下：</p>
<ul>
<li>IMPLEMENT_CLASS ：调用 RegisterNativeFunc 注册 UFUNCTION
函数列表，存储到 Class::NativeFunctionLookupTable</li>
<li>Z_Construct_UClass_AMyActor ：创建 UClass 对象，最终调用
Z_Construct_UFunction_AMyActor_GetValue 创建 UFunction 对象。</li>
<li>NewFunction-&gt;Bind() : 生成 UFunction 对象后，要进行 bind，bind 到
Class::NativeFunctionLookupTable 对应名字的函数指针，即
&amp;AMyActor::execGetValue</li>
<li>AddFunctionToFunctionMap ：绑定好的 UFunction 对象会保存在
FuncMap</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// step 1:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::StaticRegisterNativesAMyActor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UClass* Class = AMyActor::<span class="built_in">StaticClass</span>();</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> FNameNativePtrPair Funcs[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;GetValue&quot;</span>, &amp;AMyActor::execGetValue &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;SetValue&quot;</span>, &amp;AMyActor::execSetValue &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    FNativeFunctionRegistrar::<span class="built_in">RegisterFunctions</span>(Class, Funcs, <span class="built_in">UE_ARRAY_COUNT</span>(Funcs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UClass::AddNativeFunction</span><span class="params">(<span class="type">const</span> WIDECHAR* InName, FNativeFuncPtr InPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">new</span>(NativeFunctionLookupTable)<span class="built_in">FNativeFunctionLookup</span>(InFName, InPointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2: 直接看到 Z_Construct_UClass_AMyActor</span></span><br><span class="line"><span class="type">const</span> FClassFunctionLinkInfo Z_Construct_UClass_AMyActor_Statics::FuncInfo[] = &#123;</span><br><span class="line">    &#123; &amp;Z_Construct_UFunction_AMyActor_GetValue, <span class="string">&quot;GetValue&quot;</span> &#125;, <span class="comment">// 4052474662</span></span><br><span class="line">    &#123; &amp;Z_Construct_UFunction_AMyActor_SetValue, <span class="string">&quot;SetValue&quot;</span> &#125;, <span class="comment">// 2571773712</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> UE4CodeGen_Private::FClassParams Z_Construct_UClass_AMyActor_Statics::ClassParams = &#123;</span><br><span class="line">    &amp;AMyActor::StaticClass,</span><br><span class="line">    <span class="string">&quot;Engine&quot;</span>,</span><br><span class="line">    &amp;StaticCppClassTypeInfo,</span><br><span class="line">    DependentSingletons,</span><br><span class="line">    FuncInfo,    <span class="comment">// FunctionLinkArray</span></span><br><span class="line">    Z_Construct_UClass_AMyActor_Statics::PropPointers,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="built_in">UE_ARRAY_COUNT</span>(DependentSingletons),</span><br><span class="line">    <span class="built_in">UE_ARRAY_COUNT</span>(FuncInfo),</span><br><span class="line">    <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AMyActor_Statics::PropPointers),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0x009000A4</span>u,</span><br><span class="line">    <span class="built_in">METADATA_PARAMS</span>(Z_Construct_UClass_AMyActor_Statics::Class_MetaDataParams, </span><br><span class="line">        <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AMyActor_Statics::Class_MetaDataParams))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 ClassParams</span></span><br><span class="line"><span class="function">UClass* <span class="title">Z_Construct_UClass_AMyActor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> UClass* OuterClass = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!OuterClass)</span><br><span class="line">    &#123;</span><br><span class="line">        UE4CodeGen_Private::<span class="built_in">ConstructUClass</span>(OuterClass, Z_Construct_UClass_AMyActor_Statics::ClassParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OuterClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// UObjectGlobals.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConstructUClass</span><span class="params">(UClass*&amp; OutClass, <span class="type">const</span> FClassParams&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// Params.FunctionLinkArray  -&gt; ClassParams.FuncInfo</span></span><br><span class="line">    NewClass-&gt;<span class="built_in">CreateLinkAndAddChildFunctionsToMap</span>(Params.FunctionLinkArray, Params.NumFunctions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Class.cpp</span></span><br><span class="line"><span class="comment">/// Functions-&gt;CreateFuncPtr -&gt; &amp;Z_Construct_UFunction_AMyActor_GetValue</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UClass::CreateLinkAndAddChildFunctionsToMap</span><span class="params">(<span class="type">const</span> FClassFunctionLinkInfo* Functions, uint32 NumFunctions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; NumFunctions; --NumFunctions, ++Functions)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* FuncNameUTF8 = Functions-&gt;FuncNameUTF8;</span><br><span class="line">        UFunction*  Func         = Functions-&gt;<span class="built_in">CreateFuncPtr</span>();</span><br><span class="line"></span><br><span class="line">        Func-&gt;Next = Children;</span><br><span class="line">        Children = Func;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AddFunctionToFunctionMap</span>(Func, <span class="built_in">FName</span>(<span class="built_in">UTF8_TO_TCHAR</span>(FuncNameUTF8)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Functions-&gt;CreateFuncPtr()</span></span><br><span class="line"><span class="comment">// MyActor.gen.cpp</span></span><br><span class="line"><span class="function">UFunction* <span class="title">Z_Construct_UFunction_AMyActor_GetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> UFunction* ReturnFunction = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ReturnFunction)</span><br><span class="line">    &#123;</span><br><span class="line">        UE4CodeGen_Private::<span class="built_in">ConstructUFunction</span>(ReturnFunction, </span><br><span class="line">            Z_Construct_UFunction_AMyActor_GetValue_Statics::FuncParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReturnFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConstructUFunction</span><span class="params">(UFunction*&amp; OutFunction, <span class="type">const</span> FFunctionParams&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UFunction* NewFunction;</span><br><span class="line"></span><br><span class="line">    NewFunction-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3:</span></span><br><span class="line"><span class="comment">// Class.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFunction::Bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UClass* OwnerClass = <span class="built_in">GetOwnerClass</span>();</span><br><span class="line">    FName Name = <span class="built_in">GetFName</span>();</span><br><span class="line">    FNativeFunctionLookup* Found = OwnerClass-&gt;NativeFunctionLookupTable.<span class="built_in">FindByPredicate</span>([=](</span><br><span class="line">        <span class="type">const</span> FNativeFunctionLookup&amp; NativeFunctionLookup)</span><br><span class="line">    &#123; <span class="keyword">return</span> Name == NativeFunctionLookup.Name; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Found)</span><br><span class="line">    &#123;</span><br><span class="line">        Func = Found-&gt;Pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 4:</span></span><br><span class="line"><span class="comment">// Class.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddFunctionToFunctionMap</span><span class="params">(UFunction* Function, FName FuncName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FuncMap.<span class="built_in">Add</span>(FuncName, Function);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find</span></span><br><span class="line"><span class="function">UFunction* <span class="title">UClass::FindFunctionByName</span><span class="params">(FName InName, EIncludeSuperFlag::Type IncludeSuper)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UFunction* Result = FuncMap.<span class="built_in">FindRef</span>(InName);</span><br><span class="line">    <span class="keyword">if</span> (Result == <span class="literal">nullptr</span> &amp;&amp; IncludeSuper == EIncludeSuperFlag::IncludeSuper)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 在基类上查找函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过以上操作后，便可以通过反射来调用 UFUNCTION 函数了</p>
<ul>
<li>首先通过 FindFunctionChecked 获取到函数</li>
<li>在通过调用 ProcessEvent 函数执行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    UFunction* funcSetValue = pMyActor-&gt;<span class="built_in">FindFunctionChecked</span>(<span class="string">&quot;GetValue&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(funcSetValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// struct define in scope</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">funcSetValueParams</span>&#123;int32 InValue;&#125;InsParam;</span><br><span class="line">        InsParam.InValue = <span class="number">123</span>;</span><br><span class="line">        <span class="comment">// call SetHp</span></span><br><span class="line">        <span class="built_in">ProcessEvent</span>(funcSetValue,(<span class="type">void</span>*)(&amp;InsParam));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面继续说 DEFINE_FUNCTION</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_FUNCTION</span>(AMyActor::execSetValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">P_GET_PROPERTY</span>(FIntProperty,Z_Param_InValue);</span><br><span class="line">    P_FINISH;</span><br><span class="line">    P_NATIVE_BEGIN;</span><br><span class="line">    P_THIS-&gt;<span class="built_in">SetValue</span>(Z_Param_InValue);</span><br><span class="line">    P_NATIVE_END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::execSetValue</span><span class="params">( UObject* Context, FFrame&amp; Stack, RESULT_DECL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PropertyType::FIntProperty Z_Param_InValue = PropertyType::<span class="built_in">GetDefaultPropertyValue</span>();</span><br><span class="line">    Stack.<span class="built_in">StepCompiledIn</span>&lt;PropertyType&gt;(&amp;Z_Param_InValue);</span><br><span class="line"></span><br><span class="line">    Stack.Code += !!Stack.Code;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="built_in">SCOPED_SCRIPT_NATIVE_TIMER</span>(ScopedNativeCallTimer);</span><br><span class="line"></span><br><span class="line">    ((ThisClass*)(Context))-&gt;<span class="built_in">SetValue</span>(Z_Param_InValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime/CoreUObject/Public/Script.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Blueprint VM intrinsic return value declaration.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESULT_PARAM Z_Param__Result</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESULT_DECL void*const RESULT_PARAM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RESULT_DECL</span></span><br><span class="line"><span class="type">void</span>*<span class="type">const</span> Z_Param__Result</span><br></pre></td></tr></table></figure>
<h3 id="uproperty">UPROPERTY</h3>
<p>在类内对属性加了 UPROPERTY 的标记，不会在 generated.h
中产生额外的代码，但是它会把它的反射信息代码生成到在 gen.cpp 中。</p>
<p>同样是在</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> UE4CodeGen_Private::FUnsizedIntPropertyParams Z_Construct_UClass_AMyActor_Statics::NewProp_Value = &#123; <span class="string">&quot;Value&quot;</span>, <span class="literal">nullptr</span>, </span><br><span class="line">(EPropertyFlags)<span class="number">0x0040000000000000</span>, UE4CodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative,</span><br><span class="line"> <span class="number">1</span>, <span class="built_in">STRUCT_OFFSET</span>(AMyActor, Value), <span class="built_in">METADATA_PARAMS</span>(Z_Construct_UClass_AMyActor_Statics::NewProp_Value_MetaData, </span><br><span class="line"> <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AMyActor_Statics::NewProp_Value_MetaData)) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> UE4CodeGen_Private::FPropertyParamsBase* <span class="type">const</span> Z_Construct_UClass_AMyActor_Statics::PropPointers[] = &#123;</span><br><span class="line">    (<span class="type">const</span> UE4CodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UClass_AMyActor_Statics::NewProp_Value,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> FCppClassTypeInfoStatic Z_Construct_UClass_AMyActor_Statics::StaticCppClassTypeInfo = &#123;</span><br><span class="line">    TCppClassTypeTraits&lt;AMyActor&gt;::IsAbstract,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> UE4CodeGen_Private::FClassParams Z_Construct_UClass_AMyActor_Statics::ClassParams = &#123;</span><br><span class="line">    &amp;AMyActor::StaticClass,</span><br><span class="line">    <span class="string">&quot;Engine&quot;</span>,</span><br><span class="line">    &amp;StaticCppClassTypeInfo,</span><br><span class="line">    DependentSingletons,</span><br><span class="line">    FuncInfo,</span><br><span class="line">    Z_Construct_UClass_AMyActor_Statics::PropPointers, <span class="comment">/// PropertyArray</span></span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="built_in">UE_ARRAY_COUNT</span>(DependentSingletons),</span><br><span class="line">    <span class="built_in">UE_ARRAY_COUNT</span>(FuncInfo),</span><br><span class="line">    <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AMyActor_Statics::PropPointers),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0x009000A4</span>u,</span><br><span class="line">    <span class="built_in">METADATA_PARAMS</span>(Z_Construct_UClass_AMyActor_Statics::Class_MetaDataParams, </span><br><span class="line">        <span class="built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_AMyActor_Statics::Class_MetaDataParams))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">UClass* <span class="title">Z_Construct_UClass_AMyActor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> UClass* OuterClass = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!OuterClass)</span><br><span class="line">    &#123;</span><br><span class="line">        UE4CodeGen_Private::<span class="built_in">ConstructUClass</span>(OuterClass, Z_Construct_UClass_AMyActor_Statics::ClassParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OuterClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UObjectGlobals.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConstructUClass</span><span class="params">(UClass*&amp; OutClass, <span class="type">const</span> FClassParams&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// Params.FunctionLinkArray  -&gt; ClassParams.FuncInfo</span></span><br><span class="line">    <span class="built_in">ConstructFProperties</span>(NewClass, Params.PropertyArray, Params.NumProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UE4CodeGen_Private</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ConstructFProperty</span><span class="params">(FFieldVariant Outer, <span class="type">const</span> FPropertyParamsBase* <span class="type">const</span>*&amp; PropertyArray, int32&amp; NumProperties)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> FPropertyParamsBase* PropBase = *--PropertyArray;</span><br><span class="line"></span><br><span class="line">        uint32 ReadMore = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        FProperty* NewProp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">switch</span> (PropBase-&gt;Flags &amp; PropertyTypeMask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Unsupported property type</span></span><br><span class="line">                <span class="built_in">check</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> EPropertyGenFlags::Byte:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> EPropertyGenFlags::Int:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> FIntPropertyParams* Prop = (<span class="type">const</span> FIntPropertyParams*)PropBase;</span><br><span class="line">                NewProp = <span class="keyword">new</span> <span class="built_in">FIntProperty</span>(Outer, <span class="built_in">UTF8_TO_TCHAR</span>(Prop-&gt;NameUTF8), Prop-&gt;ObjectFlags, </span><br><span class="line">                    Prop-&gt;Offset, Prop-&gt;PropertyFlags);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_METADATA</span></span><br><span class="line">                MetaDataArray = Prop-&gt;MetaDataArray;</span><br><span class="line">                NumMetaData   = Prop-&gt;NumMetaData;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 SlateUI事件机制</title>
    <url>/post/360e070e/</url>
    <content><![CDATA[<p>最近开发过程中，碰到一个比较奇怪的Bug，同事在场景中创建了个3D
UI，使用的是WidgetComponent组件，然后动态设置widget实例，第一次创建的3D
UI可以正常接收到鼠标事件，通过3D UI进入战斗场景后，第二场战斗的3D
UI界面没法相应事件了，然后我就接住这口锅了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wbp_path = <span class="string">&#x27;/Game/test_3d_ui.test_3d_ui&#x27;</span></span><br><span class="line"><span class="comment"># game.ui: 全局ui管理器</span></span><br><span class="line"><span class="comment"># create_3d_ui:加载WidgetBlueprint，并打开</span></span><br><span class="line">widget = game.ui.create_3d_ui(wbp_path)</span><br><span class="line">widget_comp.set_widget(widget)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">PyObject *<span class="title">py_ue_set_widget</span><span class="params">(ue_PyUObject * self, PyObject * args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ue_py_check</span>(self);</span><br><span class="line"></span><br><span class="line">    PyObject *widget;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_ParseTuple</span>(args, <span class="string">&quot;O&quot;</span>, &amp;widget))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    UWidgetComponent *widget_component = <span class="built_in">ue_py_check_type</span>&lt;UWidgetComponent&gt;(self);</span><br><span class="line">    <span class="keyword">if</span> (!widget_component)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyErr_Format</span>(PyExc_Exception, <span class="string">&quot;uobject is not a UWidgetComponent&quot;</span>);</span><br><span class="line"></span><br><span class="line">    UUserWidget *uwidget = <span class="built_in">ue_py_check_type</span>&lt;UUserWidget&gt;(widget);</span><br><span class="line">    <span class="keyword">if</span> (!uwidget)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyErr_Format</span>(PyExc_Exception, <span class="string">&quot;argument2 is not a APlayerController&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    widget_component-&gt;<span class="built_in">SetWidget</span>(uwidget);</span><br><span class="line"></span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后开始看UE4源码，研究下UE4 SlateUI事件机制 ## 按钮事件调用栈
下图是从Launch.cpp里里的GEngineLoop
Tick调用Windows平台处理事件的代码，最终进入Button代码，响应OnClicked回调的调用栈。
<img src="/images/ue4_event/button_event_statck.png" width=100% height=100% align="middle"/></p>
<h2 id="事件来源">事件来源</h2>
<p>在Windows平台上，鼠标点击，键盘事件都是调用Windows的API，从Windows事件列表中获取的。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Ticks the engine loop </span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Launch\Private\Launch.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EngineTick</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//** line:62 **//</span></span><br><span class="line">    GEngineLoop.<span class="built_in">Tick</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\ApplicationCore\Private\Windows\WindowsPlatformApplicationMisc.cpp</span></span><br><span class="line"><span class="comment"> * windows 消息处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">WinPumpMessages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        MSG Msg;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">PeekMessage</span>(&amp;Msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,PM_REMOVE) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TranslateMessage</span>( &amp;Msg );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//* line:108 *//</span></span><br><span class="line">            <span class="built_in">DispatchMessage</span>( &amp;Msg ); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\ApplicationCore\Private\Windows\WindowsApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">int32 <span class="title">FWindowsApplication::ProcessMessage</span><span class="params">( HWND hwnd, uint32 msg, WPARAM wParam, LPARAM lParam )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedPtr&lt; FWindowsWindow &gt; CurrentNativeEventWindowPtr = <span class="built_in">FindWindowByHWND</span>( Windows, hwnd );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( Windows.<span class="built_in">Num</span>() &amp;&amp; CurrentNativeEventWindowPtr.<span class="built_in">IsValid</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_SYSKEYUP:</span><br><span class="line">            <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_NCMOUSEMOVE:</span><br><span class="line">            <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">            <span class="keyword">case</span> WM_MOUSEWHEEL:</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> WINVER &gt;= 0x0601</span></span><br><span class="line">            <span class="keyword">case</span> WM_TOUCH:</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//** line:1042 **//</span></span><br><span class="line">                    <span class="built_in">DeferMessage</span>( CurrentNativeEventWindowPtr, hwnd, msg, wParam, lParam );</span><br><span class="line">                    <span class="comment">// Handled</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\ApplicationCore\Private\Windows\WindowsApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">int32 <span class="title">FWindowsApplication::ProcessDeferredMessage</span><span class="params">( <span class="type">const</span> FDeferredWindowsMessage&amp; DeferredMessage )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Windows.<span class="built_in">Num</span>() &amp;&amp; DeferredMessage.NativeWindow.<span class="built_in">IsValid</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        HWND hwnd = DeferredMessage.hWND;</span><br><span class="line">        uint32 msg = DeferredMessage.Message;</span><br><span class="line">        WPARAM wParam = DeferredMessage.wParam;</span><br><span class="line">        LPARAM lParam = DeferredMessage.lParam;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONDBLCLK:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONDOWN:</span><br><span class="line">            <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_MBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_RBUTTONUP:</span><br><span class="line">            <span class="keyword">case</span> WM_XBUTTONUP:</span><br><span class="line">                &#123;</span><br><span class="line">                    POINT CursorPoint;</span><br><span class="line">                    CursorPoint.x = <span class="built_in">GET_X_LPARAM</span>(lParam);</span><br><span class="line">                    CursorPoint.y = <span class="built_in">GET_Y_LPARAM</span>(lParam); </span><br><span class="line"></span><br><span class="line">                    <span class="built_in">ClientToScreen</span>(hwnd, &amp;CursorPoint);</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="type">const</span> FVector2D <span class="title">CursorPos</span><span class="params">(CursorPoint.x, CursorPoint.y)</span></span>;</span><br><span class="line"></span><br><span class="line">                    EMouseButtons::Type MouseButton = EMouseButtons::Invalid;</span><br><span class="line">                    <span class="type">bool</span> bDoubleClick = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> bMouseUp = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">switch</span>(msg)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> WM_LBUTTONDBLCLK:</span><br><span class="line">                            bDoubleClick = <span class="literal">true</span>;</span><br><span class="line">                            MouseButton = EMouseButtons::Left;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">                            bMouseUp = <span class="literal">true</span>;</span><br><span class="line">                            MouseButton = EMouseButtons::Left;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">                            MouseButton = EMouseButtons::Left;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="built_in">check</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (bMouseUp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//** line:2183 **//</span></span><br><span class="line">                        <span class="keyword">return</span> MessageHandler-&gt;<span class="built_in">OnMouseUp</span>( MouseButton, CursorPos ) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (bDoubleClick)</span><br><span class="line">                    &#123;</span><br><span class="line">                        MessageHandler-&gt;<span class="built_in">OnMouseDoubleClick</span>( CurrentNativeEventWindowPtr, MouseButton, CursorPos );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        MessageHandler-&gt;<span class="built_in">OnMouseDown</span>( CurrentNativeEventWindowPtr, MouseButton, CursorPos );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
随后代码进入SlateApplication中，对事件进行封装，然后开始找到响应的Widget，调用对应的响应函数，并最终响应事件。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  ==================================</span></span><br><span class="line"><span class="comment">    前面都是从Windows事件队列获取消息</span></span><br><span class="line"><span class="comment">    并对消息进行处理，后面开始进入最难</span></span><br><span class="line"><span class="comment">    的地方了</span></span><br><span class="line"><span class="comment">    ==================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FSlateApplication::OnMouseUp</span><span class="params">( <span class="type">const</span> EMouseButtons::Type Button, <span class="type">const</span> FVector2D CursorPos )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// convert left mouse click to touch event if we are faking it	</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFakingTouchEvents</span>() &amp;&amp; Button == EMouseButtons::Left)</span><br><span class="line">    &#123;</span><br><span class="line">        bIsFakingTouched = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//** line:5305 **//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">OnTouchEnded</span>(PlatformApplication-&gt;Cursor-&gt;<span class="built_in">GetPosition</span>(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FKey Key = <span class="built_in">TranslateMouseButtonToKey</span>( Button );</span><br><span class="line"></span><br><span class="line">    <span class="function">FPointerEvent <span class="title">MouseEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        GetUserIndexForMouse(),</span></span></span><br><span class="line"><span class="params"><span class="function">        CursorPointerIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">        CursorPos,</span></span></span><br><span class="line"><span class="params"><span class="function">        GetLastCursorPos(),</span></span></span><br><span class="line"><span class="params"><span class="function">        PressedMouseButtons,</span></span></span><br><span class="line"><span class="params"><span class="function">        Key,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        PlatformApplication-&gt;GetModifierKeys()</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ProcessMouseButtonUpEvent</span>( MouseEvent );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FSlateApplication::OnTouchEnded</span><span class="params">( <span class="type">const</span> FVector2D&amp; Location, int32 TouchIndex, int32 ControllerId )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedRef&lt;FSlateUser&gt; User = <span class="built_in">GetOrCreateUser</span>(ControllerId);</span><br><span class="line">    <span class="keyword">if</span> (User-&gt;<span class="built_in">IsTouchPointerActive</span>(TouchIndex))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FPointerEvent <span class="title">PointerEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ControllerId,</span></span></span><br><span class="line"><span class="params"><span class="function">            TouchIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">            Location,</span></span></span><br><span class="line"><span class="params"><span class="function">            Location,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="number">0.0f</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//** line:5912 **//</span></span><br><span class="line">        <span class="built_in">ProcessTouchEndedEvent</span>(PointerEvent);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_SLATE_DEBUGGING</span></span><br><span class="line">        <span class="built_in">ensure</span>(!User-&gt;<span class="built_in">IsTouchPointerActive</span>(TouchIndex));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FSlateApplication::ProcessMouseButtonUpEvent</span><span class="params">( <span class="type">const</span> FPointerEvent&amp; MouseEvent )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// An empty widget path is passed in.  As an optimization, one will be generated only if a captured mouse event isn&#x27;t routed</span></span><br><span class="line">    FWidgetPath EmptyPath;</span><br><span class="line">    <span class="comment">//** line:5356 **//</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bHandled = <span class="built_in">RoutePointerUpEvent</span>( EmptyPath, MouseEvent ).<span class="built_in">IsEventHandled</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( bIsCursorUser &amp;&amp; PressedMouseButtons.<span class="built_in">Num</span>() == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        PlatformApplication-&gt;<span class="built_in">SetCapture</span>( <span class="literal">nullptr</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bHandled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">FReply <span class="title">FSlateApplication::RoutePointerUpEvent</span><span class="params">(<span class="type">const</span> FWidgetPath&amp; WidgetsUnderPointer, <span class="type">const</span> FPointerEvent&amp; PointerEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TScopeCounter&lt;int32&gt; <span class="title">BeginInput</span><span class="params">(ProcessingInput)</span></span>;</span><br><span class="line"></span><br><span class="line">    FReply Reply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">    TSharedRef&lt;FSlateUser&gt; SlateUser = <span class="built_in">GetOrCreateUser</span>(PointerEvent);</span><br><span class="line">    TSharedPtr&lt;FDragDropOperation&gt; LocalDragDropContent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SlateUser-&gt;<span class="built_in">HasCapture</span>(PointerEvent.<span class="built_in">GetPointerIndex</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        FWidgetPath MouseCaptorPath = SlateUser-&gt;<span class="built_in">GetCaptorPath</span>(PointerEvent.<span class="built_in">GetPointerIndex</span>(), </span><br><span class="line">            FWeakWidgetPath::EInterruptedPathHandling::Truncate, &amp;PointerEvent);</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">ensureMsgf</span>(MouseCaptorPath.Widgets.<span class="built_in">Num</span>() &gt; <span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;A window had a widget with mouse capture. </span></span><br><span class="line"><span class="string">            That entire window has been dismissed before the mouse up could be processed.&quot;</span>)) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Switch worlds widgets in the current path</span></span><br><span class="line">            <span class="function">FScopedSwitchWorldHack <span class="title">SwitchWorld</span><span class="params">( MouseCaptorPath )</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//** line:4815 **//</span></span><br><span class="line">            Reply =</span><br><span class="line">                FEventRouter::<span class="built_in">Route</span>&lt;FReply&gt;( <span class="keyword">this</span>, FEventRouter::<span class="built_in">FToLeafmostPolicy</span>(MouseCaptorPath), PointerEvent, </span><br><span class="line">                    [<span class="keyword">this</span>]( <span class="type">const</span> FArrangedWidget&amp; TargetWidget, <span class="type">const</span> FPointerEvent&amp; Event )</span><br><span class="line">                &#123;</span><br><span class="line">                    FReply TempReply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">                    <span class="keyword">if</span> (Event.<span class="built_in">IsTouchEvent</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        TempReply = TargetWidget.Widget-&gt;<span class="built_in">OnTouchEnded</span>(TargetWidget.Geometry, Event);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!Event.<span class="built_in">IsTouchEvent</span>() || (!TempReply.<span class="built_in">IsEventHandled</span>() &amp;&amp; <span class="keyword">this</span>-&gt;bTouchFallbackToMouse))</span><br><span class="line">                    &#123;</span><br><span class="line">                        TempReply = TargetWidget.Widget-&gt;<span class="built_in">OnMouseButtonUp</span>( TargetWidget.Geometry, Event );</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> ( Event.<span class="built_in">IsTouchEvent</span>() &amp;&amp; !<span class="built_in">IsFakingTouchEvents</span>() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Generate a Leave event when a touch ends as well, since a </span></span><br><span class="line">                        <span class="comment">// touch can enter a widget and then end inside it</span></span><br><span class="line">                        TargetWidget.Widget-&gt;<span class="built_in">OnMouseLeave</span>(Event);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> TempReply;</span><br><span class="line">                &#125;, ESlateDebuggingInputEvent::MouseButtonUp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!LocalWidgetsUnderPointer.<span class="built_in">IsValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新屏幕坐标区域中的widget</span></span><br><span class="line">            LocalWidgetsUnderPointer = <span class="built_in">LocateWindowUnderMouse</span>(PointerEvent.<span class="built_in">GetScreenSpacePosition</span>(), </span><br><span class="line">                <span class="built_in">GetInteractiveTopLevelWindows</span>(), <span class="literal">false</span>, SlateUser-&gt;<span class="built_in">GetUserIndex</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Route an event based on the Routing Policy.</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> ReplyType, <span class="keyword">typename</span> RoutingPolicyType, <span class="keyword">typename</span> EventType, <span class="keyword">typename</span> FuncType &gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> ReplyType <span class="title">Route</span><span class="params">( FSlateApplication* ThisApplication, RoutingPolicyType RoutingPolicy, EventType EventCopy, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FuncType&amp; Lambda, ESlateDebuggingInputEvent DebuggingInputEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ReplyType Reply = ReplyType::<span class="built_in">Unhandled</span>();</span><br><span class="line">    <span class="type">const</span> FWidgetPath&amp; RoutingPath = RoutingPolicy.<span class="built_in">GetRoutingPath</span>();</span><br><span class="line">    <span class="type">const</span> FWidgetPath* WidgetsUnderCursor = RoutingPolicy.<span class="built_in">GetWidgetsUnderCursor</span>();</span><br><span class="line"></span><br><span class="line">    EventCopy.<span class="built_in">SetEventPath</span>( RoutingPath );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; !Reply.<span class="built_in">IsEventHandled</span>() &amp;&amp; RoutingPolicy.<span class="built_in">ShouldKeepGoing</span>(); RoutingPolicy.<span class="built_in">Next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FWidgetAndPointer&amp; ArrangedWidget = RoutingPolicy.<span class="built_in">GetWidget</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PLATFORM_COMPILER_HAS_IF_CONSTEXPR</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Translate&lt;EventType&gt;::TranslationNeeded())</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">const</span> EventType TranslatedEvent = Translate&lt;EventType&gt;::<span class="built_in">PointerEvent</span>(ArrangedWidget.PointerPosition, EventCopy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//** line:378 **//</span></span><br><span class="line">            Reply = <span class="built_in">Lambda</span>(ArrangedWidget, TranslatedEvent).<span class="built_in">SetHandler</span>(ArrangedWidget.Widget);</span><br><span class="line">            <span class="built_in">ProcessReply</span>(ThisApplication, RoutingPath, Reply, WidgetsUnderCursor, &amp;TranslatedEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Reply = <span class="built_in">Lambda</span>(ArrangedWidget, EventCopy).<span class="built_in">SetHandler</span>(ArrangedWidget.Widget);</span><br><span class="line">            <span class="built_in">ProcessReply</span>(ThisApplication, RoutingPath, Reply, WidgetsUnderCursor, &amp;EventCopy);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">const</span> EventType TranslatedEvent = Translate&lt;EventType&gt;::<span class="built_in">PointerEvent</span>(ArrangedWidget.PointerPosition, EventCopy);</span><br><span class="line">        Reply = <span class="built_in">Lambda</span>(ArrangedWidget, TranslatedEvent).<span class="built_in">SetHandler</span>(ArrangedWidget.Widget);</span><br><span class="line">        <span class="built_in">ProcessReply</span>(ThisApplication, RoutingPath, Reply, WidgetsUnderCursor, &amp;TranslatedEvent);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Reply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\Slate\Private\Framework\Application\SlateApplication.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">FReply <span class="title">FSlateApplication::RoutePointerUpEvent</span><span class="params">(<span class="type">const</span> FWidgetPath&amp; WidgetsUnderPointer, <span class="type">const</span> FPointerEvent&amp; PointerEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch worlds widgets in the current path</span></span><br><span class="line">    <span class="function">FScopedSwitchWorldHack <span class="title">SwitchWorld</span><span class="params">( MouseCaptorPath )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//** line:4815 **//</span></span><br><span class="line">    Reply = FEventRouter::<span class="built_in">Route</span>&lt;FReply&gt;( <span class="keyword">this</span>, FEventRouter::<span class="built_in">FToLeafmostPolicy</span>(MouseCaptorPath), PointerEvent, </span><br><span class="line">        [<span class="keyword">this</span>]( <span class="type">const</span> FArrangedWidget&amp; TargetWidget, <span class="type">const</span> FPointerEvent&amp; Event )</span><br><span class="line">        &#123;</span><br><span class="line">            FReply TempReply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">            <span class="keyword">if</span> (Event.<span class="built_in">IsTouchEvent</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                TempReply = TargetWidget.Widget-&gt;<span class="built_in">OnTouchEnded</span>(TargetWidget.Geometry, Event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Event.<span class="built_in">IsTouchEvent</span>() || (!TempReply.<span class="built_in">IsEventHandled</span>() &amp;&amp; <span class="keyword">this</span>-&gt;bTouchFallbackToMouse))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//** line:4829 **//</span></span><br><span class="line">                TempReply = TargetWidget.Widget-&gt;<span class="built_in">OnMouseButtonUp</span>( TargetWidget.Geometry, Event );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( Event.<span class="built_in">IsTouchEvent</span>() &amp;&amp; !<span class="built_in">IsFakingTouchEvents</span>() )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Generate a Leave event when a touch ends as well, since a </span></span><br><span class="line">                <span class="comment">// touch can enter a widget and then end inside it</span></span><br><span class="line">                TargetWidget.Widget-&gt;<span class="built_in">OnMouseLeave</span>(Event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> TempReply;</span><br><span class="line">        &#125;, ESlateDebuggingInputEvent::MouseButtonUp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\Slate\Private\Widgets\Input\SButton.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">FReply <span class="title">SButton::OnMouseButtonUp</span><span class="params">( <span class="type">const</span> FGeometry&amp; MyGeometry, <span class="type">const</span> FPointerEvent&amp; MouseEvent )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FReply Reply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//** line:304 **//</span></span><br><span class="line">    Reply = <span class="built_in">ExecuteOnClick</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\Slate\Private\Widgets\Input\SButton.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">FReply <span class="title">SButton::ExecuteOnClick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OnClicked.<span class="built_in">IsBound</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//** line:385 **//</span></span><br><span class="line">        FReply Reply = OnClicked.<span class="built_in">Execute</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Reply;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FReply::<span class="built_in">Handled</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\UMG\Private\Components\Button.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">FReply <span class="title">UButton::SlateHandleClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//** line:203 **//</span></span><br><span class="line">    OnClicked.<span class="built_in">Broadcast</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FReply::<span class="built_in">Handled</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="获取响应控件">获取响应控件</h2>
<p>UE4中，为了方便获取鼠标响应控件，会将屏幕区域划分成一个一个区域，然后按照区域，将控件划分到对应的区域中管理，一个控件可能会被划分到多个区域中。例如：1920
* 1080 分辨率会被划分成 15 * 9 个Cell。详细代码参见如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\SlateCore\Private\Input\HittestGrid.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 屏幕分区大小</span></span><br><span class="line"><span class="function"><span class="type">const</span> FVector2D <span class="title">CellSize</span><span class="params">(<span class="number">128.0f</span>, <span class="number">128.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算屏幕分区个数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FHittestGrid::SetHittestArea</span><span class="params">(<span class="type">const</span> FVector2D&amp; HittestPositionInDesktop, <span class="type">const</span> FVector2D&amp; HittestDimensions,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FVector2D&amp; HitestOffsetInWindow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bWasCleared = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the size of the hit test area changes we need to clear it out</span></span><br><span class="line">    <span class="keyword">if</span> (GridSize != HittestDimensions)</span><br><span class="line">    &#123;</span><br><span class="line">        GridSize = HittestDimensions;</span><br><span class="line">        NumCells = <span class="built_in">FIntPoint</span>(FMath::<span class="built_in">CeilToInt</span>(GridSize.X / CellSize.X), FMath::<span class="built_in">CeilToInt</span>(GridSize.Y / CellSize.Y));</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> int32 NewTotalCells = NumCells.X * NumCells.Y;</span><br><span class="line">        <span class="built_in">ClearInternal</span>(NewTotalCells);</span><br><span class="line"></span><br><span class="line">        bWasCleared = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GridOrigin = HittestPositionInDesktop;</span><br><span class="line">    GridWindowOrigin = HitestOffsetInWindow;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bWasCleared;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过屏幕坐标获取对应分割区Cell坐标</span></span><br><span class="line"><span class="function">FIntPoint <span class="title">FHittestGrid::GetCellCoordinate</span><span class="params">(FVector2D Position)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FIntPoint</span>(</span><br><span class="line">        FMath::<span class="built_in">Min</span>(FMath::<span class="built_in">Max</span>(FMath::<span class="built_in">FloorToInt</span>(Position.X / CellSize.X), <span class="number">0</span>), NumCells.X - <span class="number">1</span>),</span><br><span class="line">        FMath::<span class="built_in">Min</span>(FMath::<span class="built_in">Max</span>(FMath::<span class="built_in">FloorToInt</span>(Position.Y / CellSize.Y), <span class="number">0</span>), NumCells.Y - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
HittestGrid 每帧都会刷新，刷新堆栈如下：
<img src="/images/ue4_event/update_hittest_area.png" width=100% height=100% align="middle"/></p>
<p>每帧从SWindow根节点开始绘制，调用SetHittestArea函数，刷新HittestGrid：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">SWindow::PaintWindow</span><span class="params">( <span class="type">double</span> CurrentTime, <span class="type">float</span> DeltaTime, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 更新HittestArea屏幕大小</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> HittestCleared = HittestGrid-&gt;<span class="built_in">SetHittestArea</span>(<span class="built_in">GetPositionInScreen</span>(), <span class="built_in">GetViewportSize</span>());</span><br><span class="line">    <span class="function">FPaintArgs <span class="title">PaintArgs</span><span class="params">(<span class="literal">nullptr</span>, GetHittestGrid(), GetPositionInScreen(), CurrentTime, DeltaTime)</span></span>;</span><br><span class="line">    <span class="function">FSlateInvalidationContext <span class="title">Context</span><span class="params">(OutDrawElements, InWidgetStyle)</span></span>;</span><br><span class="line">    Context.bParentEnabled = bParentEnabled;</span><br><span class="line">    Context.PaintArgs = &amp;PaintArgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始绘制窗口界面</span></span><br><span class="line">    FSlateInvalidationResult Result = <span class="built_in">PaintInvalidationRoot</span>(Context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根节点开始Paint后，会以深度优先方式遍历所有子节点，并调用子节点的Paint函数
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Engine\Source\Runtime\SlateCore\Private\Widgets\SWidget.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">int32 <span class="title">SWidget::Paint</span><span class="params">(<span class="type">const</span> FPaintArgs&amp; Args, <span class="type">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="params"><span class="function">    int32 LayerId, <span class="type">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    OutDrawElements.<span class="built_in">PushPaintingWidget</span>(*<span class="keyword">this</span>, LayerId, PersistentState.CachedElementHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bOutgoingHittestability)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//** line:1344 **//</span></span><br><span class="line">        Args.<span class="built_in">GetHittestGrid</span>().<span class="built_in">AddWidget</span>(MutableThis, <span class="number">0</span>, LayerId, FastPathProxyHandle.<span class="built_in">GetIndex</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Paint the geometry of this widget.</span></span><br><span class="line">    int32 NewLayerId = <span class="built_in">OnPaint</span>(UpdatedArgs, AllottedGeometry, CullingBounds, OutDrawElements, LayerId, </span><br><span class="line">        ContentWidgetStyle, bParentEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后再调用FHittestGrid::AddWidget函数，对每个Widget进行区域划分，将Widget加入对应的Cell中。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FHittestGrid::AddWidget</span><span class="params">(<span class="type">const</span> TSharedRef&lt;SWidget&gt;&amp; InWidget, int32 InBatchPriorityGroup, </span></span></span><br><span class="line"><span class="params"><span class="function">    int32 InLayerId, int32 InSecondarySort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Widget不可见，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!InWidget-&gt;<span class="built_in">GetVisibility</span>().<span class="built_in">IsHitTestVisible</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FGeometry GridSpaceGeometry = InWidget-&gt;<span class="built_in">GetPaintSpaceGeometry</span>();</span><br><span class="line">    GridSpaceGeometry.<span class="built_in">AppendTransform</span>(<span class="built_in">FSlateLayoutTransform</span>(-GridWindowOrigin));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FSlateRect BoundingRect = GridSpaceGeometry.<span class="built_in">GetRenderBoundingRect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Widget最左上角跟最右下角的Cell Index</span></span><br><span class="line">    <span class="comment">// 后面循环将Widget加入到对应的Cell区域</span></span><br><span class="line">    <span class="type">const</span> FIntPoint UpperLeftCell = <span class="built_in">GetCellCoordinate</span>(BoundingRect.<span class="built_in">GetTopLeft</span>());</span><br><span class="line">    <span class="type">const</span> FIntPoint LowerRightCell = <span class="built_in">GetCellCoordinate</span>(BoundingRect.<span class="built_in">GetBottomRight</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bAddWidget)</span><br><span class="line">    &#123;</span><br><span class="line">        int32&amp; WidgetIndex = WidgetMap.<span class="built_in">Add</span>(&amp;*InWidget);</span><br><span class="line">        <span class="keyword">for</span> (int32 XIndex = UpperLeftCell.X; XIndex &lt;= LowerRightCell.X; ++XIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int32 YIndex = UpperLeftCell.Y; YIndex &lt;= LowerRightCell.Y; ++YIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">IsValidCellCoord</span>(XIndex, YIndex))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CellAt</span>(XIndex, YIndex).<span class="built_in">AddIndex</span>(WidgetIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="todo">TODO:</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FWidgetPath <span class="title">FSlateApplication::LocateWidgetInWindow</span><span class="params">(FVector2D ScreenspaceMouseCoordinate, <span class="type">const</span> TSharedRef&lt;SWindow&gt;&amp; Window, <span class="type">bool</span> bIgnoreEnabledStatus, int32 UserIndex)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bAcceptsInput = Window-&gt;<span class="built_in">IsVisible</span>() &amp;&amp; (Window-&gt;<span class="built_in">AcceptsInput</span>() || <span class="built_in">IsWindowHousingInteractiveTooltip</span>(Window));</span><br><span class="line">    <span class="keyword">if</span> (bAcceptsInput &amp;&amp; Window-&gt;<span class="built_in">IsScreenspaceMouseWithin</span>(ScreenspaceMouseCoordinate))</span><br><span class="line">    &#123;</span><br><span class="line">        TArray&lt;FWidgetAndPointer&gt; WidgetsAndCursors = Window-&gt;<span class="built_in">GetHittestGrid</span>().<span class="built_in">GetBubblePath</span>(ScreenspaceMouseCoordinate, <span class="built_in">GetCursorRadius</span>(), bIgnoreEnabledStatus, UserIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FWidgetPath</span>(<span class="built_in">MoveTemp</span>(WidgetsAndCursors));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FWidgetPath</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TArray&lt;FWidgetAndPointer&gt; <span class="title">FHittestGrid::GetBubblePath</span><span class="params">(FVector2D DesktopSpaceCoordinate, <span class="type">float</span> CursorRadius, <span class="type">bool</span> bIgnoreEnabledStatus, int32 UserIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">checkSlow</span>(<span class="built_in">IsInGameThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FVector2D CursorPositionInGrid = DesktopSpaceCoordinate - GridOrigin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WidgetArray.<span class="built_in">Num</span>() &gt; <span class="number">0</span> &amp;&amp; Cells.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FGridTestingParams TestingParams;</span><br><span class="line">        TestingParams.CursorPositionInGrid = CursorPositionInGrid;</span><br><span class="line">        TestingParams.CellCoord = <span class="built_in">GetCellCoordinate</span>(CursorPositionInGrid);</span><br><span class="line">        TestingParams.Radius = <span class="number">0.0f</span>;</span><br><span class="line">        TestingParams.bTestWidgetIsInteractive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First add the exact point test results</span></span><br><span class="line">        <span class="type">const</span> FIndexAndDistance BestHit = <span class="built_in">GetHitIndexFromCellIndex</span>(TestingParams);</span><br><span class="line">        <span class="keyword">if</span> (BestHit.<span class="built_in">IsValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> FWidgetData&amp; BestHitWidgetData = BestHit.<span class="built_in">GetWidgetData</span>();</span><br><span class="line">            <span class="type">const</span> TSharedPtr&lt;SWidget&gt; FirstHitWidget = BestHitWidgetData.<span class="built_in">GetWidget</span>();</span><br><span class="line">            <span class="comment">// Make Sure we landed on a valid widget</span></span><br><span class="line">            <span class="keyword">if</span> (FirstHitWidget.<span class="built_in">IsValid</span>() &amp;&amp; <span class="built_in">IsCompatibleUserIndex</span>(UserIndex, BestHitWidgetData.UserIndex))</span><br><span class="line">            &#123;</span><br><span class="line">                TArray&lt;FWidgetAndPointer&gt; Path;</span><br><span class="line"></span><br><span class="line">                TSharedPtr&lt;SWidget&gt; CurWidget = FirstHitWidget;</span><br><span class="line">                <span class="keyword">while</span> (CurWidget.<span class="built_in">IsValid</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    FGeometry DesktopSpaceGeometry = CurWidget-&gt;<span class="built_in">GetPaintSpaceGeometry</span>();</span><br><span class="line">                    DesktopSpaceGeometry.<span class="built_in">AppendTransform</span>(<span class="built_in">FSlateLayoutTransform</span>(GridOrigin - GridWindowOrigin));</span><br><span class="line"></span><br><span class="line">                    Path.<span class="built_in">Emplace</span>(<span class="built_in">FArrangedWidget</span>(CurWidget.<span class="built_in">ToSharedRef</span>(), DesktopSpaceGeometry), <span class="built_in">TSharedPtr</span>&lt;FVirtualPointerPosition&gt;());</span><br><span class="line">                    CurWidget = CurWidget-&gt;<span class="built_in">Advanced_GetPaintParentWidget</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!Path.<span class="built_in">Last</span>().Widget-&gt;<span class="built_in">Advanced_IsWindow</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">TArray</span>&lt;FWidgetAndPointer&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Algo::<span class="built_in">Reverse</span>(Path);</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> bRemovedDisabledWidgets = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!bIgnoreEnabledStatus)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// @todo It might be more correct to remove all disabled widgets and non-hit testable widgets.  It doesn&#x27;t make sense to have a hit test invisible widget as a leaf in the path</span></span><br><span class="line">                    <span class="comment">// and that can happen if we remove a disabled widget. Furthermore if we did this we could then append custom paths in all cases since the leaf most widget would be hit testable</span></span><br><span class="line">                    <span class="comment">// For backwards compatibility changing this could be risky</span></span><br><span class="line">                    <span class="type">const</span> int32 DisabledWidgetIndex = Path.<span class="built_in">IndexOfByPredicate</span>([](<span class="type">const</span> FArrangedWidget&amp; SomeWidget) &#123; <span class="keyword">return</span> !SomeWidget.Widget-&gt;<span class="built_in">IsEnabled</span>(); &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (DisabledWidgetIndex != INDEX_NONE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        bRemovedDisabledWidgets = <span class="literal">true</span>;</span><br><span class="line">                        Path.<span class="built_in">RemoveAt</span>(DisabledWidgetIndex, Path.<span class="built_in">Num</span>() - DisabledWidgetIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!bRemovedDisabledWidgets &amp;&amp; Path.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (BestHitWidgetData.CustomPath.<span class="built_in">IsValid</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">const</span> TArray&lt;FWidgetAndPointer&gt; BubblePathExtension = BestHitWidgetData.CustomPath.<span class="built_in">Pin</span>()-&gt;<span class="built_in">GetBubblePathAndVirtualCursors</span>(FirstHitWidget-&gt;<span class="built_in">GetTickSpaceGeometry</span>(), DesktopSpaceCoordinate, bIgnoreEnabledStatus);</span><br><span class="line">                        Path.<span class="built_in">Append</span>(BubblePathExtension);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">return</span> Path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TArray</span>&lt;FWidgetAndPointer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">FHittestGrid::FIndexAndDistance <span class="title">FHittestGrid::GetHitIndexFromCellIndex</span><span class="params">(<span class="type">const</span> FGridTestingParams&amp; Params)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//check if the cell coord </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsValidCellCoord</span>(Params.CellCoord))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the cell and sort it </span></span><br><span class="line">        FCollapsedWidgetsArray WidgetIndexes;</span><br><span class="line">        <span class="built_in">GetCollapsedWidgets</span>(WidgetIndexes, Params.CellCoord.X, Params.CellCoord.Y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Consider front-most widgets first for hittesting.</span></span><br><span class="line">        <span class="keyword">for</span> (int32 i = WidgetIndexes.<span class="built_in">Num</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">check</span>(WidgetIndexes[i].<span class="built_in">IsValid</span>());</span><br><span class="line">            <span class="type">const</span> FWidgetData&amp; TestCandidate = WidgetIndexes[i].<span class="built_in">GetWidgetData</span>();</span><br><span class="line">            <span class="type">const</span> TSharedPtr&lt;SWidget&gt; TestWidget = TestCandidate.<span class="built_in">GetWidget</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// When performing a point hittest, accept all hittestable widgets.</span></span><br><span class="line">            <span class="comment">// When performing a hittest with a radius, only grab interactive widgets.</span></span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> bIsValidWidget = TestWidget.<span class="built_in">IsValid</span>() &amp;&amp; (!Params.bTestWidgetIsInteractive || TestWidget-&gt;<span class="built_in">IsInteractable</span>());</span><br><span class="line">            <span class="keyword">if</span> (bIsValidWidget)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> FVector2D WindowSpaceCoordinate = Params.CursorPositionInGrid + GridWindowOrigin;</span><br><span class="line"></span><br><span class="line">                <span class="type">const</span> FGeometry&amp; TestGeometry = TestWidget-&gt;<span class="built_in">GetPaintSpaceGeometry</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> bPointInsideClipMasks = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (WidgetIndexes[i].<span class="built_in">GetCullingRect</span>().<span class="built_in">IsValid</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    bPointInsideClipMasks = WidgetIndexes[i].<span class="built_in">GetCullingRect</span>().<span class="built_in">ContainsPoint</span>(WindowSpaceCoordinate);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bPointInsideClipMasks)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">const</span> TOptional&lt;FSlateClippingState&gt;&amp; WidgetClippingState = TestWidget-&gt;<span class="built_in">GetCurrentClippingState</span>();</span><br><span class="line">                    <span class="keyword">if</span> (WidgetClippingState.<span class="built_in">IsSet</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Solve non-zero radius cursors?</span></span><br><span class="line">                        bPointInsideClipMasks = WidgetClippingState-&gt;<span class="built_in">IsPointInside</span>(WindowSpaceCoordinate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bPointInsideClipMasks)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Compute the render space clipping rect (FGeometry exposes a layout space clipping rect).</span></span><br><span class="line">                    <span class="type">const</span> FSlateRotatedRect WindowOrientedClipRect = <span class="built_in">TransformRect</span>(</span><br><span class="line">                        <span class="built_in">Concatenate</span>(</span><br><span class="line">                            <span class="built_in">Inverse</span>(TestGeometry.<span class="built_in">GetAccumulatedLayoutTransform</span>()),</span><br><span class="line">                            TestGeometry.<span class="built_in">GetAccumulatedRenderTransform</span>()),</span><br><span class="line">                        <span class="built_in">FSlateRotatedRect</span>(TestGeometry.<span class="built_in">GetLayoutBoundingRect</span>())</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">IsOverlappingSlateRotatedRect</span>(WindowSpaceCoordinate, Params.Radius, WindowOrientedClipRect))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// For non-0 radii also record the distance to cursor&#x27;s center so that we can pick the closest hit from the results.</span></span><br><span class="line">                        <span class="type">const</span> <span class="type">bool</span> bNeedsDistanceSearch = Params.Radius &gt; <span class="number">0.0f</span>;</span><br><span class="line">                        <span class="type">const</span> <span class="type">float</span> DistSq = (bNeedsDistanceSearch) ? <span class="built_in">DistanceSqToSlateRotatedRect</span>(WindowSpaceCoordinate, WindowOrientedClipRect) : <span class="number">0.0f</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">FIndexAndDistance</span>(WidgetIndexes[i], DistSq);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FIndexAndDistance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应事件">响应事件</h2>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
        <category>SlateUI</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
        <tag>UMG</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 static 变量 GC 导致闪退问题</title>
    <url>/post/75d9be60/</url>
    <content><![CDATA[<p>最近开发一个 UMG 插件，插件里用到了静态变量，在 UE4
编辑器里运行没有啥问题，然后打了手机包iOS后，运行一段时间后，闪退了，闪退点就是我写的代码里中访问全局变量的时候，使用
UnrealVS 插件在 VS2019 下开启 Window 模式，也出现了类似的闪退问题：</p>
<p>UnrealVS 参数 &gt; "E:.uproject" -game -windowed -log -verbose</p>
<p>闪退代码处：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UMGEXT_API</span> UExtTextBlock : <span class="keyword">public</span> UTextBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> UDataTable* ExtTextStyleSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp 文件</span></span><br><span class="line">UDataTable* UExtTextBlock::ExtTextStyleSet = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UExtTextBlock::EnsureTextDataTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == ExtTextStyleSet || !ExtTextStyleSet-&gt;<span class="built_in">IsValidLowLevel</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ExtTextStyleSet = <span class="built_in">LoadObject</span>&lt;UDataTable&gt;(<span class="literal">nullptr</span>, *DataPath);</span><br><span class="line">        ExtTextStyleSet-&gt;<span class="built_in">AddToRoot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FTextBlockStyle <span class="title">UExtTextBlock::GetTextStyleByName</span><span class="params">(FName StyleName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EnsureTextDataTable</span>();</span><br><span class="line">    FTextBlockStyle Style = FTextBlockStyle::<span class="built_in">GetDefault</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == UExtTextBlock::ExtTextStyleSet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 闪退地方</span></span><br><span class="line">    <span class="keyword">auto</span> RowMap = UExtTextBlock::ExtTextStyleSet-&gt;<span class="built_in">GetRowMap</span>();</span><br><span class="line">    <span class="keyword">if</span>(RowMap.<span class="built_in">Contains</span>(StyleName))</span><br><span class="line">    &#123;</span><br><span class="line">        FRichTextStyleRow* RichTextStyle = (FRichTextStyleRow*)(RowMap[StyleName]);</span><br><span class="line">        Style = RichTextStyle-&gt;TextStyle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Style;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 VS2019 调试闪退点，查看 UExtTextBlock::ExtTextStyleSet
内存，每次都不一样，而且类型对象完全不匹配，所以联想到可能是内存空间被GC，然后之前指向的内存被其他变量占用了，于是去谷歌。</p>
<p>要防止对象被GC，有4种方式：</p>
<ul>
<li>作为成员变量并标记为UPROPERTY()；</li>
<li>创建对象后 AddToRoot() ；（退出游戏时需要RemoveFromRoot()）</li>
<li>FStreamableManager Load资源时，bManageActiveHandle 设置为true；</li>
<li>FGCObjectScopeGuard 在指定代码区域内保持对象；</li>
</ul>
<blockquote>
<p>注意： 一个UObject类型的变量，即使是static，默认也会被GC掉。</p>
</blockquote>
<p>知道了原因，就好解决问题了，于是做了一下修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 插件模块代码 </span></span><br><span class="line"><span class="comment">/// 启动时: 加载创建静态变量，并且将 静态变量加到 Root 上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUMGExtModule::StartupModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogUMGExtModule, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;UMGExtModule StartupModule&quot;</span>));</span><br><span class="line"></span><br><span class="line">    UExtTextBlock::<span class="built_in">EnsureTextDataTable</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 模块卸载时：将静态变量从 Root 拿掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUMGExtModule::ShutdownModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogUMGExtModule, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;UMGExtModule ShutdownModule&quot;</span>));</span><br><span class="line"></span><br><span class="line">    UExtTextBlock::<span class="built_in">ClearTextDataTable</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 对应类的代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UExtTextBlock::EnsureTextDataTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == ExtTextStyleSet || !ExtTextStyleSet-&gt;<span class="built_in">IsValidLowLevel</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ExtTextStyleSet = <span class="built_in">LoadObject</span>&lt;UDataTable&gt;(<span class="literal">nullptr</span>, *DataPath);</span><br><span class="line">        <span class="comment">/// AddToRoot : 防止被 GC</span></span><br><span class="line">        ExtTextStyleSet-&gt;<span class="built_in">AddToRoot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UExtTextBlock::ClearTextDataTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != ExtTextStyleSet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// RemoveFromRoot : 可以 GC 了 </span></span><br><span class="line">        ExtTextStyleSet-&gt;<span class="built_in">RemoveFromRoot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
        <tag>GC</tag>
        <tag>Static</tag>
      </tags>
  </entry>
  <entry>
    <title>UMG源码笔记</title>
    <url>/post/8d8c27a4/</url>
    <content><![CDATA[<p>整理下最近学习UE4 UMG的进度。</p>
<h1 id="umg类视图">1.UMG类视图</h1>
<p>UMG 控件跟Unity
UGUI不太一样，不是所有的控件节点，都能拥有子节点，为了区分这三种控件，整理了下他们基类：
* <strong>UWidget</strong> : 所有UMG
控件的公共基类，不提供增加子节点功能 * <strong>UPanelWidget</strong> :
提供了增加子节点功能，可以有多个子节点 * <strong>UContentWidget</strong>
:
继承于<strong>UPanelWidget</strong>，是<strong>UPanelWidget</strong>的一种特例，只能有一个子节点</p>
<p>UMG常用控件的继承关系如下图所示:</p>
<h2 id="不能有子节点的控件如下">1.1 不能有子节点的控件如下：</h2>
<p>这个类别的控件的公共基类都是<strong>UWidget</strong>，每个UMG控件，都持有一个Slate控件的智能指针。
<img  src=http://www.plantuml.com/plantuml/svg/VPB1Ri8m44Jl-GgVA_45HHo2ggeILL6JmDaas-1YwiesAWZrtyjclH37eHoGipDvCtPSQ-cSgDusdr1xSVxDicgbt45gCPbCPYnaDTc2XBQiMgkc1HzyfB2Ff7CcBhzgARz05zhu1u7_Zzrq3NAtz7PQa7KcNa-q6iYKVpCzpzc6LUTclp6vELvA7Bwn1ebSuofJaxBOIWiDSaN1sZHiyM4caCzZuZyroikDXXAEk56hsgrFOo9N4bNqPOpeFrFCorws40uoHfEIChivmhe5KHRA-PM2drowSLXaI9abbc8TsT4WpWZyFd6OCfB0qktCCOQdbB2qfhNWN2xjw2RwUfhGKn7TUoGwdlb2dip1Ns-lXe-HRveOpztxxwhUefHhK-z2lw6L4R4txHhfs3OQKDz2gmRidUiTn9HC0Y9fTTixzoRSlUR_jOuQ3zgMYkxBu7PSiIoFK8CKtmoU1he5flCtInA2PIGWA8E0CCM0Fm00></p>
<h2 id="可以增加子节点的控件">1.2 可以增加子节点的控件：</h2>
<h3 id="可以有一个子节点控件">1.2.1 可以有一个子节点控件</h3>
<p>有一个子节点的控件继承的父类依次是 <strong>UComponentWidget</strong>
-&gt;
<strong>UPanelWidget</strong>，父类<strong>UComponentWidget</strong>构造函数中设置了不允许多个孩子标记位：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UContentWidget::<span class="built_in">UContentWidget</span>(<span class="type">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">    : <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    bCanHaveMultipleChildren = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
公共基类<strong>UPanelWidget</strong>定义了<strong>AddChild</strong>函数，可以增加对应的子节点：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UPanelSlot* <span class="title">UPanelWidget::AddChild</span><span class="params">(UWidget* Content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Content == <span class="literal">nullptr</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !bCanHaveMultipleChildren &amp;&amp; <span class="built_in">GetChildrenCount</span>() &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Content-&gt;<span class="built_in">RemoveFromParent</span>();</span><br><span class="line"></span><br><span class="line">    EObjectFlags NewObjectFlags = RF_Transactional;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">HasAnyFlags</span>(RF_Transient))</span><br><span class="line">    &#123;</span><br><span class="line">        NewObjectFlags |= RF_Transient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UPanelSlot* PanelSlot = <span class="built_in">NewObject</span>&lt;UPanelSlot&gt;(<span class="keyword">this</span>, <span class="built_in">GetSlotClass</span>(), NAME_None, NewObjectFlags);</span><br><span class="line">    PanelSlot-&gt;Content = Content;</span><br><span class="line">    PanelSlot-&gt;Parent = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    Content-&gt;Slot = PanelSlot;</span><br><span class="line"></span><br><span class="line">    Slots.<span class="built_in">Add</span>(PanelSlot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OnSlotAdded</span>(PanelSlot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InvalidateLayoutAndVolatility</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PanelSlot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中，<strong>GetSlotClass</strong>返回对应控件的<strong>Slot</strong>的类型，在类视图里，带红色方格的标记的，是各自控件<strong>GetSlotClass</strong>返回的<strong>Slot</strong>的类型。Slot会分别指向父节点跟子节点。</p>
<img  src=http://www.plantuml.com/plantuml/svg/VLFBRe905Dtp5RDK6xv0Ow8iN3MQKchItGXNeHAc6SP4Q_hlPUwT5mLbGUREEPp707dDsvPbsyCNv8hTVwCe-wZQ2wzP7ClgLAfuQT4e9wx1aRklYXEea4kevH9-ZrXtxO6VTqekKjfSijSRhUPzcDmyQPDO6lBYRCSRgDDQg1dJztcaaxZDBimmXqSfYmasOube53Gc0j4ijECI4QVkocfz6dhwOTdtbPJyjl36IypQaj5Bbk1pCxO1fVTnd4mj6ZHS5KLILdKn-HzvEZmFochmNjeWdutSfzqVYAs5B41sAfTlhTDxo2ePZYcUbjsv5VWc2T3la5OkCOs1oqKfqPYiunx46F5003rmvJrm38wbXFoy5jTdBeupzB6GTiBrGLn9EEL7-1GDF1DsdA6mWxIo7LmBk-5xl87YLGEIgjHmL0zTG-hGsAB-J-llc7RL3v2L-yN76nhUs5U0XsO8lXdDjjWV>
<h3 id="可以有多个子节点控件">1.2.2 可以有多个子节点控件</h3>
<img  src=http://www.plantuml.com/plantuml/svg/TPDDReCm48NtdCBBX8eJ949AMT1D5IH2itR1JPnQK1adAaMzUx77lmLO8C-yXxytjgWPxdjK7Tzlf1Pe_8sYwetsTynGad1wkOeaDMfKWrVhodkcpOM8oIjj81WRI6E4fkTCy6SX-Bw4PefU1rZjGXb0pfHdngPyILNWbh2ITI96yhsBP0ZRz3E7OPm50kbqCSgwLf1Mvm2RaGhCbM8HmR1G1Flx4vyEdEDXxy2f2jm3wAdAr7SnoecGVLLkjaRrnZmqJNQbhDdyZxoT7mfarRfDoyY7EX4leuaTMiVb3QSTSVl0lUhgwPVsyapg34xbTJh1Hbti1Ee5nxGLO9EN2okO8l4_TwEyT9p-J1anU-w-_TjTu8TUVGjUX42N_A1X3pFekYJ71-4C3-lZ6yCSh1M9r4iBqxN3b3Nlc1vs1UGiSvJL9CmM5cSx3fXpsfYBlN-j89rfZhIQ-bzDOP6oOsX_>
<h2 id="slate控件类视图">1.3 Slate控件类视图</h2>
<p>Slate中除了<strong>SWidget</strong>之外有三个基础类，其他控件都是继承者三个基类。
* <strong>SPanel</strong> : 有多个子节点 * <strong>SLeafWidget</strong>
: 没有子节点 * <strong>SCompoundWidget</strong> : 可以有一个子节点</p>
<img  src=http://www.plantuml.com/plantuml/svg/VP3H2i8W58RlVGfVm2TOx6Om2882YrtBj2Ku7MgBYDwzJO-rZJMlnE_pdF-SMZ7dCAqaRuH7BuJU2D4Jqq9XGaZ-9NNq0adQiHTMiIU84O47Q33nSCWvmE8c5RT2xqh0L1cVu_ISXQ87mQwnvsg07quf2jDsvgxvngUvaaALLBQT4cE8c66yPL1JEs-PrBvWkcTkRSIbysTMN8O6op4lJjXPuaL6Q3BHODnzone1VoRB03zIK2kfkNbirezAMEK7>
<h1 id="umg渲染流程">2 UMG渲染流程</h1>
<p>TODO <img  src=http://www.plantuml.com/plantuml/svg/NOxV2e8m5CRlVGelDT07s4LWfH0OIHPvEzn13wupiP7HqxSvI-fcS7xVdtrUi0hzA5fdAJL8a2lLCtR6klCCzAkgOimyVX37SMXHLagk8UbxYJNNg8YntS37Av9GOq9Ysw8K0z0KBnrchE18sXrBoPuUNAAOMavAwTdsZstWjwYKQYouRcT5DF39Mc8t7-bxkh_inbJ23SXO3xo3ZNekgckVzHplnfC8SI4ar6Z6l41uRm00></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
        <category>SlateUI</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
        <tag>UMG</tag>
      </tags>
  </entry>
  <entry>
    <title>UMG源码笔记2-渲染过程</title>
    <url>/post/2e07afb3/</url>
    <content><![CDATA[<h1 id="umg类视图">1.UMG类视图</h1>
<p>UMG 控件跟Unity
UGUI不太一样，不是所有的控件节点，都能拥有子节点，为了区分这三种控件，整理了下他们基类：
* <strong>UWidget</strong> : 所有UMG
控件的公共基类，不提供增加子节点功能 * <strong>UPanelWidget</strong> :
提供了增加子节点功能，可以有多个子节点 * <strong>UContentWidget</strong>
: 继承于 <strong>UPanelWidget</strong> ，是
<strong>UPanelWidget</strong> 的一种特例，只能有一个子节点</p>
<p>UMG常用控件的继承关系如下图所示:</p>
<p><img src="/images/umg_render/umg_class.png" width=70% height=70% align="center"/></p>
<p><strong>UPanelWidget</strong> 实现了可以增加节点的功能
<strong>AddChild</strong>
，然后提供了是否可以增加多个子节点的标记为，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UPanelSlot* <span class="title">UPanelWidget::AddChild</span><span class="params">(UWidget* Content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Content == <span class="literal">nullptr</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !bCanHaveMultipleChildren &amp;&amp; <span class="built_in">GetChildrenCount</span>() &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Content-&gt;<span class="built_in">RemoveFromParent</span>();</span><br><span class="line"></span><br><span class="line">    EObjectFlags NewObjectFlags = RF_Transactional;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">HasAnyFlags</span>(RF_Transient))</span><br><span class="line">    &#123;</span><br><span class="line">        NewObjectFlags |= RF_Transient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Slot </span></span><br><span class="line">    <span class="comment">// GetSlotClass  : 获取对应节点的Slot类</span></span><br><span class="line"></span><br><span class="line">    UPanelSlot* PanelSlot = <span class="built_in">NewObject</span>&lt;UPanelSlot&gt;(<span class="keyword">this</span>, <span class="built_in">GetSlotClass</span>(), NAME_None, NewObjectFlags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slot-&gt;Content : 子节点</span></span><br><span class="line">    <span class="comment">// Slot-&gt;Parent  : 父节点 </span></span><br><span class="line">    PanelSlot-&gt;Parent = <span class="keyword">this</span>;</span><br><span class="line">    PanelSlot-&gt;Content = Content;</span><br><span class="line"></span><br><span class="line">    Content-&gt;Slot = PanelSlot;</span><br><span class="line"></span><br><span class="line">    Slots.<span class="built_in">Add</span>(PanelSlot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OnSlotAdded</span>(PanelSlot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InvalidateLayoutAndVolatility</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PanelSlot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UContentWidget</strong> 的实现是将
<strong>bCanHaveMultipleChildren</strong> 设置 <strong>false</strong>
，达到只有一个子节点的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UContentWidget::<span class="built_in">UContentWidget</span>(<span class="type">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">    : <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    bCanHaveMultipleChildren = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中， <strong>GetSlotClass</strong> 返回对应控件的
<strong>Slot</strong> 的类型，下面的表格里给出了对应控件的
<strong>Slot</strong> 类型，即 <strong>GetSlotClass</strong> 返回的
<strong>Slot</strong> 的类型。创建后的 <strong>Slot</strong>
对象会分别指向父节点跟子节点。</p>
<table>
<thead>
<tr class="header">
<th>控件</th>
<th>Slot类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UWidget/UPanelWidget/UCheckBox/URetainerBox</td>
<td>UPanelSlot</td>
</tr>
<tr class="even">
<td>USafeZone</td>
<td>USafeZoneSlot</td>
</tr>
<tr class="odd">
<td>USizeBox</td>
<td>USizeBoxSlot</td>
</tr>
<tr class="even">
<td>UBorder</td>
<td>UBorderSlot</td>
</tr>
<tr class="odd">
<td>UButton</td>
<td>UButtonSlot</td>
</tr>
<tr class="even">
<td>UCanvasPanel</td>
<td>UCanvasPanelSlot</td>
</tr>
<tr class="odd">
<td>UHorizontalBox</td>
<td>UHorizontalBoxSlot</td>
</tr>
<tr class="even">
<td>UOverlay</td>
<td>UOverlaySlot</td>
</tr>
<tr class="odd">
<td>UScrollBox</td>
<td>UScrollBoxSlot</td>
</tr>
<tr class="even">
<td>UGridPanel</td>
<td>UGridSlot</td>
</tr>
</tbody>
</table>
<h2 id="slate控件类视图">1.3 Slate控件类视图</h2>
<p><strong>Slate</strong> 中基础类是 <strong>SWidget</strong>
，这是个抽象类，不能实例化，此外还有三个继承 <strong>SWidget</strong>
的基础类，其他控件都是这个三个类的子类型。 * <strong>SPanel</strong> :
有多个子节点，本身是个抽象类，子类需要定义子节点组织方式 *
<strong>SLeafWidget</strong> : 没有子节点，抽象类，子节点需要重写
<strong>Paint</strong> 方法 * <strong>SCompoundWidget</strong> :
可以有一个子节点</p>
<h1>
<img src="/images/umg_render/slate_class.png" width=100% height=100% align="center"/>
</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SCompoundWidget</span> : <span class="keyword">public</span> SWidget</span><br><span class="line">&#123;</span><br><span class="line">    FSimpleSlot ChildSlot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SBoxPanel</span> : <span class="keyword">public</span> SPanel</span><br><span class="line">&#123;</span><br><span class="line">    TPanelChildren&lt;FSlot&gt; Children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SlotType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TPanelChildren</span> : <span class="keyword">public</span> FChildren, <span class="keyword">private</span> TIndirectArray&lt; SlotType &gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>TPanelChildren<FSlot></strong> : 实际上是一个
<strong>Array&lt;SWidget*&gt;</strong> <strong>FSimpleSlot</strong> :
持有一个 <strong>SWidget*</strong></p>
</blockquote>
<h1 id="umg渲染流程">2 UMG渲染流程</h1>
<p>渲染一个SImage的调用栈如下：</p>
<img  src=http://www.plantuml.com/plantuml/svg/ZLDTQy8m57tlhmW-RGF_G1y4TOu9oiGF9WoHp5pRO7OZITHjltwtJUhQhav37vfppxdVkNkuP-rsvsc0YKGOQRsFuxdSxA8Cd2dkeBlVAxdXJcgyQkgYU3Jyz2f50ivU87e62dt2IvI9aKV2VfasablMQZ6N0aQCJjl897NjpXiBnyTa4oxH5HXR_HkUiksdKWbJyybctavvPDxyfSBmReTuv4gAtEzKQnVuTRYYhBgUANsQS9TwIcxDgWZM0bqkb_4BLY2VG5RAGC4784d6V0Sz_Lbb-6Y1CvAMU5qX5YXHEabPVeE8G5dmgcmarD9SEGKKO5RigNG3KvjU9TRqUTX4i-impO8z1QiFPWDZZZp9k8izDGlcyEaE1hfESGktkLvxS9uQu29NrBQaiYbKU6Y43NiHhZtkDcdckSJu8x-ew7FwRT3z8od8GtHWaAkRHFJHU8FXkg9FFIdcbeDHhZaFEuZ3-tdF6EpFMTNQBp6PQ7fANt7SEz3BEQEzmtOBfg7wFFGZTvmM54nIJWWQw4sHIbjke-W7>
<h2 id="fslateapplication-渲染">2.1 FSlateApplication 渲染</h2>
<p>首先介绍下几个关键的类 * UGameEngine : 全局对象
<strong>GEngine</strong> 类 * FSlateApplication :
单例，游戏窗口类负责渲染 <strong>Slate</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局单例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UGameEngine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 游戏窗口句柄</span></span><br><span class="line">    TWeakPtr&lt;<span class="keyword">class</span> <span class="title class_">SWindow</span>&gt; GameViewportWindow;</span><br><span class="line">    <span class="comment">// 游戏视口</span></span><br><span class="line">    UGameViewportClient* GameViewport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏GameInstance对象 ：WorkingCellGameInstance</span></span><br><span class="line">    UGameInstance* GameInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局单例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FSlateApplication</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">FSlateApplication</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存所有窗口</span></span><br><span class="line">    TArray&lt; TSharedRef&lt;SWindow&gt; &gt; SlateWindows;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏加载前闪屏</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPreLoadScreenManager</span></span><br><span class="line">&#123;</span><br><span class="line">    TWeakPtr&lt;<span class="keyword">class</span> <span class="title class_">SWindow</span>&gt; MainWindow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Initialize</span><span class="params">((FSlateRenderer&amp; InSlateRenderer);</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> PassPreLoadScreenWindowBackToGame();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure>
<p><strong>FSlateApplication</strong> 是一个单例类，会在
<strong>FEngineLoop::PreInit</strong> 调用时创建：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function">int32 <span class="title">FEngineLoop::PreInit</span><span class="params">(<span class="type">const</span> TCHAR* CmdLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> int32 rv1 = <span class="built_in">PreInitPreStartupScreen</span>(CmdLine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="function">int32 <span class="title">FEngineLoop::PreInitPreStartupScreen</span><span class="params">(<span class="type">const</span> TCHAR* CmdLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    FSlateApplication::<span class="built_in">Create</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完 <strong>FSlateApplication</strong> 后，接下来会在
<strong>FEngineLoop::PreInitPreStartUpScreen</strong> 函数中调用
<strong>UGameEngine::CreateGameWindow()</strong> 创建游戏窗口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function">TSharedRef&lt;SWindow&gt; <span class="title">UGameEngine::CreateGameWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedRef&lt;SWindow&gt; Window = <span class="built_in">SNew</span>(SWindow);</span><br><span class="line"></span><br><span class="line">    FSlateApplication::<span class="built_in">Get</span>().<span class="built_in">AddWindow</span>( Window, bShowImmediately );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2. 如果有**PreLoadScreenManager**，则会在其初始化函数 **Initialize** </span></span><br><span class="line"><span class="comment">///    的时候创建，并赋值给**MainWindow**</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPreLoadScreenManager::Initialize</span><span class="params">(FSlateRenderer&amp; InSlateRenderer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedRef&lt;SWindow&gt; GameWindow = (GameEngine &amp;&amp; GameEngine-&gt;GameViewportWindow.<span class="built_in">IsValid</span>()) ? </span><br><span class="line">    GameEngine-&gt;GameViewportWindow.<span class="built_in">Pin</span>().<span class="built_in">ToSharedRef</span>() : UGameEngine::<span class="built_in">CreateGameWindow</span>();</span><br><span class="line"></span><br><span class="line">    MainWindow = GameWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3. 然后在**PassPreLoadScreenWindowBackToGame**将窗口</span></span><br><span class="line"><span class="comment">///    赋值给**GameEngine-&gt;GameViewportWindow**</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPreLoadScreenManager::PassPreLoadScreenWindowBackToGame</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GameEngine-&gt;GameViewportWindow = MainWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的 <strong>SWindow</strong>会加到
<strong>FSlateApplication</strong> 的 <strong>SlateWindown</strong>
队列:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TSharedRef&lt;SWindow&gt; <span class="title">FSlateApplication::AddWindow</span><span class="params">( TSharedRef&lt;SWindow&gt; InSlateWindow,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> <span class="type">bool</span> bShowImmediately )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    FSlateWindowHelper::<span class="built_in">ArrangeWindowToFront</span>(SlateWindows, InSlateWindow);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> InSlateWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染时，会遍历 <strong>SlateWindows</strong> 列表，依次渲染每个
<strong>Window</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateApplication::PrivateDrawWindows</span><span class="params">( TSharedPtr&lt;SWindow&gt; DrawOnlyThisWindow )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( TArray&lt; TSharedRef&lt;SWindow&gt; &gt;::TConstIterator <span class="built_in">CurrentWindowIt</span>( SlateWindows ); </span><br><span class="line">        CurrentWindowIt; ++CurrentWindowIt )</span><br><span class="line">    &#123;</span><br><span class="line">        TSharedRef&lt;SWindow&gt; CurrentWindow = *CurrentWindowIt;</span><br><span class="line">        <span class="comment">// Only draw visible windows or in off-screen rendering mode</span></span><br><span class="line">        <span class="keyword">if</span> (bRenderOffScreen || CurrentWindow-&gt;<span class="built_in">IsVisible</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DrawWindowAndChildren</span>( CurrentWindow, DrawWindowArgs );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateApplication::DrawWindowAndChildren</span><span class="params">( <span class="type">const</span> TSharedRef&lt;SWindow&gt;&amp; WindowToDraw, </span></span></span><br><span class="line"><span class="params"><span class="function">    FDrawWindowArgs&amp; DrawWindowArgs )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxLayerId = WindowToDraw-&gt;<span class="built_in">PaintWindow</span>(</span><br><span class="line">        <span class="built_in">GetCurrentTime</span>(),</span><br><span class="line">        <span class="built_in">GetDeltaTime</span>(),</span><br><span class="line">        WindowElementList,</span><br><span class="line">        <span class="built_in">FWidgetStyle</span>(),</span><br><span class="line">        WindowToDraw-&gt;<span class="built_in">IsEnabled</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UGameEngine</strong> 初始化时，还会创建
<strong>UGameViewportClient</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGameEngine::Init</span><span class="params">(IEngineLoop* InEngineLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(GIsClient)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewportClient = <span class="built_in">NewObject</span>&lt;UGameViewportClient&gt;(<span class="keyword">this</span>, GameViewportClientClass);</span><br><span class="line">        ViewportClient-&gt;<span class="built_in">Init</span>(*GameInstance-&gt;<span class="built_in">GetWorldContext</span>(), GameInstance);</span><br><span class="line">        GameViewport = ViewportClient;</span><br><span class="line">        GameInstance-&gt;<span class="built_in">GetWorldContext</span>()-&gt;GameViewport = ViewportClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 游戏中打开的界面**UUserWidget**，都会调用**widiget::AddToViewport()**，将自己挂到**UGameViewportClient**上 -->
<h2 id="swindow-渲染">2.2 SWindow 渲染</h2>
<p><strong>SWindow</strong> 类的组成 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SLATECORE_API</span> SWindow : <span class="keyword">public</span> SCompoundWidget, <span class="keyword">public</span> FSlateInvalidationRoot</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// Slate 事件检测加速类</span></span><br><span class="line">    TUniquePtr&lt;FHittestGrid&gt; HittestGrid;</span><br><span class="line">    SVerticalBox::FSlot* ContentSlot;</span><br><span class="line">    TWeakPtr&lt;SWindow&gt; ParentWindowPtr;</span><br><span class="line">    TArray&lt; TSharedRef&lt;SWindow&gt; &gt; ChildWindows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>SWindow</strong>在初始化时，会在 ChildSlot里增加几个
<strong>SOverlay</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SWindow::ConstructWindowInternals</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ChildSlot</span><br><span class="line">    [</span><br><span class="line">        <span class="built_in">SAssignNew</span>(WindowOverlay, SOverlay)</span><br><span class="line">        .<span class="built_in">Visibility</span>(EVisibility::SelfHitTestInvisible)</span><br><span class="line">        <span class="comment">// window background</span></span><br><span class="line">        + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">        [</span><br><span class="line">            WindowBackgroundImage.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window border</span></span><br><span class="line">        + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">        [</span><br><span class="line">            WindowBorder.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window outline</span></span><br><span class="line">        + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">        [</span><br><span class="line">            WindowOutline.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">        ]</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染时，从 <strong>SlateApplication</strong> 对象调用
<strong>SWindow</strong> 的 <strong>PaintWindow</strong> 方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function">int32 <span class="title">SWindow::PaintWindow</span><span class="params">( <span class="type">double</span> CurrentTime, <span class="type">float</span> DeltaTime, </span></span></span><br><span class="line"><span class="params"><span class="function">    FSlateWindowElementList&amp; OutDrawElements, <span class="type">const</span> FWidgetStyle&amp; InWidgetStyle, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bParentEnabled )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSlateInvalidationResult Result = <span class="built_in">PaintInvalidationRoot</span>(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="function">FSlateInvalidationResult <span class="title">FSlateInvalidationRoot::PaintInvalidationRoot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateInvalidationContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CachedMaxLayerId = <span class="built_in">PaintSlowPath</span>(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3</span></span><br><span class="line"><span class="function">int32 <span class="title">SWindow::PaintSlowPath</span><span class="params">(<span class="type">const</span> FSlateInvalidationContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HittestGrid-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FSlateRect WindowCullingBounds = <span class="built_in">GetClippingRectangleInWindow</span>();</span><br><span class="line">    <span class="type">const</span> int32 LayerId = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> FGeometry WindowGeometry = <span class="built_in">GetWindowGeometryInWindow</span>();</span><br><span class="line"></span><br><span class="line">    int32 MaxLayerId = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    MaxLayerId = <span class="built_in">Paint</span>(*Context.PaintArgs, WindowGeometry, WindowCullingBounds, </span><br><span class="line">        *Context.WindowElementList, LayerId, Context.WidgetStyle,</span><br><span class="line">         Context.bParentEnabled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxLayerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 4. 最终调用到基类 SWidget::Paint 函数</span></span><br><span class="line"><span class="function">int32 <span class="title">SWidget::Paint</span><span class="params">(<span class="type">const</span> FPaintArgs&amp; Args, <span class="type">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="params"><span class="function">    int32 LayerId, <span class="type">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 NewLayerId = <span class="built_in">OnPaint</span>(UpdatedArgs, AllottedGeometry, CullingBounds, </span><br><span class="line">        OutDrawElements, LayerId, ContentWidgetStyle, bParentEnabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 5</span></span><br><span class="line"><span class="function">int32 <span class="title">SWindow::OnPaint</span><span class="params">(<span class="type">const</span> FPaintArgs&amp; Args, <span class="type">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="params"><span class="function">    int32 LayerId, <span class="type">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 MaxLayer = SCompoundWidget::<span class="built_in">OnPaint</span>(Args, AllottedGeometry, MyCullingRect, </span><br><span class="line">        OutDrawElements, LayerId, InWidgetStyle, bParentEnabled);</span><br><span class="line">    <span class="keyword">return</span> MaxLayer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不同的节点的<strong>OnPaint</strong>函数实现不一样
<strong>SCompoundWidget</strong>只有一个子节点，直接调用子节点的Paint函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">SCompoundWidget::OnPaint</span><span class="params">( <span class="type">const</span> FPaintArgs&amp; Args, <span class="type">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, int32 LayerId, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( ArrangedChildren.<span class="built_in">Num</span>() &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">check</span>( ArrangedChildren.<span class="built_in">Num</span>() == <span class="number">1</span> );</span><br><span class="line">        FArrangedWidget&amp; TheChild = ArrangedChildren[<span class="number">0</span>];</span><br><span class="line">       </span><br><span class="line">        int32 Layer = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            Layer = TheChild.Widget-&gt;<span class="built_in">Paint</span>( Args.<span class="built_in">WithNewParent</span>(<span class="keyword">this</span>), </span><br><span class="line">                TheChild.Geometry, MyCullingRect, OutDrawElements, LayerId + <span class="number">1</span>,</span><br><span class="line">                CompoundedWidgetStyle, <span class="built_in">ShouldBeEnabled</span>( bParentEnabled ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Layer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SPanel</strong> 有多个子节点，渲染接口如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int32 ChildIndex = <span class="number">0</span>; ChildIndex &lt; ArrangedChildren.<span class="built_in">Num</span>(); ++ChildIndex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> FArrangedWidget&amp; CurWidget = ArrangedChildren[ChildIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsChildWidgetCulled</span>(MyCullingRect, CurWidget))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> int32 CurWidgetsMaxLayerId = CurWidget.Widget-&gt;<span class="built_in">Paint</span>(NewArgs, </span><br><span class="line">            CurWidget.Geometry, MyCullingRect, OutDrawElements, LayerId,</span><br><span class="line">            InWidgetStyle, bShouldBeEnabled);</span><br><span class="line"></span><br><span class="line">        MaxLayerId = FMath::<span class="built_in">Max</span>(MaxLayerId, CurWidgetsMaxLayerId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终渲染到可渲染的子节点上，例如<strong>SImage</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function">int32 <span class="title">SImage::OnPaint</span><span class="params">( <span class="type">const</span> FPaintArgs&amp; Args, <span class="type">const</span> FGeometry&amp; AllottedGeometry, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, </span></span></span><br><span class="line"><span class="params"><span class="function">    int32 LayerId, <span class="type">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FSlateBrush* ImageBrush = Image.<span class="built_in">GetImage</span>().<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ImageBrush != <span class="literal">nullptr</span>) &amp;&amp; (ImageBrush-&gt;DrawAs != ESlateBrushDrawType::NoDrawType))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> bIsEnabled = <span class="built_in">ShouldBeEnabled</span>(bParentEnabled);</span><br><span class="line">        <span class="type">const</span> ESlateDrawEffect DrawEffects = bIsEnabled ? ESlateDrawEffect::None :</span><br><span class="line">            ESlateDrawEffect::DisabledEffect;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> FLinearColor <span class="title">FinalColorAndOpacity</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            InWidgetStyle.GetColorAndOpacityTint() * </span></span></span><br><span class="line"><span class="params"><span class="function">            ColorAndOpacity.Get().GetColor(InWidgetStyle) * </span></span></span><br><span class="line"><span class="params"><span class="function">            ImageBrush-&gt;GetTint( InWidgetStyle ) )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bFlipForRightToLeftFlowDirection &amp;&amp; GSlateFlowDirection == EFlowDirection::RightToLeft)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> FGeometry FlippedGeometry = AllottedGeometry.<span class="built_in">MakeChild</span></span><br><span class="line">                (<span class="built_in">FSlateRenderTransform</span>(<span class="built_in">FScale2D</span>(<span class="number">-1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">            FSlateDrawElement::<span class="built_in">MakeBox</span>(OutDrawElements, LayerId,</span><br><span class="line">                FlippedGeometry.<span class="built_in">ToPaintGeometry</span>(), ImageBrush, DrawEffects,</span><br><span class="line">                FinalColorAndOpacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            FSlateDrawElement::<span class="built_in">MakeBox</span>(OutDrawElements, LayerId, AllottedGeometry.<span class="built_in">ToPaintGeometry</span>(), </span><br><span class="line">                ImageBrush, DrawEffects, FinalColorAndOpacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LayerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="comment">/// 最后调用 **FSlateDrawElement** 来生成对应的渲染元素</span></span><br><span class="line"><span class="comment">/// FSlateDrawElement::MakeBox -&gt; FSlateDrawElement::MakeBoxInternal</span></span><br><span class="line"><span class="function">FSlateDrawElement&amp; <span class="title">FSlateDrawElement::MakeBoxInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FSlateWindowElementList&amp; ElementList,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 InLayer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FPaintGeometry&amp; PaintGeometry,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateBrush* InBrush,</span></span></span><br><span class="line"><span class="params"><span class="function">    ESlateDrawEffect InDrawEffects,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FLinearColor&amp; InTint</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 记住这个 ElementType，后面还有用到</span></span><br><span class="line">    EElementType ElementType = (InBrush-&gt;DrawAs == ESlateBrushDrawType::Border) ? </span><br><span class="line">        EElementType::ET_Border : EElementType::ET_Box;</span><br><span class="line"></span><br><span class="line">    FSlateDrawElement&amp; Element = ElementList.<span class="built_in">AddUninitialized</span>();</span><br><span class="line">    FSlateBoxPayload&amp; BoxPayload = ElementList.<span class="built_in">CreatePayload</span>&lt;FSlateBoxPayload&gt;(Element);</span><br><span class="line"></span><br><span class="line">    BoxPayload.<span class="built_in">SetTint</span>(InTint);</span><br><span class="line">    BoxPayload.<span class="built_in">SetBrush</span>(InBrush);</span><br><span class="line"></span><br><span class="line">    Element.<span class="built_in">Init</span>(ElementList, ElementType, InLayer, PaintGeometry, InDrawEffects);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<strong>SlateApplication</strong>中的<strong>Renderer</strong>中有专门的渲染buff<strong>DrawBuffer</strong>，调用完OnPaint后都会将自己的渲染数据<strong>Element</strong>添加到
<strong>ElementListd</strong>队列中，给后面合批准备数据。</p>
<h2 id="真正的render">2.3 真正的Render</h2>
<p>下面进入真正的渲染流程了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateApplication::PrivateDrawWindows</span><span class="params">( TSharedPtr&lt;SWindow&gt; DrawOnlyThisWindow )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 这是上面说的，依次 Paint 每个 SWindow  </span></span><br><span class="line">    <span class="keyword">for</span>( TArray&lt; TSharedRef&lt;SWindow&gt; &gt;::TConstIterator <span class="built_in">CurrentWindowIt</span>( SlateWindows ); </span><br><span class="line">        CurrentWindowIt; ++CurrentWindowIt )</span><br><span class="line">    &#123;</span><br><span class="line">        TSharedRef&lt;SWindow&gt; CurrentWindow = *CurrentWindowIt;</span><br><span class="line">        <span class="comment">// Only draw visible windows or in off-screen rendering mode</span></span><br><span class="line">        <span class="keyword">if</span> (bRenderOffScreen || CurrentWindow-&gt;<span class="built_in">IsVisible</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DrawWindowAndChildren</span>( CurrentWindow, DrawWindowArgs );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 开始准备合批，并且生成 render 指令</span></span><br><span class="line">    <span class="comment">/// OutDrawBuffer : 之前所有Slate控件的Element数据都在这里</span></span><br><span class="line">    Renderer-&gt;<span class="built_in">DrawWindows</span>( DrawWindowArgs.OutDrawBuffer );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateRHIRenderer::DrawWindows</span><span class="params">(FSlateDrawBuffer&amp; WindowDrawBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DrawWindows_Private</span>(WindowDrawBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateRHIRenderer::DrawWindows_Private</span><span class="params">(FSlateDrawBuffer&amp; WindowDrawBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// SlateBlush资源合并图集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DoesThreadOwnSlateRendering</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ResourceManager-&gt;<span class="built_in">UpdateTextureAtlases</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 按照 Window 处理 Element 数据</span></span><br><span class="line">    <span class="keyword">for</span> (int32 ListIndex = <span class="number">0</span>; ListIndex &lt; WindowElementLists.<span class="built_in">Num</span>(); ++ListIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        FSlateWindowElementList&amp; ElementList = *WindowElementLists[ListIndex];</span><br><span class="line"></span><br><span class="line">        ElementBatcher-&gt;<span class="built_in">AddElements</span>(ElementList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 4. ElementBatcher 定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FSlateRHIRenderer</span> : <span class="keyword">public</span> FSlateRenderer</span><br><span class="line">&#123;</span><br><span class="line">    TUniquePtr&lt;FSlateElementBatcher&gt; ElementBatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 5 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateElementBatcher::AddElements</span><span class="params">(FSlateWindowElementList&amp; WindowElementList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">AddElementsInternal</span>(WindowElementList.<span class="built_in">GetUncachedDrawElements</span>(), ViewportSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 6. 之前 SImage 用到的 ElementType ET_Box/ET_Border</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EElementType</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    ET_Box,</span><br><span class="line">    ET_DebugQuad,</span><br><span class="line">    ET_Text,</span><br><span class="line">    ET_ShapedText,</span><br><span class="line">    ET_Spline,</span><br><span class="line">    ET_Line,</span><br><span class="line">    ET_Gradient,</span><br><span class="line">    ET_Viewport,</span><br><span class="line">    ET_Border,</span><br><span class="line">    ET_Custom,</span><br><span class="line">    ET_CustomVerts,</span><br><span class="line">    ET_PostProcessPass,</span><br><span class="line">    <span class="comment">/** Total number of draw commands */</span></span><br><span class="line">    ET_Count,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateElementBatcher::AddElementsInternal</span><span class="params">(<span class="type">const</span> FSlateDrawElementArray&amp; DrawElements, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FVector2D&amp; ViewportSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> FSlateDrawElement&amp; DrawElement : DrawElements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Determine what type of element to add</span></span><br><span class="line">        <span class="keyword">switch</span> ( DrawElement.<span class="built_in">GetElementType</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 之前 SImage 用到的 ElementType ET_Box/ET_Border</span></span><br><span class="line">        <span class="keyword">case</span> EElementType::ET_Box:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">SCOPED_NAMED_EVENT_TEXT</span>(<span class="string">&quot;Slate::AddBoxElement&quot;</span>, FColor::Magenta);</span><br><span class="line">            <span class="built_in">STAT</span>(ElementStat_Boxes++);</span><br><span class="line">            DrawElement.<span class="built_in">IsPixelSnapped</span>() ? <span class="built_in">AddBoxElement</span>&lt;ESlateVertexRounding::Enabled&gt;(DrawElement) : </span><br><span class="line">                <span class="built_in">AddBoxElement</span>&lt;ESlateVertexRounding::Disabled&gt;(DrawElement);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EElementType::ET_Border:</span><br><span class="line">        <span class="keyword">case</span> EElementType::ET_Text:</span><br><span class="line"></span><br><span class="line">        <span class="comment">///...</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 7</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;ESlateVertexRounding Rounding&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateElementBatcher::AddBoxElement</span><span class="params">(<span class="type">const</span> FSlateDrawElement&amp; DrawElement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    FSlateRenderBatch&amp; RenderBatch = <span class="built_in">CreateRenderBatch</span>( Layer, <span class="built_in">FShaderParams</span>(), Resource, </span><br><span class="line">        ESlateDrawPrimitive::TriangleList, ESlateShader::Default, InDrawEffects, DrawFlags, </span><br><span class="line">        DrawElement);</span><br><span class="line">    <span class="comment">// Create 9 quads for the box element based on the following diagram</span></span><br><span class="line">    <span class="comment">//     ___LeftMargin    ___RightMargin</span></span><br><span class="line">    <span class="comment">//    /                /</span></span><br><span class="line">    <span class="comment">//  +--+-------------+--+</span></span><br><span class="line">    <span class="comment">//  |  |c1           |c2| ___TopMargin</span></span><br><span class="line">    <span class="comment">//  +--o-------------o--+</span></span><br><span class="line">    <span class="comment">//  |  |             |  |</span></span><br><span class="line">    <span class="comment">//  |  |c3           |c4|</span></span><br><span class="line">    <span class="comment">//  +--o-------------o--+</span></span><br><span class="line">    <span class="comment">//  |  |             |  | ___BottomMargin</span></span><br><span class="line">    <span class="comment">//  +--+-------------+--+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 一共16个顶点数据</span></span><br><span class="line">    RenderBatch.<span class="built_in">AddVertex</span>( FSlateVertex::<span class="built_in">Make</span>&lt;Rounding&gt;( RenderTransform, <span class="built_in">FVector2D</span>( Position.X, Position.Y ),</span><br><span class="line">       LocalSize, DrawScale, <span class="built_in">FVector4</span>(StartUV, Tiling), Tint ) ); <span class="comment">//0</span></span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    RenderBatch.<span class="built_in">AddVertex</span>( FSlateVertex::<span class="built_in">Make</span>&lt;Rounding&gt;( RenderTransform, <span class="built_in">FVector2D</span>( EndPos.X, EndPos.Y ),</span><br><span class="line">       LocalSize, DrawScale, <span class="built_in">FVector4</span>(EndUV, Tiling), Tint ) ); <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Top</span></span><br><span class="line">    RenderBatch.<span class="built_in">AddIndex</span>( IndexStart + <span class="number">0</span> );</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    RenderBatch.<span class="built_in">AddIndex</span>( IndexStart + <span class="number">15</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 8. 所有的Element都会存储Layer Shader参数等信息，添加成待合批数据。</span></span><br><span class="line"><span class="function">FSlateRenderBatch&amp; <span class="title">FSlateElementBatcher::CreateRenderBatch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 Layer, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FShaderParams&amp; ShaderParams,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateShaderResource* InResource,</span></span></span><br><span class="line"><span class="params"><span class="function">    ESlateDrawPrimitive PrimitiveType,</span></span></span><br><span class="line"><span class="params"><span class="function">    ESlateShader ShaderType,</span></span></span><br><span class="line"><span class="params"><span class="function">    ESlateDrawEffect DrawEffects,</span></span></span><br><span class="line"><span class="params"><span class="function">    ESlateBatchDrawFlag DrawFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateDrawElement&amp; DrawElement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FSlateRenderBatch&amp; NewBatch = CurrentCachedElementList</span><br><span class="line">        ? CurrentCachedElementList-&gt;<span class="built_in">AddRenderBatch</span>(Layer, ShaderParams, InResource,</span><br><span class="line">            PrimitiveType, ShaderType, DrawEffects, DrawFlags, DrawElement.<span class="built_in">GetSceneIndex</span>())</span><br><span class="line"></span><br><span class="line">        : BatchData-&gt;<span class="built_in">AddRenderBatch</span>(Layer, ShaderParams, InResource, PrimitiveType, </span><br><span class="line">            ShaderType, DrawEffects, DrawFlags, DrawElement.<span class="built_in">GetSceneIndex</span>());</span><br><span class="line"></span><br><span class="line">    NewBatch.ClippingState = <span class="built_in">ResolveClippingState</span>(DrawElement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewBatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 9. 最后新建合批任务，在新建的线程里进行合批</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateRHIRenderer::DrawWindows_Private</span><span class="params">(FSlateDrawBuffer&amp; WindowDrawBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GIsClient &amp;&amp; !<span class="built_in">IsRunningCommandlet</span>() &amp;&amp; !GUsingNullRHI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ENQUEUE_RENDER_COMMAND</span>(SlateDrawWindowsCommand)(</span><br><span class="line">            [Params, ViewInfo](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/// 10. 切换到渲染线程</span></span><br><span class="line">                Params.Renderer-&gt;<span class="built_in">DrawWindow_RenderThread</span>(RHICmdList, *ViewInfo, </span><br><span class="line">                    *Params.WindowElementList, Params);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 10. 切换到渲染线程</span></span><br><span class="line"><span class="comment">/** Draws windows from a FSlateDrawBuffer on the render thread */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateRHIRenderer::DrawWindow_RenderThread</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList,</span></span></span><br><span class="line"><span class="params"><span class="function">    FViewportInfo&amp; ViewportInfo, FSlateWindowElementList&amp; WindowElementList, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> FSlateDrawWindowCommandParams&amp; DrawCommandParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RenderingPolicy-&gt;<span class="built_in">BuildRenderingBuffers</span>(RHICmdList, BatchData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 11. 创建渲染Buffers </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateRHIRenderingPolicy::BuildRenderingBuffers</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, </span></span></span><br><span class="line"><span class="params"><span class="function">    FSlateBatchData&amp; InBatchData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 12. Slate 数据合批</span></span><br><span class="line">    InBatchData.<span class="built_in">MergeRenderBatches</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 12. Slate 数据合批</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateBatchData::MergeRenderBatches</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (int32 TestIndex = BatchIndex + <span class="number">1</span>; TestIndex &lt; BatchIndices.<span class="built_in">Num</span>(); ++TestIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> TPair&lt;int32, int32&gt;&amp; NextBatchIndexPair = BatchIndices[TestIndex];</span><br><span class="line">        FSlateRenderBatch&amp; TestBatch = RenderBatches[NextBatchIndexPair.Key];</span><br><span class="line">        <span class="keyword">if</span> (TestBatch.<span class="built_in">GetLayer</span>() != CurBatch.<span class="built_in">GetLayer</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// none of the batches will be compatible since we encountered an incompatible layer</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///                                       13. 合批规则</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!TestBatch.bIsMerged &amp;&amp; CurBatch.<span class="built_in">IsBatchableWith</span>(TestBatch))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CombineBatches</span>(CurBatch, TestBatch, FinalVertexData, FinalIndexData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 13. 合批规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBatchableWith</span><span class="params">(<span class="type">const</span> FSlateRenderBatch&amp; Other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        ShaderResource == Other.ShaderResource</span><br><span class="line">        &amp;&amp; DrawFlags == Other.DrawFlags</span><br><span class="line">        &amp;&amp; ShaderType == Other.ShaderType</span><br><span class="line">        &amp;&amp; DrawPrimitiveType == Other.DrawPrimitiveType</span><br><span class="line">        &amp;&amp; DrawEffects == Other.DrawEffects</span><br><span class="line">        &amp;&amp; ShaderParams == Other.ShaderParams</span><br><span class="line">        &amp;&amp; InstanceData == Other.InstanceData</span><br><span class="line">        &amp;&amp; InstanceCount == Other.InstanceCount</span><br><span class="line">        &amp;&amp; InstanceOffset == Other.InstanceOffset</span><br><span class="line">        &amp;&amp; DynamicOffset == Other.DynamicOffset</span><br><span class="line">        &amp;&amp; CustomDrawer == Other.CustomDrawer</span><br><span class="line">        &amp;&amp; SceneIndex == Other.SceneIndex</span><br><span class="line">        &amp;&amp; ClippingState == Other.ClippingState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 14. 合批结束</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateRHIRenderingPolicy::BuildRenderingBuffers</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList,</span></span></span><br><span class="line"><span class="params"><span class="function">    FSlateBatchData&amp; InBatchData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 10/11/12 Draw Element 合批</span></span><br><span class="line">    InBatchData.<span class="built_in">MergeRenderBatches</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 合批结束 开始发送渲染指令</span></span><br><span class="line">    <span class="type">const</span> FSlateVertexArray&amp; FinalVertexData = InBatchData.<span class="built_in">GetFinalVertexData</span>();</span><br><span class="line">    <span class="type">const</span> FSlateIndexArray&amp; FinalIndexData = InBatchData.<span class="built_in">GetFinalIndexData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> int32 NumVertices = FinalVertexData.<span class="built_in">Num</span>();</span><br><span class="line">    <span class="type">const</span> int32 NumIndices = FinalIndexData.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InBatchData.<span class="built_in">GetRenderBatches</span>().<span class="built_in">Num</span>() &gt; <span class="number">0</span> &amp;&amp; NumVertices &gt; <span class="number">0</span> &amp;&amp; NumIndices &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> bShouldShrinkResources = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        RHICmdList.<span class="built_in">EnqueueLambda</span>([</span><br><span class="line">            VertexBuffer = MasterVertexBuffer.VertexBufferRHI.<span class="built_in">GetReference</span>(),</span><br><span class="line">            IndexBuffer = MasterIndexBuffer.IndexBufferRHI.<span class="built_in">GetReference</span>(),</span><br><span class="line">            &amp;InBatchData,</span><br><span class="line">            bAbsoluteIndices</span><br><span class="line">        ](FRHICommandListImmediate&amp; InRHICmdList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_SlateUpdateBufferRTTimeLambda);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Note: Use &quot;Lambda&quot; prefix to prevent clang/gcc warnings of &#x27;-Wshadow&#x27; warning</span></span><br><span class="line">            <span class="type">const</span> FSlateVertexArray&amp; LambdaFinalVertexData = InBatchData.<span class="built_in">GetFinalVertexData</span>();</span><br><span class="line">            <span class="type">const</span> FSlateIndexArray&amp; LambdaFinalIndexData = InBatchData.<span class="built_in">GetFinalIndexData</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> int32 NumBatchedVertices = LambdaFinalVertexData.<span class="built_in">Num</span>();</span><br><span class="line">            <span class="type">const</span> int32 NumBatchedIndices = LambdaFinalIndexData.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">            uint32 RequiredVertexBufferSize = NumBatchedVertices * </span><br><span class="line">                <span class="built_in">sizeof</span>(FSlateVertex);</span><br><span class="line">            uint8* VertexBufferData = (uint8*)InRHICmdList.<span class="built_in">LockVertexBuffer</span>(VertexBuffer, <span class="number">0</span>, </span><br><span class="line">                RequiredVertexBufferSize, RLM_WriteOnly);</span><br><span class="line"></span><br><span class="line">            uint32 RequiredIndexBufferSize = NumBatchedIndices * <span class="built_in">sizeof</span>(SlateIndex);</span><br><span class="line">            uint8* IndexBufferData = (uint8*)InRHICmdList.<span class="built_in">LockIndexBuffer</span>(IndexBuffer, <span class="number">0</span>, </span><br><span class="line">                RequiredIndexBufferSize, RLM_WriteOnly);</span><br><span class="line"></span><br><span class="line">            FMemory::<span class="built_in">Memcpy</span>(VertexBufferData, LambdaFinalVertexData.<span class="built_in">GetData</span>(), RequiredVertexBufferSize);</span><br><span class="line">            FMemory::<span class="built_in">Memcpy</span>(IndexBufferData, LambdaFinalIndexData.<span class="built_in">GetData</span>(), RequiredIndexBufferSize);</span><br><span class="line"></span><br><span class="line">            InRHICmdList.<span class="built_in">UnlockVertexBuffer</span>(VertexBuffer);</span><br><span class="line">            InRHICmdList.<span class="built_in">UnlockIndexBuffer</span>(IndexBuffer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 15.回到渲染线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateRHIRenderer::DrawWindow_RenderThread</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 12. Slate 数据合批</span></span><br><span class="line">    InBatchData.<span class="built_in">MergeRenderBatches</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="type">const</span> uint32 ViewportWidth = (ViewportRT) ? ViewportRT-&gt;<span class="built_in">GetSizeX</span>() :</span><br><span class="line">        ViewportInfo.Width;</span><br><span class="line">    <span class="type">const</span> uint32 ViewportHeight = (ViewportRT) ? ViewportRT-&gt;<span class="built_in">GetSizeY</span>() : </span><br><span class="line">        ViewportInfo.Height;</span><br><span class="line"></span><br><span class="line">    <span class="function">FSlateBackBuffer <span class="title">BackBufferTarget</span><span class="params">(BackBuffer, FIntPoint(ViewportWidth, </span></span></span><br><span class="line"><span class="params"><span class="function">        ViewportHeight))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 16. DrawElements</span></span><br><span class="line">    RenderingPolicy-&gt;<span class="built_in">DrawElements</span></span><br><span class="line">    (</span><br><span class="line">        RHICmdList,</span><br><span class="line">        BackBufferTarget,</span><br><span class="line">        BackBuffer,</span><br><span class="line">        PostProcessBuffer,</span><br><span class="line">        ViewportInfo.bRequiresStencilTest ? ViewportInfo.DepthStencil : EmptyTarget,</span><br><span class="line">        BatchData.<span class="built_in">GetFirstRenderBatchIndex</span>(),</span><br><span class="line">        BatchData.<span class="built_in">GetRenderBatches</span>(),</span><br><span class="line">        RenderParams</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 16. DrawElements</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateRHIRenderingPolicy::DrawElements</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FRHICommandListImmediate&amp; RHICmdList,</span></span></span><br><span class="line"><span class="params"><span class="function">    FSlateBackBuffer&amp; BackBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    FTexture2DRHIRef&amp; ColorTarget,</span></span></span><br><span class="line"><span class="params"><span class="function">    FTexture2DRHIRef&amp; PostProcessTexture,</span></span></span><br><span class="line"><span class="params"><span class="function">    FTexture2DRHIRef&amp; DepthStencilTarget,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 FirstBatchIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TArray&lt;FSlateRenderBatch&gt;&amp; RenderBatches,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FSlateRenderingParams&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (NextRenderBatchIndex != INDEX_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">        VertexBufferPtr = &amp;MasterVertexBuffer;</span><br><span class="line">        IndexBufferPtr = &amp;MasterIndexBuffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// for RHIs that can&#x27;t handle VertexOffset, we need to offset </span></span><br><span class="line">        <span class="comment">// the stream source each time</span></span><br><span class="line">        RHICmdList.<span class="built_in">SetStreamSource</span>(<span class="number">0</span>, VertexBufferPtr-&gt;VertexBufferRHI, </span><br><span class="line">            RenderBatch.VertexOffset * <span class="built_in">sizeof</span>(FSlateVertex));</span><br><span class="line"></span><br><span class="line">        RHICmdList.<span class="built_in">DrawIndexedPrimitive</span>(IndexBufferPtr-&gt;IndexBufferRHI, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">            RenderBatch.NumVertices, RenderBatch.IndexOffset, PrimitiveCount, </span><br><span class="line">            RenderBatch.InstanceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，就完成了Slate的渲染了。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
        <category>SlateUI</category>
        <category>UMG</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
        <tag>UMG</tag>
        <tag>Slate</tag>
      </tags>
  </entry>
  <entry>
    <title>UnrealEnginPython踩坑记录</title>
    <url>/post/637d361d/</url>
    <content><![CDATA[<p>最近项目换成了UE4，脚本用到的是python预研，用到的插件是<a
href="https://github.com/20tab/UnrealEnginePython">UnrealEnginePython</a>，在使用这个插件的过程中踩到几个坑，在这里mark下。</p>
<h2 id="自动导出接口参数不匹配">1. 自动导出接口参数不匹配</h2>
<p>这个bug是同事遇到的，报错的情况很诡异，报错log如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">LogPython: Error xxx/xxx/xxx<span class="variable">.py</span>:<span class="number">27</span> RuntimeWarning: tp_compare didn&#x27;t <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">or</span> -<span class="number">2</span> <span class="keyword">for</span> exception</span><br><span class="line">  ue<span class="variable">.log</span>(<span class="string">&quot;this is a test log&quot;</span> + str(test_dict<span class="variable">.get</span>(<span class="number">10000</span>, None)))</span><br><span class="line">LogPython: Error argument must be <span class="keyword">string</span>, <span class="keyword">not</span> <span class="keyword">int</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>初看这个报错，就找到对应行，结果发现，只是一个对python
dict的取值操作，调用的也是dict类型提供的标准函数。最近项目在折腾python版本的问题，以为是同事修改了python底层C++代码，导致的报错。跟同事py了很久，也没找到头绪，在UnrealEnginePython提供的python
console命令，直接调用这个dict可以正常取值，而且尝试打印这个get函数的地址，代码逻辑输出的地址跟在python
console里输出的是一样的。到这里就陷入了思考了。</p>
<p>中午干饭回来，继续盯log，我偶然发现了个警告</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">LogTemp: Warning: argument is <span class="keyword">not</span> a FText</span><br></pre></td></tr></table></figure>
<p>便在工程里搜索了下，全局只有一个地方打印了这个日志。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function">FText <span class="title">get_value</span><span class="params">(PyObject* py_object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_Parse</span>(py_object, <span class="string">&quot;s&quot;</span>, &amp;str))</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;argument is not a FText&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="built_in">UTF8_TO_TCHAR</span>(str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我断点调试跟踪堆栈发现调用关系如下：</p>
<p><img src="/images/unreal_python_bug/python_stack.png" width=50% height=50% align="center"/></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EXPORT_UOBJECT_FUNC</span>(<span class="string">&quot;set_text&quot;</span>,&amp;UTextBlock::SetText),</span><br></pre></td></tr></table></figure>
<p>UTextBlock::SetText 函数声明如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetText</span><span class="params">(FText InText)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>EXPORT_UOBJECT_FUNC</strong> 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_UOBJECT_FUNC(func_name, func)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    func_name, \</span></span><br><span class="line"><span class="meta">    [](PyObject *self, PyObject *args)\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">        return UePyTemplate::invoke_func((ue_PyUObject *)self, args, func);\</span></span><br><span class="line"><span class="meta">    &#125;,\</span></span><br><span class="line"><span class="meta">    METH_VARARGS, <span class="string">&quot;&quot;</span>\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>R是返回值void T是类型UTextBlock Args是传入的参数 self是调用对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UEPyTemplate.h</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">PyObject *<span class="title">invoke_func</span><span class="params">(ue_PyUObject *self, PyObject * args, R(T::*func)(Args...))</span></span></span><br><span class="line"><span class="function">INVOKE_UOBJECT_FUNC</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INVOKE_UOBJECT_FUNC \</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    UE_PY_CHECK(self);\</span></span><br><span class="line"><span class="meta">    T *uobject = ue_py_check_type<span class="string">&lt;T&gt;</span>(self);\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!uobject)\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">        UClass* uclass = T::StaticClass();\</span></span><br><span class="line"><span class="meta">        FString class_name = uclass-&gt;GetName();\</span></span><br><span class="line"><span class="meta">        return PyErr_Format(PyExc_Exception, <span class="string">&quot;uobject is not %s&quot;</span>, TCHAR_TO_ANSI(*class_name));\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    CHECK_ARGS_COUNT(args, sizeof...(Args));\</span></span><br><span class="line"><span class="meta">    PyObject* ret = ret_type<span class="string">&lt;R&gt;</span>::template call_func_with_args<span class="string">&lt;Args...&gt;</span>(uobject, func, args);\</span></span><br><span class="line"><span class="meta">    return ret;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们到处的这个函数只有一个参数，最终会调用CALL_WITH_1_ARG，参数列表是GET_1_ARG获得的，即:
get_args<Arg1>::value(args, 0);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET_1_ARG auto arg1 = get_args<span class="string">&lt;Arg1&gt;</span>::value(args, 0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_2_ARG GET_1_ARG auto arg2 = get_args<span class="string">&lt;Arg2&gt;</span>::value(args, 1);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_3_ARG GET_2_ARG auto arg3 = get_args<span class="string">&lt;Arg3&gt;</span>::value(args, 2);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_4_ARG GET_3_ARG auto arg4 = get_args<span class="string">&lt;Arg4&gt;</span>::value(args, 3);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_5_ARG GET_4_ARG auto arg5 = get_args<span class="string">&lt;Arg5&gt;</span>::value(args, 4);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_6_ARG GET_5_ARG auto arg6 = get_args<span class="string">&lt;Arg6&gt;</span>::value(args, 5);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_7_ARG GET_6_ARG auto arg7 = get_args<span class="string">&lt;Arg7&gt;</span>::value(args, 6);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_8_ARG GET_7_ARG auto arg8 = get_args<span class="string">&lt;Arg8&gt;</span>::value(args, 7);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_9_ARG GET_8_ARG auto arg9 = get_args<span class="string">&lt;Arg9&gt;</span>::value(args, 8);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_1_ARG arg1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_2_ARG CALL_WITH_1_ARG, arg2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_3_ARG CALL_WITH_2_ARG, arg3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_4_ARG CALL_WITH_3_ARG, arg4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_5_ARG CALL_WITH_4_ARG, arg5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_6_ARG CALL_WITH_5_ARG, arg6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_7_ARG CALL_WITH_6_ARG, arg7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_8_ARG CALL_WITH_7_ARG, arg8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_9_ARG CALL_WITH_8_ARG, arg9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_FUNC_WITH_ARGS(args_count)\</span></span><br><span class="line"><span class="meta">template<span class="string">&lt;DECLARE_##args_count##_ARG, typename T, typename F&gt;</span>\</span></span><br><span class="line"><span class="meta">static PyObject* call_func_with_args(T* uobject, F func, PyObject* args)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    GET_##args_count##_ARG;\</span></span><br><span class="line"><span class="meta">    R ret = (uobject-&gt;*func)(CALL_WITH_##args_count##_ARG);\</span></span><br><span class="line"><span class="meta">    RETURN_VALUE(ret);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_args</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">value</span><span class="params">(PyObject *args, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_args_value</span>&lt;T&gt;(args, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">get_args_value</span><span class="params">(PyObject *args, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyObject* py_object = <span class="built_in">PyTuple_GetItem</span>(args, index);</span><br><span class="line">    <span class="keyword">if</span> (subclass_of&lt;T&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> subclass_of&lt;T&gt;::<span class="built_in">get_subclass_value</span>(py_object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_value</span>&lt;T&gt;(py_object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get_value模板函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">get_value</span><span class="params">(PyObject* py_object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uobject_derived_type&lt;T&gt;::<span class="built_in">get_value</span>(py_object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是特化版本的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function">UNREALENGINEPYTHON_API FText <span class="title">get_value</span><span class="params">(PyObject* py_object)</span></span>;</span><br></pre></td></tr></table></figure>
<p>产生这个警告的界面里，跟FText相关的只有一个调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_text</span>(<span class="params">self, text_str</span>):</span><br><span class="line">    self.uobject.set_text(text_str)</span><br></pre></td></tr></table></figure>
<p>立马打印这text_str，发现传入的参数是int，结合之前FText
get_value特化函数，发现了坑点：
函数将int类型的py_object进行字符串类型匹配解析时，没有做类型判定，强行按照c风格字符串进行解析，解析的结果是会将连续的内存块解析成字符串，并且在第一个'\0'空间停止，之前的内存空间数据都被当成了字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function">FText <span class="title">get_value</span><span class="params">(PyObject* py_object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_Parse</span>(py_object, <span class="string">&quot;s&quot;</span>, &amp;str))</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;argument is not a FText&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="built_in">UTF8_TO_TCHAR</span>(str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是设置字符串的结果，字符串内容都是乱码：
<img src="/images/unreal_python_bug/text_error.png" width=50% height=50% align="center"/>
这就解释清楚，之前的报错，而且报错的地方经常不固定。
找到原因，修改方法就容易了。顺势排查了一波对字符串参数解析的特化版本，防止后面留坑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function">FText <span class="title">get_value</span><span class="params">(PyObject* py_object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyString_Check</span>(py_object))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;argument is not a FText&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_Parse</span>(py_object, <span class="string">&quot;s&quot;</span>, &amp;str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FText::<span class="built_in">FromString</span>(<span class="built_in">FString</span>(<span class="built_in">UTF8_TO_TCHAR</span>(str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ue4引擎代码的坑">2.UE4引擎代码的坑</h2>
<p>做UI的时候需要个屏幕坐标空间转换的函数，在谷歌上找到了个下面这个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UnrealEngine/Engine/Source/Runtime/UMG/Public/Blueprint/SlateBlueprintLibrary.h</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Translates local coordinate of the geometry provided into local viewport coordinates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param PixelPosition The position in the game&#x27;s viewport, usable for line traces and </span></span><br><span class="line"><span class="comment"> * other uses where you need a coordinate in the space of viewport resolution units.</span></span><br><span class="line"><span class="comment"> * @param ViewportPosition The position in the space of other widgets in the viewport.  Like if you wanted</span></span><br><span class="line"><span class="comment"> * to add another widget to the viewport at the same position in viewport space as this location, this is</span></span><br><span class="line"><span class="comment"> * what you would use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintPure, Category=<span class="string">&quot;User Interface|Geometry&quot;</span>, meta=( WorldContext=<span class="string">&quot;WorldContextObject&quot;</span> ))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">LocalToViewport</span><span class="params">(UObject* WorldContextObject, <span class="type">const</span> FGeometry&amp; Geometry, FVector2D LocalCoordinate,</span></span></span><br><span class="line"><span class="params"><span class="function">        FVector2D&amp; PixelPosition, FVector2D&amp; ViewportPosition)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后开始写C++导出接口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">PyObject *<span class="title">py_ue_screen_to_widget_local</span><span class="params">(ue_PyUObject * self, PyObject * args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ue_py_check</span>(self);</span><br><span class="line"></span><br><span class="line">    UWidget* widget = <span class="built_in">ue_py_check_type</span>&lt;UWidget&gt;(self);</span><br><span class="line">    <span class="keyword">if</span> (!widget)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PyErr_Format</span>(PyExc_Exception, <span class="string">&quot;uobject is not a UWidget&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PyArg_ParseTuple</span>(args, <span class="string">&quot;(ff)&quot;</span>, &amp;x, &amp;y))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">    FVector2D local_pos;</span><br><span class="line">    <span class="function">FVector2D <span class="title">screen_pos</span><span class="params">(x, y)</span></span>;</span><br><span class="line">    FGeometry geometry = widget-&gt;<span class="built_in">GetCachedGeometry</span>();</span><br><span class="line">    </span><br><span class="line">    USlateBlueprintLibrary::<span class="built_in">ScreenToWidgetLocal</span>(widget, geometry, screen_pos, local_pos);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">py_ue_new_fvector2d</span>(local_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>screen_pos在进入函数ScreenToWidgetLocal时，数据一切正常，而进入函数后，数据不对了，像没初始化的样子。查了下源码发现FVector2D没有实现拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FVector2D</span>(<span class="type">const</span>&amp; FVector2D)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其实只是开启了编译优化，代码行号跟变量被优化掉了，被优化的变量没法看到具体的内存值。</p>
<h2 id="unreal-c不允许指针指向不完整的类类型踩坑">3. Unreal
C++不允许指针指向不完整的类类型（踩坑）</h2>
<p>新增如下代码时，突然VS2019爆出警告
C++不允许指针指向不完整的类类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// SHierarchyViewItem.cpp</span></span><br><span class="line">NewSlot = Parent-&gt;<span class="built_in">AddChild</span>(Widget);</span><br><span class="line"><span class="keyword">if</span> (Parent-&gt;<span class="built_in">IsA</span>(UCanvasPanel::<span class="built_in">StaticClass</span>()))</span><br><span class="line">&#123;</span><br><span class="line">    UCanvasPanelSlot* NewCanvasSlot = <span class="built_in">Cast</span>&lt;UCanvasPanelSlot&gt;(NewSlot);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> != NewCanvasSlot)</span><br><span class="line">    &#123;</span><br><span class="line">        NewCanvasSlot-&gt;<span class="built_in">SetAnchors</span>(<span class="built_in">FAnchors</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line">        NewCanvasSlot-&gt;<span class="built_in">SetAlignment</span>(<span class="built_in">FVector2D</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入这两个头文件就能解决这个问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CanvasPanel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CanvasPanelSlot.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>UE4</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Github 网站添加谷歌跟百度收录</title>
    <url>/post/fe9b04dd/</url>
    <content><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>Github 上利用 Hexo 建立的博客是无法被搜索引擎搜索到的。Github
本身也不会将信息提交给引擎。所以，为了让博客信息被检索到，我们需要手动将博客网站提交给搜索引擎并验证，实际上就是验证网站是我们自己的。对于
hexo 博客来说，如果你是部署在 GitHub
Pages，那么你是无法被百度收录的，因为 GitHub
禁止了百度爬虫。（不过这里可以介绍下我使用百度站长工具的辛酸泪）</p>
<p>查看自己博客有没有被搜索引擎收录可以在搜索引擎中输入
<strong>site:www.your_website</strong> 来查看是否收录</p>
<div data-align="center">
<p><img src="/images/web_sitemap/site_search_google.png" width="50%" height="50%" /></p>
</div>
<div data-align="center">
<p><img src="/images/web_sitemap/site_search_baidu.png" width="50%" height="50%" /></p>
</div>
<p><a
href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google
引擎验证申请地址</a></p>
<p><a href="https://ziyuan.baidu.com/linksubmit/url">百度
引擎验证申请地址</a></p>
<p><a href="https://www.bing.com/webmasters/">Bing 站长工具</a></p>
<h2 id="sitemap">sitemap</h2>
<p>首先要生成博客的 sitemap，需要安装两个插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p>然后打开博客根目录配置文件 _config.yml，增加如下几行配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 谷歌、百度站点地图生成</span></span><br><span class="line"><span class="attr">Plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-baidu-sitemap</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-sitemap</span></span><br><span class="line"></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure>
<p>接着打开 NexT 主题配置文件，找到 menu 中的 sitemap</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu</span>:</span><br><span class="line">  <span class="attr">sitemap</span>: /sitemap.<span class="property">xml</span> || sitemap</span><br></pre></td></tr></table></figure>
<p>修改本地化文件 themes/next/languages/zh-Hans.yml，添加字段：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">站点地图</span></span><br></pre></td></tr></table></figure>
<div data-align="left">
<p><img src="/images/web_sitemap/next_sitemap.png" width="25%" height="25%" /></p>
</div>
<p>安装完插件后，每次生成时，会自动创建 baidusitemap.xml 和
sitemap.xml</p>
<div data-align="center">
<p><img src="/images/web_sitemap/site_export.png" width="70%" height="70%" /></p>
</div>
<h2 id="谷歌收录">谷歌收录</h2>
<p>谷歌收录比较顺利，直接进入 <a
href="https://search.google.com/search-console">Google Search
Console</a>，用谷歌账号登陆，直接选择 Domain
方式，把你的域名地址填入：</p>
<div data-align="center">
<p><img src="/images/web_sitemap/google_add_web.png" width="50%" height="50%" /></p>
</div>
<p>这时候谷歌会让你验证域名是否属于你，因为我之前已经验证过，这里使用个假域名来测试，复制下面这长串的信息，在你的域名解析服务中增加一行</p>
<div data-align="center">
<p><img src="/images/web_sitemap/google_key.png" width="50%" height="50%" /></p>
</div>
<p>打开你的域名解析，我这里用的是腾讯云：</p>
<ul>
<li>主机记录 ： *</li>
<li>记录类型 ： TXT</li>
<li>主机记录 ： 刚刚复制的长串</li>
</ul>
<div data-align="center">
<p><img src="/images/web_sitemap/google_add_txt.png" width="70%" height="70%" /></p>
</div>
<p>添加完后，过一会再使用 Google Search Console
工具完成验证。验证成功后，找到 Sitemaps 入口</p>
<div data-align="center">
<p><img src="/images/web_sitemap/google_add_sitemap.png" width="25%" height="25%" /></p>
</div>
<p>然后输入你的 sitemap 地址，就可以完成：</p>
<div data-align="center">
<p><img src="/images/web_sitemap/google_add_sitemap_ok.png" width="70%" height="70%" /></p>
</div>
<p>然后就可以用这个工具来查看你网址通过谷歌搜索的点击次数了。</p>
<h2 id="百度收录">百度收录</h2>
<p>百度收录比较坑，这里介绍下我的踩坑经历，首先你需要登陆百度账号，找到<a
href="https://ziyuan.baidu.com/">站长工具</a>。</p>
<div data-align="center">
<p><img src="/images/web_sitemap/baidu_web_index.png" width="80%" height="80%" /></p>
</div>
<p>输入你的网址，这里需要旋转网站协议 http/https，因为我验证过了，这里用
github.io 的网址测试：</p>
<div data-align="center">
<p><img src="/images/web_sitemap/baidu_add_web_url.png" width="80%" height="80%" /></p>
</div>
<p>选完站点领域后，进入验证环节：</p>
<div data-align="center">
<p><img src="/images/web_sitemap/baidu_web_key.png" width="80%" height="80%" /></p>
</div>
<h3 id="文件验证">文件验证</h3>
<p>这个很简单，直接点击<strong>下载验证文件</strong>，然后将文件放到你博客的
Source 根目录，部署的时候，就会一键部署了，但是百度这里会提示 301
报错</p>
<blockquote>
<p>1.检查自己的网站是否加密了？采用https访问，并且http访问全部自动跳转https，这就属于加密，而且出现了跳转问题，所以这时候采用文件验证、html标签验证均会出现301跳转问题</p>
</blockquote>
<blockquote>
<p>2.技术会有某某端口禁止百度抓取，当用户访问此网站时，某端口拒绝后会自动跳转另一端口允许用户访问，所以当你把验证文件放在根目录时，就会出现此类情况；</p>
</blockquote>
<h3 id="html-标签验证">HTML 标签验证</h3>
<p>这里要感谢 NexT 的作者 <a
href="https://github.com/iissnan">iissnan</a>，预留了验证模板，在主题
NexT 目录找到 <strong>baidu_site_verification</strong> 对应的文件</p>
<blockquote>
<p>旧版的 NexT 在 themes/next/layout/_partials/head.swig，新版位置是
themes/next/layout/_partials/head/head.njk</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.yandex_site_verification %&#125;</span><br><span class="line">  &lt;meta name=&quot;yandex-verification&quot; content=&quot;&#123;&#123; theme.yandex_site_verification &#125;&#125;&quot;&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.baidu_site_verification %&#125;</span><br><span class="line">  &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;code-XXXXXXX&quot;&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>同时，记得修改主题目录配置文件 **themes/next/_config.yml**，将
baidu_site_verification 设置为 true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Baidu Webmaster tools verification.</span><br><span class="line"># See: https://ziyuan.baidu.com/site</span><br><span class="line">baidu_site_verification: true</span><br></pre></td></tr></table></figure>
<p>结局跟文件验证一样：301</p>
<h3 id="cname-验证">CNAME 验证</h3>
<p>这个其实是我一开始就尝试过的方式，但是一直提示 DNS
解析不到，我是按着百度提示配置的，将百度站点工具给的key，用 CNAME
的方式添加到域名解析服务中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">code-XXXXXXX.xianlong.site</span><br></pre></td></tr></table></figure>
<p>这里用测试网址来说明百度的验证 Key</p>
<div data-align="center">
<p><img src="/images/web_sitemap/baidu_code.png" width="60%" height="60%" /></p>
</div>
<p>因为其他大佬使用的是阿里云部署的域名解析，域名后缀解析服务器自带，只需要填写域名前的字段
code-XXXXXXX</p>
<div data-align="center">
<p><img src="/images/web_sitemap/baidu_add_key.png" width="40%" height="40%" /></p>
</div>
<p>结果就是这里卡了很久，后面我将域名去掉后配置上去，立马成功了，在这个测试例子中，请使用
<font color=Red><strong>code-fFLAOWlTNn</strong></font>，切记配置的时候主机记录不需要域名后缀部分，坑爹的百度。</p>
<h3 id="上传-sitemap">上传 Sitemap</h3>
<p>接下来就简单了，验证成功后，进入站点管理平台提交 Sitemap 吧</p>
<div data-align="center">
<p><img src="/images/web_sitemap/baidu_add_sitemap.png" width="70%" height="70%" /></p>
</div>
<p>最后可以通过 <a href="https://tool.chinaz.com/baidu/">站长工具</a>
查询收录情况。</p>
<h2 id="bing-收录">Bing 收录</h2>
<p>Bing 收录配置也比较简单，使用微软账号登陆后，可以直接从 Google
中导入你的网站，非常好用，收录也比较快。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
</search>
