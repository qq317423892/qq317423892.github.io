<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#e7ddc8" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#181c27" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/./images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/./images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/./images/favicon-16x16-next.png"><link rel="mask-icon" href="/./images/safari-pinned-tab-next.svg" color="#e7ddc8"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=LXGW:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLong+Cang:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.xianlongok.site","root":"/","images":"/blog/images/","scheme":"Gemini","darkmode":true,"version":"8.17.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":null,"post_body":null,"coll_header":null,"sidebar":"fadeInDown"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="FSR 技术原理及应用 FidelityFX-FSR 1.0（FidelityFX Super Resolution）是 AMD 开源的超分算法，这个算法不像 NVIDIA 的大力水手（DLSS）使用了机器学习算法，总体来说是对边缘进行锐化后的图像放大思想，效果上没有非常逆天，但是扩展性高，适用于各种显卡平台，且开销低1（这篇文章里说用到 17 &#x3D; 12 + 5 次采样）  上采样跟下采样  *"><meta property="og:type" content="article"><meta property="og:title" content="FSR 技术原理"><meta property="og:url" content="https://www.xianlongok.site/post/30ae96f7/index.html"><meta property="og:site_name" content="十三"><meta property="og:description" content="FSR 技术原理及应用 FidelityFX-FSR 1.0（FidelityFX Super Resolution）是 AMD 开源的超分算法，这个算法不像 NVIDIA 的大力水手（DLSS）使用了机器学习算法，总体来说是对边缘进行锐化后的图像放大思想，效果上没有非常逆天，但是扩展性高，适用于各种显卡平台，且开销低1（这篇文章里说用到 17 &#x3D; 12 + 5 次采样）  上采样跟下采样  *"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/fsr_scale.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/fsr_need.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/fsr_pipline.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/mip_bias.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/fsr_src.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/cs_split.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/sample_mid.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/scale_b.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/sobe.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/lanczos2.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/lw.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/edge_type.jpg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/feture_nerbor.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/x_w.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/get_pixel.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/f_group.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/f_bl.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/feture_nerbor.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/dir.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/f_rotate_2.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/rcas.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/rcas_w.svg"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/sample_mid.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/scale_b.png"><meta property="og:image" content="https://www.xianlongok.site/images/amd_fsr/scale_fsr.png"><meta property="article:published_time" content="2023-10-27T01:01:22.000Z"><meta property="article:modified_time" content="2023-10-27T02:58:43.181Z"><meta property="article:author" content="小贤"><meta property="article:tag" content="FSR"><meta property="article:tag" content="AMD"><meta property="article:tag" content="FidelityFX-FSR"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.xianlongok.site/images/amd_fsr/fsr_scale.png"><link rel="canonical" href="https://www.xianlongok.site/post/30ae96f7/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.xianlongok.site/post/30ae96f7/","path":"post/30ae96f7/","title":"FSR 技术原理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>FSR 技术原理 | 十三</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-2Y4JGXG8FG"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2Y4JGXG8FG","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><link rel="dns-prefetch" href="https://www.xianlongok.work"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">十三</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">安心学技术</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fas fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fas fa-splotch fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-tools"><a href="/tools/" rel="section"><i class="fas fa-wrench fa-fw"></i>工具</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fas fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fas fa-book fa-fw"></i>留言板</a></li><li class="menu-item menu-item-novelai"><a href="/NovelAI/" rel="section"><i class="fas fa-tachometer fa-fw"></i>NovelAI</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#fsr-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">FSR 技术原理及应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E9%87%87%E6%A0%B7%E8%B7%9F%E4%B8%8B%E9%87%87%E6%A0%B7"><span class="nav-number">2.</span> <span class="nav-text">上采样跟下采样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fsr-%E6%B5%81%E7%A8%8B%E8%B7%9F%E7%AE%80%E4%BB%8B"><span class="nav-number">3.</span> <span class="nav-text">FSR 流程跟简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fsr-%E7%AE%A1%E7%BA%BF"><span class="nav-number">3.1.</span> <span class="nav-text">FSR 管线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fsr-%E4%BB%A3%E7%A0%81%E7%BB%84%E6%88%90"><span class="nav-number">3.1.1.</span> <span class="nav-text">FSR 代码组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dx12-%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">DX12 下的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fsr-%E8%B6%85%E5%88%86%E9%83%A8%E5%88%86"><span class="nav-number">4.</span> <span class="nav-text">FSR 超分部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#easuedge-adaptive-spatial-upsamping"><span class="nav-number">4.1.</span> <span class="nav-text">EASU（Edge Adaptive Spatial Upsamping）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%BC%98%E8%B7%9F%E9%9D%9E%E8%BE%B9%E7%BC%98%E7%9A%84%E4%B8%8A%E9%87%87%E6%A0%B7"><span class="nav-number">4.1.1.</span> <span class="nav-text">边缘跟非边缘的上采样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lanczos2-%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.2.</span> <span class="nav-text">Lanczos2 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%BC%98%E7%89%B9%E5%BE%81"><span class="nav-number">4.1.3.</span> <span class="nav-text">边缘特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%BC%98%E7%89%B9%E5%BE%81-feature-%E8%B7%9F%E5%8F%98%E9%87%8F-omega"><span class="nav-number">4.1.4.</span> <span class="nav-text">边缘特征 \(Feature\) 跟变量 \(\omega\)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#feature-%E8%8E%B7%E5%BE%97"><span class="nav-number">4.1.5.</span> <span class="nav-text">\(Feature\) 获得</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A2%AF%E5%BA%A6"><span class="nav-number">4.1.6.</span> <span class="nav-text">梯度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%87%E6%A0%B7%E9%A2%9C%E8%89%B2%E5%80%BC"><span class="nav-number">4.1.7.</span> <span class="nav-text">采样颜色值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rcasrobust-contrast-adaptive-sharpening"><span class="nav-number">4.2.</span> <span class="nav-text">RCAS（Robust Contrast Adaptive Sharpening）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD"><span class="nav-number">5.</span> <span class="nav-text">后续</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fsr-1.0"><span class="nav-number">5.1.</span> <span class="nav-text">FSR 1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsr-2.0"><span class="nav-number">5.2.</span> <span class="nav-text">FSR 2.0</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="小贤" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">小贤</p><div class="site-description" itemprop="description">Watch and learn, your magic is mine!</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">37</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/qq317423892" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qq317423892" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="mailto:xianlongok@163.com" title="E-Mail → mailto:xianlongok@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://scorpioq.github.io/" title="https:&#x2F;&#x2F;scorpioq.github.io&#x2F;" rel="noopener" target="_blank">ScorpioQ</a></li><li class="links-of-blogroll-item"><a href="https://www.cnblogs.com/lastkiss/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lastkiss&#x2F;" rel="noopener" target="_blank">邪妖怪のBlog</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.xianlongok.site/post/30ae96f7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="小贤"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="十三"><meta itemprop="description" content="Watch and learn, your magic is mine!"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="FSR 技术原理 | 十三"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">FSR 技术原理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-10-27 09:01:22" itemprop="dateCreated datePublished" datetime="2023-10-27T09:01:22+08:00">2023-10-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Graphics/" itemprop="url" rel="index"><span itemprop="name">Graphics</span></a> </span></span><span id="/post/30ae96f7/" class="post-meta-item leancloud_visitors" data-flag-title="FSR 技术原理" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/post/30ae96f7/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/post/30ae96f7/" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>10 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="fsr-技术原理及应用">FSR 技术原理及应用</h2><p>FidelityFX-FSR 1.0（FidelityFX Super Resolution）是 AMD 开源的超分算法，这个算法不像 NVIDIA 的大力水手（DLSS）使用了机器学习算法，总体来说是对边缘进行锐化后的图像放大思想，效果上没有非常逆天，但是扩展性高，适用于各种显卡平台，且开销低 <sup><a href="#ref-anchor-1">1</a></sup>（这篇文章里说用到 <strong>17 = 12 + 5</strong> 次采样）</p><h2 id="上采样跟下采样">上采样跟下采样</h2><ul><li>上采样：原先有一张小尺寸的纹理，然后我们将这个纹理放大到大尺寸中，然后使用采样方法（例如双线线性插值）进行填充。</li><li>下采样：原先有一张大尺寸的纹理，然后将这个纹理缩小到一个小尺寸中。</li></ul><h2 id="fsr-流程跟简介">FSR 流程跟简介</h2><p>AMD 官方文档 <sup><a href="#ref-anchor-2">2</a></sup> 给出了几个缩放比例，以及对应分辨率超分后得到的输出分辨率，缩放比例越多，性能提升越多，但同时画质会有所降低，如下图所示：</p><div data-align="center"><p><img data-src="/images/amd_fsr/fsr_scale.png" width="80%" height="80%"></p></div><h3 id="fsr-管线">FSR 管线</h3><p>AMD <a target="_blank" rel="noopener" href="https://github.com/GPUOpen-Effects/FidelityFX-FSR/blob/master/docs/FidelityFX-FSR-Overview-Integration.pdf">官方文档</a>中给出了 FSR 使用前提：</p><div data-align="center"><p><img data-src="/images/amd_fsr/fsr_need.png" width="80%" height="80%"></p></div><ul><li>进行 FSR 之前，图像必须已经是做过抗锯齿后的，因此 FSR 必须在 TAA，MSAA， Tone maping 后面。</li><li>图像中的像素值必须是标准化的，像素值范围在 [0-1]</li><li>渲染得到的图像必须要要使用负的 Mip 修正来增加图像细节</li><li>图像没有噪声</li></ul><p>下图是官方给的 FSR 的管线图：</p><div data-align="center"><p><img data-src="/images/amd_fsr/fsr_pipline.png" width="80%" height="80%"></p></div><div class="note info">超分前，渲染分辨率是比较小的，因此渲染时会使用比较高级别的 mipmap 贴图，因此为了提高图像细节，可以根据超分比例增加 mipmap 偏移），下面是对应缩放比例下 MIP bias 偏移值对照表。 <span class="math inline">\(MIP bias = -\log2(ScaleFactor)\)</span><div data-align="center"><p><img data-src="/images/amd_fsr/mip_bias.png" width="50%" height="50%"></p></div></div><h4 id="fsr-代码组成">FSR 代码组成</h4><p>FSR 代码很简单，主要包含 一个 Shader 文件以及两个 C++/Shader 用到的 .h 头文件</p><div data-align="center"><p><img data-src="/images/amd_fsr/fsr_src.png" width="25%" height="25%"></p></div><h4 id="dx12-下的实现">DX12 下的实现</h4><p>可以下载 <a target="_blank" rel="noopener" href="https://github.com/GPUOpen-Effects/FidelityFX-FSR.git">FidelityFX-FSR 源码</a>，按照文档安装环境 CMake 后，执行对应的批处理，生成对应的 DX12 或者 Vulkan（需要安装 Vulkan DK） 工程，然后点击对应的工程编译生成示例工程，官方工程里是在 TAA，Tone mapping 之后增加一个 FSR 流程，然后使用 Compute Shader 来做超采。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// FidelityFX-FSR\sample\src\DX12\SampleRenderer.cpp</span>
<span class="token keyword">void</span> <span class="token class-name">SampleRenderer</span><span class="token double-colon punctuation">::</span><span class="token function">OnRender</span><span class="token punctuation">(</span><span class="token keyword">int</span> displayWidth<span class="token punctuation">,</span> <span class="token keyword">int</span> displayHeight<span class="token punctuation">,</span> 
    State <span class="token operator">*</span>pState<span class="token punctuation">,</span> SwapChain <span class="token operator">*</span>pSwapChain<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// TAA</span>
    <span class="token comment">// Tone mapping</span>
    m_FSR<span class="token punctuation">.</span><span class="token function">Upscale</span><span class="token punctuation">(</span>pCmdLst2<span class="token punctuation">,</span> displayWidth<span class="token punctuation">,</span> displayHeight<span class="token punctuation">,</span> pState<span class="token punctuation">,</span> 
        <span class="token operator">&amp;</span>m_ConstantBufferRing<span class="token punctuation">,</span> hdr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>m_FSR</strong> 创建的时候会加载 FSR_Pass.hlsl 并编译 Shader，这里会传入 Shader 编译用到的宏定义，以及指定线程组中的线程数量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用时记得引用 FSR 给的头文件，这里包含一些数据格式</span>
<span class="token comment">// 以及用来计算 uniform 常量的函数 FsrEasuCon</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ffx_a.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ffx_fsr1.h"</span></span>

<span class="token comment">// FidelityFX-FSR\sample\src\DX12\FSR_Filter.cpp</span>
<span class="token keyword">void</span> <span class="token class-name">FSR_Filter</span><span class="token double-colon punctuation">::</span><span class="token function">OnCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    defines<span class="token punctuation">[</span><span class="token string">"SAMPLE_RCAS"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span>
    defines<span class="token punctuation">[</span><span class="token string">"SAMPLE_EASU"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>

    m_easu<span class="token punctuation">.</span><span class="token function">OnCreate</span><span class="token punctuation">(</span>pDevice<span class="token punctuation">,</span> pResourceViewHeaps<span class="token punctuation">,</span> <span class="token string">"FSR_Pass.hlsl"</span><span class="token punctuation">,</span> <span class="token string">"mainCS"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> 
        <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>defines<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// NVIDA 中调度的基本单位 warp 大小是 32 个线程</span>
    <span class="token comment">// AMD   中调度的基本单位 warefront 大小是 64 个线程</span>
    <span class="token comment">// 因此这里采用了 64 的倍数</span>
    <span class="token comment">// cs 代码中每个线程组创建 64 * 1 * 1 线程</span>

    <span class="token comment">// m_easu.OnCreate 函数调用会定义如下三个宏，在 FSR_Pass.hlsl 中会用到</span>
    <span class="token comment">// defines["WIDTH" ] = std::to_string(params.dwWidth);</span>
    <span class="token comment">// defines["HEIGHT"] = std::to_string(params.dwHeight);</span>
    <span class="token comment">// defines["DEPTH" ] = std::to_string(params.dwDepth);</span>
    
    defines<span class="token punctuation">[</span><span class="token string">"SAMPLE_EASU"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span>
    defines<span class="token punctuation">[</span><span class="token string">"SAMPLE_RCAS"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>
    <span class="token comment">// cs 代码中每个线程组创建 64 * 1 * 1 线程</span>
    m_rcas<span class="token punctuation">.</span><span class="token function">OnCreate</span><span class="token punctuation">(</span>pDevice<span class="token punctuation">,</span> pResourceViewHeaps<span class="token punctuation">,</span> <span class="token string">"FSR_Pass.hlsl"</span><span class="token punctuation">,</span> <span class="token string">"mainCS"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> 
        <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>defines<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每帧渲染时 FSR 更新分为三个步骤：</p><ul><li>FsrEasuCon：计算 FSR 用到的常数 uniform，用于计算像素点对应超采前像素位置信息</li><li>EASU：调用 easu Compute Shader 进行上采样</li><li>RCAS：调用 rcas Compute Shader 进行锐化操作</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">FSRConstants</span>
<span class="token punctuation">&#123;</span>
    XMUINT4 Const0<span class="token punctuation">;</span>
    XMUINT4 Const1<span class="token punctuation">;</span>
    XMUINT4 Const2<span class="token punctuation">;</span>
    XMUINT4 Const3<span class="token punctuation">;</span>
    XMUINT4 Sample<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">FSR_Filter</span><span class="token double-colon punctuation">::</span><span class="token function">Upscale</span><span class="token punctuation">(</span>ID3D12GraphicsCommandList<span class="token operator">*</span> pCommandList<span class="token punctuation">,</span> <span class="token keyword">int</span> displayWidth<span class="token punctuation">,</span> 
    <span class="token keyword">int</span> displayHeight<span class="token punctuation">,</span> State<span class="token operator">*</span> pState<span class="token punctuation">,</span> DynamicBufferRing<span class="token operator">*</span> pConstantBufferRing<span class="token punctuation">,</span> <span class="token keyword">bool</span> hdr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/// Step 1:</span>
    <span class="token function">FsrEasuCon</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AU1<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>consts<span class="token punctuation">.</span>Const0<span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AU1<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>consts<span class="token punctuation">.</span>Const1<span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AU1<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>consts<span class="token punctuation">.</span>Const2<span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AU1<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>consts<span class="token punctuation">.</span>Const3<span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AF1<span class="token operator">></span></span></span><span class="token punctuation">(</span>pState<span class="token operator">-></span>renderWidth<span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AF1<span class="token operator">></span></span></span><span class="token punctuation">(</span>pState<span class="token operator">-></span>renderHeight<span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AF1<span class="token operator">></span></span></span><span class="token punctuation">(</span>pState<span class="token operator">-></span>renderWidth<span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>AF1<span class="token operator">></span></span></span><span class="token punctuation">(</span>pState<span class="token operator">-></span>renderHeight<span class="token punctuation">)</span><span class="token punctuation">,</span> 
        <span class="token punctuation">(</span>AF1<span class="token punctuation">)</span>displayWidth<span class="token punctuation">,</span> <span class="token punctuation">(</span>AF1<span class="token punctuation">)</span>displayHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/// 将超采图像按照 16 * 16 大小分割成若干个线程组</span>
    <span class="token comment">/// 超采后分辨率 1920 * 1080 会对应创建 120 * 68 个 compute shader 线程组</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> threadGroupWorkRegionDim <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> dispatchX <span class="token operator">=</span> <span class="token punctuation">(</span>displayWidth <span class="token operator">+</span> <span class="token punctuation">(</span>threadGroupWorkRegionDim <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> 
        threadGroupWorkRegionDim<span class="token punctuation">;</span>

    <span class="token keyword">int</span> dispatchY <span class="token operator">=</span> <span class="token punctuation">(</span>displayHeight <span class="token operator">+</span> <span class="token punctuation">(</span>threadGroupWorkRegionDim <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> 
        threadGroupWorkRegionDim<span class="token punctuation">;</span>

    <span class="token comment">/// Step 2:</span>
    m_easu<span class="token punctuation">.</span><span class="token function">Draw</span><span class="token punctuation">(</span>pCommandList<span class="token punctuation">,</span> cbHandle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_intermediaryUav<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_inputTextureSrv<span class="token punctuation">,</span> 
        dispatchX<span class="token punctuation">,</span> dispatchY<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/// Step 3:</span>
    m_rcas<span class="token punctuation">.</span><span class="token function">Draw</span><span class="token punctuation">(</span>pCommandList<span class="token punctuation">,</span> cbHandle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_outputTextureUav<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_intermediarySrv<span class="token punctuation">,</span> 
        dispatchX<span class="token punctuation">,</span> dispatchY<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FSR 中对图片处理的切割如下图所示，将超分图像按照 16 * 16 切分成块，每个线程组处理一块，然后在 CS 中将 16 * 16 的块切分成 8 * 8 的小块，对应 8 * 8 个线程，每个线程处理 4 个像素，如下图紫色框所示：</p><div data-align="center"><p><img data-src="/images/amd_fsr/cs_split.svg" width="80%" height="80%"></p></div><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl"><span class="token comment">// FidelityFX-FSR\sample\src\DX12\FSR_Pass.hlsl</span>

<span class="token comment">// 每个线程组中对应的线程数量是：64 * 1 * 1 </span>
<span class="token punctuation">[</span><span class="token function">numthreads</span><span class="token punctuation">(</span>WIDTH<span class="token punctuation">,</span> HEIGHT<span class="token punctuation">,</span> DEPTH<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">void</span> <span class="token function">mainCS</span><span class="token punctuation">(</span><span class="token keyword">uint3</span> LocalThreadId <span class="token operator">:</span> SV_GroupThreadID<span class="token punctuation">,</span> <span class="token keyword">uint3</span> WorkGroupId <span class="token operator">:</span> SV_GroupID<span class="token punctuation">,</span> 
    <span class="token keyword">uint3</span> Dtid <span class="token operator">:</span> SV_DispatchThreadID<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 根据线程组 WorkGroupId 我们可以知道当前处理的切片编号（例如上图右边 粉红色区域 (2, 1) ）</span>
    <span class="token comment">// 根据线程 LocalThreadId 我们可以知道当前处理的是左上角 8 * 8 中的像素编号</span>
    <span class="token comment">//  （例如上图 A 区域中的紫色像素  (3, 2) ）</span>
    AU2 gxy <span class="token operator">=</span> <span class="token function">ARmp8x8</span><span class="token punctuation">(</span>LocalThreadId<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">AU2</span><span class="token punctuation">(</span>WorkGroupId<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token number">4u</span><span class="token punctuation">,</span> WorkGroupId<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> <span class="token number">4u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/// A 区域</span>
    <span class="token function">CurrFilter</span><span class="token punctuation">(</span>gxy<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/// B 区域</span>
    gxy<span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">8u</span><span class="token punctuation">;</span>
    <span class="token function">CurrFilter</span><span class="token punctuation">(</span>gxy<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/// C 区域</span>
    gxy<span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token number">8u</span><span class="token punctuation">;</span>
    <span class="token function">CurrFilter</span><span class="token punctuation">(</span>gxy<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/// D 区域</span>
    gxy<span class="token punctuation">.</span>x <span class="token operator">-=</span> <span class="token number">8u</span><span class="token punctuation">;</span>
    <span class="token function">CurrFilter</span><span class="token punctuation">(</span>gxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">CurrFilter</span><span class="token punctuation">(</span>AU2 pos<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">SAMPLE_EASU</span></span>
    AH3 c<span class="token punctuation">;</span>
    <span class="token function">FsrEasuH</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> Const0<span class="token punctuation">,</span> Const1<span class="token punctuation">,</span> Const2<span class="token punctuation">,</span> Const3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> Sample<span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>
        c <span class="token operator">*=</span> c<span class="token punctuation">;</span>
    <span class="token function">imageStore</span><span class="token punctuation">(</span>OutputTexture<span class="token punctuation">,</span> <span class="token function">ASU2</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">AH4</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">SAMPLE_RCAS</span></span>
    AH3 c<span class="token punctuation">;</span>
    <span class="token function">FsrRcasH</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>r<span class="token punctuation">,</span> c<span class="token punctuation">.</span>g<span class="token punctuation">,</span> c<span class="token punctuation">.</span>b<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> Const0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> Sample<span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>
        c <span class="token operator">*=</span> c<span class="token punctuation">;</span>
    <span class="token function">imageStore</span><span class="token punctuation">(</span>OutputTexture<span class="token punctuation">,</span> <span class="token function">ASU2</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">AH4</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="fsr-超分部分">FSR 超分部分</h2><p>FSR 超分部分包含两个部分，上采样（EASU）+ 锐化（RCAS），接下来对这几部分做详细分析。</p><h3 id="easuedge-adaptive-spatial-upsamping">EASU（Edge Adaptive Spatial Upsamping）</h3><p>首先我们看下使用双线性插值来做图像放大的效果，下面是一张 128 * 128 的图片，我们将其放大 2 倍。</p><table><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr class="header"><th><img data-src="/images/amd_fsr/sample_mid.png" width="128" height="128"></th><th><img data-src="/images/amd_fsr/scale_b.png" width="256" height="256"></th></tr></thead><tbody></tbody></table><p>可以看到，图像出现了模糊，主要是因为边缘部分的像素出现了锯齿，因此在放大图像的过程中，需要对边缘部分进行特殊处理。</p><h4 id="边缘跟非边缘的上采样">边缘跟非边缘的上采样</h4><p>使用 EASU 进行上采样，对图像进行放大时，放大后的像素有两种情况</p><ul><li>非边缘：如果是非边缘，则对于放大后的像素点 <span class="math inline">\(P\)</span>，在原图对应像素点 <span class="math inline">\(Q\)</span>，则 <span class="math inline">\(Q\)</span> 附近的像素灰度应该非常接近，此时只需要对 <span class="math inline">\(Q\)</span> 周围的像素进行加权平均即可：</li></ul><p><span class="math display">\[ f(P) = \frac{\sum_i f(Q_i)\omega_i}{\sum_i \omega_i} \tag{1} \]</span></p><div class="note info"><ol type="1"><li><span class="math inline">\(f(x)\)</span>: 采样像素 x 点的灰度值</li><li><span class="math inline">\(\omega_i\)</span>: 为权重（正数）</li></ol></div><ul><li>边缘：如果此时像素点 <span class="math inline">\(P\)</span> 为边缘时，如果按照公式 (1) 处理，则边缘就会变模糊，因此根据边缘锐化的思路，对边缘进行上采样为：</li></ul><p><span class="math display">\[ f(P) = f(Q) + \lambda F(Q) \tag{2} \]</span></p><div class="note info"><ol type="1"><li><span class="math inline">\(F(Q)\)</span>: 为高频滤波器，用来提取边缘信息</li><li><span class="math inline">\(\lambda\)</span>: 为缩放因子</li></ol></div><p>例如：4 领域的 <strong>拉普拉斯算子</strong>就是一个常用的高频滤波器（图像边缘处的像素变化大，也就是高频数据）</p><div data-align="center"><p><img data-src="/images/amd_fsr/sobe.svg" width="50%" height="50%"></p></div><p>使用算子后得到：</p><p><span class="math display">\[ F(Q)=|4f(Q_{x,y}) - f(Q_{x-1, y}) - f(Q_{x+1, y}) - f(Q_{x,y-1}) - f(Q_{x, y+1})| \tag{3} \]</span></p><div class="note info"><p>如果 <span class="math inline">\(Q_{x,y}\)</span> 周围像素的灰度值变化越小（低频，非边缘），则 <span class="math inline">\(F(Q)\)</span> 越小，灰度值变化越大（高频，边缘）则 <span class="math inline">\(F(Q)\)</span> 越大。其实本质上还是加权法，只是权重有负数（为了计算像素之间的差值）。</p></div><p>因此可以将边缘跟非边缘的计算方法统一成一个表达式：</p><p><span class="math display">\[ f(P) = \frac{\sum_i f(Q_i)H(Q_i)}{\sum_i H(Q_i)} \tag{4} \]</span></p><div class="note info"><p><span class="math inline">\(H(Q_i)\)</span>: 权重计算公式，而且应该满足当 Q 点为非边缘时，权重为正数，Q 点为边缘时，<span class="math inline">\(H(Q_i)\)</span> 中会包含负的权重，用来计算高频滤波器，因此接下来就是要找到满足这样条件的权重计算公式。</p></div><h4 id="lanczos2-函数">Lanczos2 函数</h4><p>EASU 引入了 Lanczos 函数：</p><p><span class="math display">\[ L(x) = \frac{asin(\pi x)sin(\frac{\pi x}{a})}{\pi^2 x^2}, x \in [-a, a] \tag{5} \]</span></p><div class="note info"><p>当 <span class="math inline">\(a = 2\)</span> 时，通常将其成为 Lanczons2 函数， EASU 就是基于 Lanczos2 函数作为基础处理的，它的图像如下图所示。</p></div><div data-align="center"><p><img data-src="/images/amd_fsr/lanczos2.png" width="80%" height="80%"></p></div><p>Lanczons2 函数的值在 <span class="math inline">\(x\in [0,1]\)</span> 时函数值大于 0，<span class="math inline">\(x \in [1, 2]\)</span> 部分，函数值小于 0。但是函数包含了三角函数，在 Shader 中效率不高，因此 EASU 用多项式来拟合公式 (5)。</p><p><span class="math display">\[ L(x) = \left[\frac{25}{16}\left( \frac{2}{5} x^2 - 1 \right)^2 - \left( \frac{25}{16} - 1 \right) \right](\omega x^2 - 1)^2 \tag{6} \]</span></p><p>其中 <span class="math inline">\(\omega\)</span> 参数可以用来控制函数在 <span class="math inline">\(x \in [1, 2]\)</span> 部分的值，下面是 <span class="math inline">\(w\)</span> 从 0 变化到 0.5 过程中的函数图像</p><div data-align="center"><p><img data-src="/images/amd_fsr/lw.png" width="80%" height="80%"></p></div><div class="note primary"><p>拖拽紫色的拖拽点，可以改变 <span class="math inline">\(\omega\)</span> 的值，点击右下角 desmos 可以跳转对应的公式编辑器。</p></div><iframe src="https://www.desmos.com/calculator/yedg3kmoxd?embed" width="700" height="300" style="border:1px solid #ccc" frameborder="0"></iframe><h4 id="边缘特征">边缘特征</h4><p>图像中的边缘，一般有如下几种情况：</p><div data-align="center"><p><img data-src="/images/amd_fsr/edge_type.jpg" width="80%" height="80%"></p></div><p>EASU 主要是解决阶梯状边缘，因此特征约接近阶梯状边缘，对应的 <span class="math inline">\(\omega\)</span> 应该越小，即当 <span class="math inline">\(x \in [1,2]\)</span> 时 <span class="math inline">\(L(x)\)</span> 返回的权重小于 0，同时对应像素 <span class="math inline">\(Q\)</span> 计算上下左右方向上的像素点，定义特征 <span class="math inline">\(F\)</span> 的计算公式（<strong>这里 <span class="math inline">\(f(x)\)</span> 获得做过灰度化处理后的颜色值</strong>）：</p><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl"><span class="token comment">// Simplest multi-channel approximate luma possible (luma times 2, in 2 FMA/MAD).</span>
<span class="token keyword">float</span> l <span class="token operator">=</span> b <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">+</span> r <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">+</span> g<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><span class="math display">\[ \begin{aligned} F &amp;= (FX^2 + FY^2) \\ FX &amp;= \frac{ |f-d| }{ max(|f-e|, |e-d|) } = \frac{|f(Q_{x+1,y})-f(Q_{x-1,y})|}{max \left( |f(Q_{x,y}) - f(Q_{x-1,y})|, |f(Q_{x+1,y}) - f(Q_{x,y})| \right) } \\ FX &amp;= \frac{ |i-b| }{ max(|i-e|, |e-b|) } = \frac{|f(Q_{x,y-1})-f(Q_{x,y+1})|}{max \left( |f(Q_{x,y+1}) - f(Q_{x,y})|, |f(Q_{x,y}) - f(Q_{x,y-1})| \right) } \end{aligned} \tag{7} \]</span></p><div data-align="center"><p><img data-src="/images/amd_fsr/feture_nerbor.svg" width="20%" height="20%"></p></div><p>EASU 最后还对 <span class="math inline">\(FX^2\)</span>、<span class="math inline">\(FY^2\)</span> 的值做了限制，将其限制在 <span class="math inline">\([0,1]\)</span> 范围内</p><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl">A_STATIC AF1 <span class="token function">ASatF1</span><span class="token punctuation">(</span>AF1 a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">AMinF1</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token function">AMaxF1</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
lenX<span class="token operator">=</span><span class="token function">ASatF1</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>dirX<span class="token punctuation">)</span><span class="token operator">*</span>lenX<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后将 <span class="math inline">\(F\)</span> 的值归一化后，得到 <span class="math inline">\(Feature\)</span> 的计算公式：</p><p><span class="math display">\[ Feature = \left( \frac{F}{2} \right)^2 \tag{8} \]</span></p><div class="note info"><p>当像素是边缘的时候，<span class="math inline">\(Feature\)</span> 的值越大，接近 1，反之则越小，趋近于 0</p></div><h4 id="边缘特征-feature-跟变量-omega">边缘特征 <span class="math inline">\(Feature\)</span> 跟变量 <span class="math inline">\(\omega\)</span></h4><p>前面我们已经找到了区分边缘的特征值 <span class="math inline">\(Feature\)</span>，以及可以通过 <span class="math inline">\(\omega\)</span> 调整区间 <span class="math inline">\([1,2]\)</span> 取值范围的拟合曲线了（公式 6），接下来就是要建立 <span class="math inline">\(Feature\)</span> 跟 <span class="math inline">\(\omega\)</span> 之间的联系。</p><div data-align="center"><p><img data-src="/images/amd_fsr/x_w.png" width="80%" height="80%"></p></div><p>公式 6 中的函数 <span class="math inline">\(L(x), x \in [-2,2]\)</span> 是关于 <span class="math inline">\(y\)</span> 轴对称的，因此这里只分析正半轴（事实上，EASU 里也只用到了正半轴），在正半轴上 <span class="math inline">\(L(x)\)</span> 有三个根：<span class="math inline">\(x=1;x=2;x=\frac{ 1 }{ \sqrt {\omega} }, (\omega &gt; 0)\)</span>。</p><p>当 <span class="math inline">\(\frac{1}{ \sqrt{\omega} } \in [1,2]\)</span> 时（<span class="math inline">\(\omega \in [\frac{1}{4}, 1]\)</span>），区间 <span class="math inline">\([1, \frac{1}{ \sqrt{\omega} }]\)</span> 中有一个极小值 <span class="math inline">\(m\)</span>。</p><ul><li><span class="math inline">\(\frac{1}{ \sqrt{\omega} } \rightarrow 1\)</span> : <span class="math inline">\(m \rightarrow 0\)</span></li><li><span class="math inline">\(\frac{1}{ \sqrt{\omega} } \rightarrow 2\)</span> : <span class="math inline">\(m \rightarrow -\frac{2187}{16483}\)</span></li></ul><p>因此可以通过改变 <span class="math inline">\(\frac{1}{ \sqrt{\omega} }\)</span> 的值来控制 <span class="math inline">\([1, \frac{1}{ \sqrt{\omega} }]\)</span> 区间里负值的大小（用来做公式 4 中的负权重）。</p><p><span class="math display">\[ \omega = 1 - \frac{3}{4}Feature \tag{9} \]</span></p><p>但是由于 <span class="math inline">\(\frac{1}{ \sqrt{\omega} }\)</span> 在趋近于 <span class="math inline">\(1\)</span> 时，负权重不够，会导致边缘信息识别不够，因此 EASU 将 <span class="math inline">\(\frac{1}{ \sqrt{\omega} }\)</span> 的范围限定在 <span class="math inline">\([\sqrt{2}, 2]\)</span>，因此 <span class="math inline">\(\omega \in [\frac{1}{4}, \frac{1}{2}]\)</span>，得出新的线性关系：</p><p><span class="math display">\[ \omega = \frac{1}{2} - \frac{1}{4}Feature \tag{10} \]</span></p><p>下面是拟合曲线根据 <span class="math inline">\(Feature\)</span> 变化图像：</p><iframe src="https://www.desmos.com/calculator/xp1effgzhc?embed" width="800" height="300" style="border:1px solid #ccc" frameborder="0"></iframe><div class="note info"><p>ESAU 同时限定了 <span class="math inline">\(x\)</span> 的范围为 <span class="math inline">\(x \in [0, \frac{1}{\sqrt{\omega}} ]\)</span>，即 <span class="math inline">\(x = min(x, \frac{1}{\sqrt{\omega}} )\)</span></p></div><h4 id="feature-获得"><span class="math inline">\(Feature\)</span> 获得</h4><p>EASU 计算 <span class="math inline">\(Q\)</span> 点特征时，因为最终算出来的 <span class="math inline">\(Q\)</span> 不一定是整数，因此采用的是采样像素点 <span class="math inline">\(Q\)</span> 周围 12 个像素的值来计算，首先 EASU 进行 12 次采样，分别获取像素 <span class="math inline">\(Q\)</span> 周围点的像素值：</p><div data-align="center"><p><img data-src="/images/amd_fsr/get_pixel.svg" width="20%" height="20%"></p></div><div class="note info"><ol type="1"><li>上图中的 <span class="math inline">\(f\)</span> 是对应超采前的像素点 <span class="math inline">\(Q\)</span></li><li>每次使用 Gather4 指令批量采样 4 个像素点中的一个通道，例如浅绿色框采样的顺序是 ijfe，因为像素有三个通道 RGB，因此最终是 4 * 3 次采样（z 表示多余的像素，计算时不会用到）。</li></ol></div><p>然后，计算特征时，分四组分别计算出 4 个 <span class="math inline">\(Feature\)</span></p><div data-align="center"><p><img data-src="/images/amd_fsr/f_group.svg" width="80%" height="80%"></p></div><p>然后再使用双线性插值得到最终 <span class="math inline">\(Feature\)</span>，如下图所示 <span class="math inline">\(O = floor(Q)\)</span>，<span class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span> 则是 <span class="math inline">\(Q\)</span> 到 <span class="math inline">\(O\)</span> 的偏移。</p><div data-align="center"><p><img data-src="/images/amd_fsr/f_bl.svg" width="30%" height="30%"></p></div><p><span class="math display">\[ Feature = (1-u)(1-v)f_1 + u(1-v)f_2 + uvf_3 + (1-u)vf_4 \tag{11} \]</span></p><h4 id="梯度">梯度</h4><p>计算 <span class="math inline">\(Feature\)</span> 的同时，EASU 还计算了 <span class="math inline">\(Q\)</span> 点的像素灰度变化的梯度（灰度值变化最快的方向），同样也是分 4 组计算梯度，最后双线性插值得出最终的梯度向量。</p><p><span class="math display">\[ \begin{aligned} D_x &amp;= f - d = f(Q_{x+1, y}) - f(Q_{x-1, y}) \\ D_y &amp;= i - b = f(Q_{x, y+1}) - f(Q_{x, y-1}) \end{aligned} \tag{12} \]</span></p><div data-align="center"><p><img data-src="/images/amd_fsr/feture_nerbor.svg" width="20%" height="20%"></p></div><div class="note info"><p><span class="math inline">\(\vec{D} = (cos\theta, sin\theta)\)</span>，其中 <span class="math inline">\(\theta\)</span> 是梯度向量角度</p></div><div data-align="center"><p><img data-src="/images/amd_fsr/dir.svg" width="20%" height="20%"></p></div><h4 id="采样颜色值">采样颜色值</h4><p>到这里我们得到了像素 <span class="math inline">\(Q\)</span> 的梯度，以及 <span class="math inline">\(Feature\)</span>，然后分别对 <span class="math inline">\(Q\)</span> 周围的 12 个采样点，按照梯度角度进行旋转（这部分是个人理解，希望有大佬能指点一下，因为边缘不一定是水平方向上的边缘，会按照梯度来，但是我们可以按照梯度旋转后，将边缘旋转到阶梯状边缘，EASU 这里选择的是旋转采样核）。</p><div data-align="center"><p><img data-src="/images/amd_fsr/f_rotate_2.svg" width="60%" height="60%"></p></div><div class="note info"><p>上图展示的 <span class="math inline">\(\vec{D} = (cos45 ^{\circ}, sin45 ^{\circ})\)</span> （红色箭头）下的情况，注意 <span class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span> 轴的正方向，旋转是按照向量原点，顺时针旋转 <span class="math inline">\(\theta\)</span> 角度。</p></div><p>如上图，采样点 <span class="math inline">\(b\)</span> 跟 <span class="math inline">\(Q\)</span> 之间的向量 <span class="math inline">\(\vec{QB}\)</span> 按照梯度旋转：</p><p><span class="math display">\[ \begin{aligned} x_r &amp;= x_{QB} * cos\theta + y_{QB} * sin \theta \\ y_r &amp;= -x_{QB} * sin \theta + y_{QB} * cos \theta \end{aligned} \tag{13} \]</span></p><p>旋转完毕后， 采样核不再是中心对称了，因此 EASU 定义了一个将旋转向量根据 <strong>梯度</strong> 和 <strong>边缘特征</strong> 进行缩放的公式：</p><p><span class="math display">\[ \begin{aligned} Stretch &amp;= \frac{ 1 }{ max(|sin\theta|, |cos\theta|) } \\ S_x &amp;= 1 + (Stretch - 1) * Feature \\ S_y &amp;= 1 - 0.5 * Feature \end{aligned} \tag{14} \]</span></p><p>然后得出 <span class="math inline">\(QB\)</span> 旋转缩放后向量坐标:</p><p><span class="math display">\[ \begin{aligned} S_{xb} = x_r * S_x \\ S_{yb} = y_r * S_y \\ \end{aligned} \tag{15} \]</span></p><p>最后求出向量的模：</p><p><span class="math display">\[ d_b = min( \sqrt{S_{xb}^2 + S_{yb}^2}, \frac{ 1 }{ \sqrt{\omega} } ) \tag{16} \]</span></p><p>将得出的 <span class="math inline">\(d_b\)</span> 带入到公式 6，求出 <span class="math inline">\(b\)</span> 像素点的权重值</p><div class="note success"><p>这里使用了采样点 <span class="math inline">\(Q_i\)</span> 到 <span class="math inline">\(Q\)</span> 的欧式距离来应用之前的权重公式 <span class="math display">\[ L(x) = \left[\frac{25}{16}\left( \frac{2}{5} x^2 - 1 \right)^2 - \left( \frac{25}{16} - 1 \right) \right](\omega x^2 - 1)^2 \tag{6} \]</span></p></div><p>其他像素点依次按照这样的方法求出对应像素的权重值，最后利用公式 4，即可求出上采样 <span class="math inline">\(P\)</span> 点的像素值。</p><div class="note success"><p><span class="math display">\[ f(P) = \frac{\sum_i f(Q_i)H(Q_i)}{\sum_i H(Q_i)} \tag{4} \]</span></p></div><p>EASU 里最后会对求出的颜色做限制，限制颜色的最大最小值只能在这 12 个采样点颜色之间，据说可以减少 ringing 效果。</p><pre class="line-numbers language-hlsl" data-language="hlsl"><code class="language-hlsl"><span class="token comment">/// aw 是公式 4 的分子</span>
<span class="token comment">/// ac 是公式 4 的分母的倒数</span>
<span class="token comment">/// min4 max4 是 12 个采样点的最小最大颜色值（RGB）</span>
pix<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>max4<span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>min4<span class="token punctuation">,</span>aC<span class="token operator">*</span><span class="token function">AF3_</span><span class="token punctuation">(</span><span class="token function">ARcpF1</span><span class="token punctuation">(</span>aW<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结">总结</h4><p>总结一下，EASU 阶段其实就是根据像素灰度，计算得到 <span class="math inline">\(Feature\)</span>，然后得到 <span class="math inline">\(\omega\)</span>，用来调整拟合曲线的窗口</p><ul><li>当像素越接近边缘像素时：拟合函数返回负权重，用来提取边缘，锐化效果强</li><li>当像素越接近非边缘像素时：拟合函数返回正数，用来平滑非边缘像素</li></ul><h3 id="rcasrobust-contrast-adaptive-sharpening">RCAS（Robust Contrast Adaptive Sharpening）</h3><p>上采样结束后，FSR 最后对上采样得到的图像进行一次 RCAS （在 CAS 基础进行改进）的锐化处理，将边缘的信息进一步强化，RCAS 其实是拉普拉斯算子的变种：</p><div data-align="center"><p><img data-src="/images/amd_fsr/rcas.svg" width="20%" height="20%"></p></div><p>则最后像素 <span class="math inline">\(P\)</span> 按照上面的算子进行加权计算即可：</p><p><span class="math display">\[ F(P) = \frac{ f(P) + w * ( f(P_{x-1,y}) + f(P_{x+1,y}) + f(P_{x,y-1}) + f(P_{x,y+1}) ) }{4\omega + 1} \tag{17} \]</span></p><div class="note info"><p>这里需要从已经超分后的图像上进行采样颜色，需要采样 5 个点的像素值</p></div><p>对于 <span class="math inline">\(\omega\)</span> 权重，RCAS 计算方法是获取像素 <span class="math inline">\(P\)</span> 点周围四个像素的值来计算，先求出这 5 个像素的最大值 MAX，最小值 MIN，这里也是用到是颜色值来计算。</p><div data-align="center"><p><img data-src="/images/amd_fsr/rcas_w.svg" width="70%" height="70%"></p></div><p><span class="math display">\[ \omega = max \left( -\frac{Min}{4Max}, \frac{ 1-Max }{ 4Min - 4 } \right) * Scale \tag{18} \]</span></p><div class="note info"><p><span class="math inline">\(Scale\)</span> 为采样之后分辨率跟原分辨率的比值。</p></div><p>RCAS 中为了确保 <span class="math inline">\(\omega\)</span> 为负数，最后对 <span class="math inline">\(\omega\)</span> 做了限制：</p><p><span class="math display">\[ \omega = max \left( -\left(\frac{1}{4} - \frac{1}{16} \right), min (\omega, 0) \right) \]</span></p><div class="note info"><p>对于每个通道 <span class="math inline">\(RGB\)</span> 都计算一次对应的 <span class="math inline">\(w_R\)</span>、<span class="math inline">\(w_G\)</span>、 <span class="math inline">\(w_B\)</span></p></div><table><colgroup><col style="width:33%"><col style="width:33%"><col style="width:33%"></colgroup><thead><tr class="header"><th style="text-align:center">原图</th><th style="text-align:center">双线性插值</th><th style="text-align:center">FSR</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><img data-src="/images/amd_fsr/sample_mid.png" width="128" height="128"></td><td style="text-align:center"><img data-src="/images/amd_fsr/scale_b.png" width="256" height="256"></td><td style="text-align:center"><img data-src="/images/amd_fsr/scale_fsr.png" width="256" height="256"></td></tr></tbody></table><div class="note info"><p>这里写了个 <a target="_blank" rel="noopener" href="https://github.com/qq317423892/FSR_PY.git">python 版的 FSR</a> 来测试对比结果。</p></div><h2 id="后续">后续</h2><h3 id="fsr-1.0">FSR 1.0</h3><p>EASU 阶段采样 12 像素，耗时比较多，KM 上介绍了一个种 5-Tap <sup><a href="#ref-anchor-4">4</a></sup> 的 Lanczos2 的卷积，可以减少 EASU 阶段的开销，当然效果上也会有一些些打折。</p><h3 id="fsr-2.0">FSR 2.0</h3><p>FSR 2.0 增加了时域上的缩放算法，会使用上一帧的数据， FSR 2.0 效果更细腻，自带 TSAA，但是开销非常大，建议在 PC 平台上使用 FSR 2.0，设备推荐使用 FSR 1.0，后续会研究下 FSR 2.0。</p><h2 id="参考">参考</h2><div id="ref-anchor-1"></div><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/401030221">1.详细剖析 AMD FSR 算法</a></p><div id="ref-anchor-2"></div><p><a target="_blank" rel="noopener" href="https://github.com/GPUOpen-Effects/FidelityFX-FSR/blob/master/docs/FidelityFX-FSR-Overview-Integration.pdf">2.FidelityFX-FSR 官方文档</a></p><div id="ref-anchor-3"></div><p><a target="_blank" rel="noopener" href="https://github.com/GPUOpen-Effects/FidelityFX-FSR.git">3.FidelityFX-FSR 源码</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343858207">4.图像处理学习笔记（十四）——图像边缘锐化的基本方法(理论篇)</a></p><div id="ref-anchor-4"></div><p><a target="_blank" rel="noopener" href="https://vec3.ca/bicubic-filtering-in-fewer-taps">5.Bicubic Filtering in Fewer Taps</a></p></div><footer class="post-footer"><div class="license"><div class="license-title">FSR 技术原理</div><div class="license-link"><a href="https://www.xianlongok.site/post/30ae96f7/">https://www.xianlongok.site/post/30ae96f7/</a></div><div class="license-meta"><div class="license-meta-item"><div class="license-meta-title">本文作者</div><div class="license-meta-text">小贤</div></div><div class="license-meta-item"><div class="license-meta-title">发布于</div><div class="license-meta-text">2023-10-27</div></div><div class="license-meta-item"><div class="license-meta-title">更新于</div><div class="license-meta-text">2023-10-27</div></div><div class="license-meta-item"><div class="license-meta-title">许可协议</div><div class="license-meta-text"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank">CC BY-NC-SA 4.0</a></div></div></div><div class="license-statement">转载或引用本文时，请遵守上述许可协议，注明出处、不得用于商业用途！</div></div><div class="post-tags"><a href="/tags/FSR/" rel="tag"><i class="fa fa-tag"></i> FSR</a> <a href="/tags/AMD/" rel="tag"><i class="fa fa-tag"></i> AMD</a> <a href="/tags/FidelityFX-FSR/" rel="tag"><i class="fa fa-tag"></i> FidelityFX-FSR</a></div><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a href="/post/3725508f/" rel="next" title="实时阴影技术">实时阴影技术 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fas fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">小贤</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">267k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">4:02</span></span></div><div class="powered"><a href="https://dlzhang.com" rel="noopener" target="_blank">小贤</a>使用 <a href="https://hexo.io" rel="noopener" target="_blank">Hexo</a> <a href="https://theme-next.js.org" rel="noopener" target="_blank">NexT</a> 设计搭建</div></div></footer><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"dkLUcqHORjRdwQiwRPJMs00N-gzGzoHsz","app_key":"EhWnaex3YyY7bQysJ2SFnukE","server_url":null,"security":false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://www.xianlongok.work","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"libUrl":"https://unpkg.com/@waline/client@v2/dist/waline.js","login":"disable","meta":["nick","mail","link"],"requiredMeta":["nick","mail"],"pageSize":5,"avatar":"mm","dark":"auto","emoji":true,"locale":{"placeholder":"请正确填写邮箱方便查收回复，评论通过审核才会显示。","admin":"站长","nick":"名称*","mail":"邮箱*","link":"网址"},"el":"#waline","comment":true,"path":"/post/30ae96f7/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false}});</script></body></html>